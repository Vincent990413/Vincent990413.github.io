[{"title":"uniapp学习笔记01-基本语法","url":"/2021/06/20/uniapp学习笔记01-基本语法/","content":"# Uni-App 教程\n**截图，笔记均转自哔哩哔哩黑马程序员。**\n![Uniapp黑马大纲](https://img-blog.csdnimg.cn/20210620170345210.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n## Uniapp 介绍\n`uniapp`是一个使用Vue.js开发所有前端应用的框架，可发布到IOS、Android、微信小程序等平台。\n\n官网文档：\n\n[点我进入uniapp官网文档](https://uniapp.dcloud.io/)\n\n**1. Vue以及微信小程序开发经验。**\n\n第一次用**微信小程序预览**时需要注意：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210620172547748.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n而且需要将**微信开发工具的安全端口**打开。\n\n## 介绍项目目录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210620180029729.png)\n其中：\n1. pages 存放页面相关.vue。\n2. static 存放静态资源（图片、音频或者视频等）。\n3. unpackage 存放打包后的资源，比如H5原生或者微信小程序等等。\n4. pages.json对uni-app进行全局配置，决定页面文件的路径、窗口样式、原生导航栏以及底部的原生Tabbar等。\n5. manifest.json时应用的配置文件，用于指定应用的名称、图标以及权限等。\n6. App.vue时项目入口组件，main.js时用于初始化可能需要的插件。\n7. component用于存放需要的组件。\n\nuniapp需要遵守的一些重要规范：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210620202721872.PNG)\n\n## 全局样式配置 Global Style\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210620202935401.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n以上的全局配置，会对所有页面都生效。\n\n* 注意，pages.json中的**pages中的style是属于页面级的样式。这里的样式，会覆盖掉全局样式。**\n\n## 配置页面\n在pages.json中的page去配置所有页面，而第一个页面是启动页面。\n\n```js\n{\n\t// \"path\": \"pages/index/index\"\n\t\"path\": \"pages/message/message\",\n\t\"style\": {\n\t\t\"navigationBarTitleText\": \"信息页\"\n\t\t//这里面的样式 会覆盖掉全局的样式\n\t}\n\t\"h5\":{\n\t\t//这里是h5的独有样式 见uniapp官网\n\t}\n}\n```\n\n## 配置Tabbar选项栏\n\n如果应用是一个多tab应用，那么就可以**配置相应的选项栏以及对应跳转的页面。**\n\n**tabbar与pages、globalstyle同级。**\n\n1. 如果选项卡在顶部（position:top），那么不会显示图标icon。**（只对微信小程序起作用。）**\n2. 装所有选项卡的tabBar中的list是一个数组（**长度在2~5之间**）。\n\n其他**关于tabbar的重要属性：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210620205543497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n1. color属于tabbar下的，16进制数，属于未选中时的颜色。selectedColor属于选中的颜色。borderStyle是边框颜色，只能是黑色或者白色。\n\n\n而其中的list数组中，**每一项都是一个对象，其具有的属性如下**：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210620205730703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n2. 注意，pagePath是必须在pages数组中定义的页面路径。\n\n实例代码：\n```js\n\"tabBar\": {\n\t\t\"list\": [{\n\t\t\t\t\"text\": \"首页\",\n\t\t\t\t\"pagePath\": \"pages/index/index\",\n\t\t\t\t\"iconPath\": \"static/icons/homeNotSelected.png\",\n\t\t\t\t\"selectedIconPath\": \"static/icons/homeSelected.png\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"text\": \"信息\",\n\t\t\t\t\"pagePath\": \"pages/message/message\"\n\t\t\t}\n\t\t]\n\t}\n```\n\n其中iconPath代表未选择时的图标，而selectedIconPath代表选中时的图标。\n\n图标可以去这个网站（需要科学上网）找：\n\n[点我搜索图标](https://icons8.com/icons)\n\n## condition 是启动模式配置，它主要用于模拟直达某一个页面的常见，以方便进行开发调试。该模式还在开发期间生效。\n\n[转，如何配置condition开发的直达页面](https://blog.csdn.net/qq_35366269/article/details/107647133)\n\n# uniapp 中的组件\n组件，就像HTML中的标签（div、p等等）。\n## text文本组件\n用于显示文本。是行内元素，**Text组件相当于Span标签，而View组件相当于Div。**\n\n重要属性如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621093311943.png)\n其中space属性中的值说明如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621093600886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n```js\n<view>\n\t<text selectable>这是可选中的文本</text>\n</view>\n```\n\n有时，我们在text组件内手动写了连续的空格，但默认只会显示一个空格。**想要显示多个空格，我们就可以，使用space属性，**并按照要求写对应的值。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621094021961.png)\n\ndecode我们用于`&amp;`解码成&amp;等转义字符（例如大于、小于等）。\n\n## View组件\nView相当于一个**div的容器**，盒子。且**是独占一行的！**\n\n重要属性如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621094248747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\nhover-class是**指定手动按下去的样式类**。\n\n**hover-stop-propagation表示可以阻止因手动按下去而导致的样式传播。**（比如现在有一个父组件和子组件，**如果我们只按父组件中的子组件区域，会触发父组件的样式变化，** 如果父组件写了hover-class，**如果想要阻止则使用这个属性。**）\n\nhover-start-time代表多久才出现这个点击态。需要绑定:，数字才是Number类型，否则是string类型。stay是松开手后，保留多长时间。\n\n## Button 组件\n重要属性如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621100023709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n## Image 组件\nImage组件用于显示图片。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621100237475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n* <image> 组件默认宽度 300px、高度 225px；app-nvue平台，暂时默认为屏幕宽度src 仅支持相对路径、绝对路径，支持 base64 码；\n* 页面结构复杂，css样式太多的情况，使用 image 可能导致样式生效较慢，出现 “闪一下” 的情况，此时设置 image{will-change: transform} ,可优化此问题。\n* 自定义组件里面使用 <image>时，若 src 使用相对路径可能出现路径查找失败的情况，故建议使用绝对路径。\n\n其中mode模式属性值为：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621100552167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## uniapp 中的样式\n关于uniapp中重要的样式知识点如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621101303901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n* 宽度占满屏幕，则设置`width:750rpx;代表100%`\n因此若设置375rpx，则代表设置宽度占设备的一半，自适应，根据设备宽度自动调整。rpx也适用于文字。\n\n@import可以导入外联样式表：\n```js\n@import url(\"../../static/css/global.css\");\n```\n\n* page 就相当于body节点。\n* 跟pages.json中的样式覆盖原理一样，App.vue中写的样式是全局样式，而每一个vue文件中写的，是局部样式。**局部样式会覆盖全局样式！**\n\n## uniapp 的插值表达式\n{{  variable }}\n\n见Vue的插值表达式。\n```js\n<template>\n\t<view>\n\t\t{{ info }}\n\t\t{{ 1 + 2 }}\n\t</view>\n</template>\n\n<script>\nexport....\ndata(){\n\treturn{\n\t\tinfo: \"Hello, World!\"\n\t}\n}\n</script>\n```\n \n## uniapp 的数据绑定\n见Vue的数据绑定。\n\n```js\n<template>\n\t<view>\n\t\t{{ info }}\n\t\t{{ 1 + 2 }}\n\t</view>\n</template>\n\n<script>\nexport....\ndata(){\n\treturn{\n\t\tinfo: \"Hello, World!\"\n\t}\n}\n</script>\n```\n\n\n## uniapp 的for遍历\n见Vue的for循环遍历\n\n可以**在需要引用的地方外部，写一个span，来写for.**\n\n\n## uniapp 的事件绑定以及传递参数\n见Vue的事件绑定。\n\n\n## uniapp 的生命周期\n### 应用的生命周期\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621132846575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\nApp.vue中存放应用的各个生命周期。\n\nonLaunch只会触发一次，onShow和onHide会被多次触发。\n\n```js\nonError:function(err){\n\tconsole.log('出现异常了：' + err);\n}\n```\n### 页面的生命周期\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621132900418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n* 注意，onLoad与onReady只会出现一次。而onShow和onHide会出现多次！\n\n**当切换tabBar时，会触发对应的onHide以及对应的onHide。**\n\n## 常见函数事件\n### 下拉事件：\n1. 在pages.json中的pages中的某一个页面，来配置style:\n```js\n{\n\t\"path\": \"pages/index/index\",\n\t\"style\": {\n\t\t\"navigationBarTitleText\": \"首页\",\n\t\t\"enablePullDownRefresh\": true\n\t}\n},\n```\n调用下拉的回调函数\n```js\nonPullDownRefresh(){\n\tconsole.log('检测到下拉事件');\n\tuni.stopPullDownRefresh(); //关闭下拉事件\n}\n```\n\n2. 在某事件中，指定下拉刷新（并延迟关闭下拉）：\n```js\nrefreshPage() {\n\tuni.startPullDownRefresh();\n\tsetTimeout(() => {\n\t\tuni.stopPullDownRefresh();\n\t}, 2000)\n}\n```\n\n### 到达底部事件\n```js\nonReachBottom(){\nconsole.log('在满足于pages.json中配置的距底部多少距离触发的距离后，触发！');\n}\n\n其中pages.json中配置如下：\n\"style\":{\n\t\"onReachBottomDistance\": 10\n}\n```\n\n### Get 网络请求\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210621140748917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n* 注意method如果不填，默认get方法。dataType是返回数据的类型，**如果设置为JSON，那么会对数据做一次JSON.parse。**\n* data中写get方法的请求参数。**header中写请求携带的头信息，比如token等等**。\n* \n实例代码：\n```js\nuni.request({\n\turl: \"http://localhost:8181/api/getInfo\",\n\tsuccess(res) {\n\t\tconsole.log(res);\n\t},\n\tfail(err) {\n\t\tconsole.log(\"遇到了错误：\" + err);\n\t}\n})\n```\n\n### Post请求\n\n* 我们通过指定`uni.request`中的**method来指定\"post\"即可以使用。**\n\n并且我们，直接**将一个json对象作为data。**\n\n```js\nlet _this = this\nuni.request({\n\turl: \"http://api.apishop.net/common/joke/getJokesByRandom\",\n\tdata: this.jokeForm,\n\tmethod:\"POST\",\n\t//sucess为成功回调函数 并且注意使用_this\n\tsuccess(res) {\n\t\tconsole.log(res)\n\t},\n\tfail(err) {\n\t\tconsole.log(err)\n\t}\n})\n```\n\n其他的属性以及参数，见官方文档。","tags":["前端框架学习"],"categories":["前端框架学习"]},{"title":"Vue3.0学习笔记","url":"/2021/06/14/vue3-0学习笔记/","content":"\n# Vue3.0+TypeScript 学习笔记\n# Composition API \n* 也称组合式API，是Vue3.x的新特性。通过创建Vue组件，我们可以将接口的可重复部分以及功能提取到可重用的代码段中。提高系统的可重用性。\n\n## 常用函数\n1. setup（所有CompAPI代码都写在这里）\n2. ref（字符串等类型）\n3. reactive（2、3用于定义响应式数据）（对象数据）\n4. watchEffect\n5. watch（监听数据）\n6. computed（负责复杂数据渲染）\n7. toRefs\n8. 生命周期的hooks\n\n# 创建Vue3.x项目\n* 请注意！**以后的Vue3.x代码，最好使用TypeScript作为编程语言来编写。**\n```cmd\nvue create vue3_typescript\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614142710905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n选择**手动选择**：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614142750743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**选择Vue3.0**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/202106141428131.png)\n进入项目：\n项目结构图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614143202365.png)\n## 在setup中写自适应数据\n```js\nsetup() {\n\t//ref以及reactive 用于定义响应式数据\n}\n```\n\n* ref 定义string、number、boolean以及数组等基本类型\n\n* 而reactive一般用于定义对象等组合型数据\n\n声明响应式数据：\n### 定义字符串等基本类型\n```js\n\t// ref 定义string、number、boolean以及数组等基本类型\n    var title:any = ref(\"我是一个标题\");\n```\n\n### 定义对象\n```js\n     //而reactive一般用于定义对象等组合型数据\n    var userInfo:any = reactive({\n      username: \"vincent\",\n      age: 20,\n    });\n```\n\n### **我们需要将他们作为setup()函数的返回值！让前端页面能引用到。**\n\n**Vue3.0 + TypeScript 完整demo代码是：**\n\nHome.vue\n```js\n<template>\n  <div class=\"home\">\n    <div>\n      {{ userInfo }}\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, reactive, ref } from \"vue\";\n\nexport default defineComponent({\n  name: \"Home\",\n  components: {},\n  setup() {\n    //ref以及reactive 用于定义响应式数据\n\n    // ref 定义string、number、boolean以及数组等基本类型\n    var title:any = ref(\"我是一个标题\");\n\n    //而reactive一般用于定义对象等组合型数据\n    var userInfo:any = reactive({\n      username: \"vincent\",\n      age: 20,\n    });\n    \n    let getUserInfo = function (userInfo: any): any {\n      return userInfo;\n    };\n\n    return {\n      title,\n      userInfo,\n      getUserInfo,\n    };\n  },\n});\n</script>\n\n```\n\n### 定义方法（箭头函数）\n**# 当不知道要不要返回值的时候，可以使用箭头函数，该写参数写参数，该返回就返回。**\n\n```js\n    let getUserInfoArrow = () => {\n      return userInfo;\n    };\n```\n\n我们在定义了**ref**数据后，如果想要在setup()函数中的任意一个地方更改这个ref数据，必须通过：`user.value`，才能获得值。\n\n### 响应式数据的双向绑定\n<mark>注意，如果不用ref或者reactive响应式数据。</mark>\n\n**普通的数据，普通的对象，是不能完成双向绑定即应用于实时刷新的。**\n\n比如：\n\n**1. let num:number = 0;\n2. let obj:any = { username: \"Vincent\", age: 19}**\n\n而响应式数据的双向绑定代码是：\n```js\n<input type=\"text\" v-model=\"title\" />\n\nsetup() {\n    let title = ref(\"这是H1的标题~\");\n    return {\n      title,\n    };\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614145727258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n### ...toRefs(obj) 解构响应式对象\n默认情况下，我们定义了`reactive对象`并且return之后。在前端页面，是不能直接引用的，比如：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614150602632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614150626541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**title was accessed but is not defined** 提示，我们想要获取这个title，但是他认为我们并没有去定义这个title，说明我们不能直接用reactive对象里面的某个属性，而应该**首先让某个属性 变成ref自适应数据**，即：\n\n**Reactive对象的数据  ->  Ref 自适应数据  -> 前端页面引用**\n\n因此，我们需要在`return`中加入:\n```js\nsetup() {\n    let news = reactive({\n      title: \"新闻标题\",\n      content: \"这是新闻内容！\",\n    });\n\n    return {\n      ...toRefs(news),\n    };\n  },\n```\n\n这样我们前端页面，可以使用：\n```js\n  {{ title }}\n```\n进行直接引用。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614151007379.png)\n### computed 属性\n我们可以利用`computed`属性来自动检测某些数据。并根据这些数据，满足我们的需求来处理。**（官方说，任何复杂逻辑处理的代码都写在computed中）**\n\n1. 现在我们有一个输入框，我们**输入自适应对象user的成绩score** \n2. 然后，通过**computed来实时检测成绩**，大于或者等于60分就算及格，否则不及格，要求**及时弹出信息。**\n\n```js\n<template>\n  <div class=\"home\">\n    <h1>获取用户信息</h1>\n    <div>\n      <input type=\"text\" v-model=\"score\" />\n      <div>\n        {{ isPassedInfo }}\n      </div>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { \ndefineComponent, \nreactive, \nref, \ntoRefs, \ncomputed } from \"vue\";\n\nexport default defineComponent({\n  name: \"Home\",\n  components: {},\n  setup() {\n    let user = reactive({\n      score: 0,\n    });\n\n    let isPassedInfo = computed(():string => {\n      if (user.score >= 60) {\n        return \"及格！\";\n      } else {\n        return \"不及格！\";\n      }\n    });\n    return {\n      ...toRefs(user),\n      isPassedInfo,\n    };\n  },\n});\n</script>\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614153609790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n### watch与watchEffect\n#### watchEffect 监听\n* 响应式地**跟踪**其依赖项时，立即运行一个箭头函数，并在更改依赖项时，重新运行它。（这个依赖项是什么，具体要看箭头函数中所涉及到的变量。）\n\n**比如我们现在用控制台，在实时监视某输入框中内容的变化。**\n\n```js\n<template>\n  <div class=\"home\">\n    <div>\n        <input type=\"text\" v-model=\"num\">\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  reactive,\n  ref,\n  toRefs,\n  watchEffect,\n} from \"vue\";\n\nexport default defineComponent({\n  name: \"Home\",\n  components: {},\n  setup() {\n    let data = reactive({\n      num: 0,\n    });\n\n    //看箭头函数体中 所出现的就是依赖项！\n    watchEffect(() => {\n      \n      //当data.num发生改变时 就会运行该方法\n      console.log(`num...为${data.num}`);\n    });\n    return {\n      ...toRefs(data),\n    };\n  },\n});\n</script>\n\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210614154735313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n* 可以看到的是，如果我们页面刷新几次，尽管**依赖项**没有发生改变，还是0，但仍然会执行这个方法。打印`num...为0`这句话多次。\n\n### watch \n其实watchEffect与watch都具有监听的作用。\n\n**watch可以指定监听的某一个对象**，**并且当这个对象里边的变量发生变化**（从而引起这个对象发生变化），才会执行方法体。\n\n```js\nlet data = reactive({\n      num: 0,\n    });\n\t\n\t//当data对象发生变化时 会执行方法体\n    watch(data, () => {\n      console.log(data.num);\n    });\n```\n\n**通过watch我们还可以获取到，变化前以及变化后的值。**\n\n```js\n\tlet data = ref(1);\n\n    //注意current与prev都是对象\n    //等同于你监听的这个对象 里面的属性都与其相同\n    watch(data, (current, prev) => {\n      console.log(data + \":当前值\" + current + \",之前的值：\" + prev);\n    });\n\n    return {\n      data\n    };\n```\n\n### 生命周期函数\n值得注意的是，**setup()比beforeCreate以及created更先执行。**因此，这两个我们不需要显式地去调用。\n\n以下为所有生命周期函数调用的方法：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210615094939593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n我们来写一个onMounted（首先要引入）：\n\n```js\n<script lang=\"ts\">\nimport { defineComponent, onMounted } from \"vue\";\n\nexport default defineComponent({\n  name: \"Home\",\n  components: {},\n  setup() {\n    onMounted(() => {\n      console.log('这里是onMounted!!!')\n    });\n  },\n});\n</script>\n```\n\n### Vue3.0 子组件接收父组件\n首先，我们需要父组件传过来值。**注意，利用TypeScript强类型引用的原则，一定要注意，传过去的类型与子组件声明接收的类型要一致。**\n\n```js\n<template>\n  <div class=\"home\">\n    <div>\n      <my-component-hello  :msg=\"msg\" />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from \"vue\";\nimport HelloWorldVue from \"../components/HelloWorld.vue\";\nexport default defineComponent({\n  name: \"Home\",\n  components: {\n    \"my-component-hello\": HelloWorldVue,\n  },\n  setup() {\n    //传过去的值的类型是string类型\n    let msg: string = \"你好，Hello World！\";\n    return {\n      msg,\n    };\n  },\n});\n</script>\n```\n\n父组件传过去后，子组件要接收并且声明**这个数据的类型**\n```js\n<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from \"vue\";\n\nexport default defineComponent({\n  name: \"HelloWorld\",\n  props: {\n    msg: String,\n  },\n});\n</script>\n```\n\n### Provider 与Inject （用于多层次组件）\n见博客:\n\n[爷孙级别组件数据传递](https://vincent990413.github.io/2021/04/27/VUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%BA%94%E7%94%A8-2/#%E7%88%B7%E5%AD%99%E7%BA%A7%E5%88%AB%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%EF%BC%88%E5%A4%9A%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%A7%E7%BB%84%E4%BB%B6%EF%BC%89)\n\n# Vue3.0全面集成TypeScript\n## Vue3.0_CompositionAPI +TypeScript\n**Demo.vue**\n```js\n<template>\n  <div>\n    {{ title }}\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from \"vue\";\nexport default defineComponent({\n  name: \"Demo\",\n  setup() {\n    let title: string = \"这是字符串类型的标题！\";\n    return {\n      title,\n    };\n  },\n});\n</script>\n\n<style scoped>\n/* 该style只能被本组件使用 */\n</style>\n```\n\n## 定义一个接口\n我们定义一个News用于规范化对象（规范其属性类型。）：\n\n```js\n<template>\n  <div>\n    {{ newsInstance }}\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from \"vue\";\nexport default defineComponent({\n  name: \"Demo\",\n  setup() {\n    //定义一个新闻接口 其中满足这些属性类型\n    interface News {\n      title: string;\n      content: string;\n      count: number;\n    }\n    \n    //实现接口的第一种方法\n    let newsInstance: News = {\n      title: \"这是字符串类型的新闻标题\",\n      content: \"这是字符串类型的新闻内容\",\n      count: 10,\n    };\n    return {\n      newsInstance,\n    };\n  },\n});\n</script>\n\n<style scoped>\n/* 该style只能被本组件使用 */\n</style>\n```\n\n**实现接口的第二种方法：（推荐）**\n```js\nlet newsInstance = reactive<News>({\n      title: \"泛型标题\",\n      content: \"泛型内容\",\n      count: 100,\n    });\n```\n\n## ref泛型指定数据类型\n```js\nlet count = ref<number>(100);\n```\n\n## 挂载路由\n```js\nimport { \ncreateRouter, \ncreateWebHashHistory, \nRouteRecordRaw } from 'vue-router'\nimport Home from '../views/Home.vue'\n\nconst routes: Array<RouteRecordRaw> = [\n  {\n    path: '/',\n    name: 'Home',\n    component: Home\n  },\n  {\n    path: '/about',\n    name: 'About',\n    // 访问路由时 懒加载\n    component: () => import('../views/About.vue')\n  }\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes\n})\n\nexport default router\n```\n\n### 动态路由传值\n* 我们可以再进入某个路由的同时，动态地传入URL某个index值。\n\n1. 路由配置\n```js\n  {\n    path: '/demo/:id',\n    name: 'Demo',\n    component: () => import('../components/Demo.vue')\n  }\n```\n\n当然了，对应的Demo组件必须存在。\n\n**现在，我们想要：跳转到Demo组件的同时，传入动态的id值。**\n\n（可以联想**SpringMVC的@PathVariable注解**）\n\n并且，我们还可以获取到，这个传入过来的值。\n\n2. 在相应位置**配置导航栏**，利用模板字符串取script中的自适应数据，利用:to给标签绑定属性。\n```js\n<template>\n<router-link \n   :to=\" `/demo/${username}` \">\n   进入Demo，传入字符串username过去\n   </router-link>\n</template>\n\n\n<script lang=\"ts\">\nimport { ref } from \"vue\";\nexport default defineComponent({\n  name: \"Home\",\n  setup() {\n    let username = ref<string>(\"vincent\")\n\n    return {\n      username,\n    };\n  },\n});\n</script>\n```\n\n3. 在demo组件中获取到这个值！\n* 由于**Vue3.x CompositionAPI中没有this的概念**。因此我们只有通过Vue2.x的方式来获取这个参数。\n\n<mark>本文中任何出现this的地方，都不能写在Setup中！<mark>\n\n```js\n<template>\n  <div>\n    欢迎通过URL动态路由进入本Demo组件，\n    您传过来的参数是：{{ routerUrlParam.id }}\n  </div>\n</templte>\n  data() {\n    return {\n      routerUrlParam: {},\n    };\n  },\n  mounted() {\n    this.routerUrlParam = this.$route.params;\n  },\n```\n\n### get方法传值\n我们可以通过类似get方法传值。\n\n比如:\n\n**xxx/getUsername?username=test**\n\n1. 配置路由**没有PathVariable**\n```js\n  {\n    path: '/demo',\n    name: 'Demo',\n    component: () => import('../components/Demo.vue')\n  }\n```\n\n2. 传值\n```js\n<router-link :to=\"`/demo?username=${username}`\">进入Demo，传入字符串username过去</router-link>\n        \nsetup() {\n    let username = ref<string>(\"vincent\")\n    return {\n      username,\n    };\n  },        \n```\n\n3. 接收\n```js\n<template>\n  <div>\n    欢迎通过URL动态路由进入本Demo组件，您传过来的参数是：{{ routerUrlParam.username }}\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, onMounted, reactive, ref } from \"vue\";\n\nexport default defineComponent({\n  setup() {\n    return {\n      \n    };\n  },\n  data() {\n    return {\n      routerUrlParam: {},\n    };\n  },\n  mounted() {\n    this.routerUrlParam = this.$route.query;\n  },\n});\n</script>\n```\n\n### 路由跳转\n```js\n//用JS来实现编程跳转\nthis.$router.push({path:'/xxx'});\n```\n\n* 如果要用get方法传值的话，我们要在push中写第二个参数。\n\n```js\n//编程式跳转 并get传值\n      this.$router.push({\n        path: \"/demo\",\n        query: {\n          username: \"vincent\",\n        },\n      });\n\n//接收时用来接收这个对象\nthis.$route.query\n```\n\n\n### Vuex状态管理\nVuex 主要解决**组件与组件之间的数据共享，状态共享。**\n\n此外，还能**实现组件里边数据的持久化。**\n\n比如，我们有一个新闻news组件还有一个新闻详情组件，点击每一条新闻，都能查看对应的新闻详情，而点进新闻详情可以看到的同时，退到新闻组价时，由于页面重新渲染，因此会重新向后台查询。\n\n（避免这种情况，我们要么可以**使用Localstorage**要么就可以**使用Vuex**）\n\n* **注意，使用Vuex，当刷新页面后，数据都会变成初始数据。**\n\n## 不结合TypeScript\n#### 核心概念\n1. State 相当于所有数据集合。\n2. Getters 相当于计算属性computed\n3. Mutations 相当于methods方法集合\n4. Actions 触发Mutations中的方法，**可以写一些异步操作。**\n5. Modules 指的是模块。\n\n**初始化如下：**\n```js\nimport { createStore } from 'vuex'\n\nexport default createStore({\n  state: {\n  \treturn{\n  \t\tval:1\n  \t}\n  },\n  mutations: {\n  },\n  actions: {\n  },\n  modules: {\n  }\n})\n```\n#### state存储数据\n\n* 那么**如何获取到state中存储的数据**呢？\n\n有两种方法：\n\n第一种：\n```js\nthis.$store.state.val //适用于Vue2.x\n```\n\n第二种：**（推荐）**\n```js\nstate: {\n    users: ['张三', '李四', '王五']\n  },\n```\n\n```js\ncomputed:{\n\t...mapState(['users'])\n}\n```\n\n这样就可以直接在页面中使用：\n```js\n{{ users }}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210616102747775.png)\n\n\n#### mutations可以改变数据\n```js\nmutations: {\n    setVal(state, newVal) {\n      state.val = newVal;\n    }\n  },\n```\n\n* 那么如何调用这个方法呢？\n\n**commit方法若有两个参数。**\n\n**第一个参数是字符串，与对应的方法名字对应。第二个参数是传入的值！就会进入相应的方法体。**\n\n```js\nlet newVal = 14\nthis.$store.commit('setVal', newVal);\n```\n\n#### getters \n实时获取数据，同时根据业务逻辑来处理。\n\n比如state中有一个变量msg代表字符串消息。`msg: 'Hello World!'`\n\n**我们现使其字符串颠倒。**\n\n```js\ngetters: {\n    reverseMsg(state) {\n      //比如根据业务逻辑来翻转字符串\n      return state.msg.split(\"\").reverse().join(\"\");\n    }\n  },\n```\n\n* 如何使用getters中的方法呢？\n \n 与获取state中的数据一样，推荐两种方法：\n 1. 直接通过getters.XXX\n```js\nthis.$store.getters.reversMsg;\n```\n\n2. 通过mapGetters\n```js\nimport { mapGetters } from \"vuex\";\ncomputed: {\n    ...mapGetters([\"reverseMsg\"]),\n  },\n```\n\n在页面中直接使用` {{reversMsg}}`\n\n#### Actions 写异步操作\n比如我们去后台请求一个api接口，**成功了我们执行mutations中的某一个方法，失败了我们去执行另一个方法。这样的操作，我们可以写在actions中。**\n\nactions 负责异步执行位于Mutations中的方法。\n\n首先在mutations中写一个方法showMessage\n```js\nshowMessage() {\n      console.log('这是异步消息！');\n    }\n```\n\n然后在actions中定义异步操作：\n```js\n//异步执行mutations里边的方法\n    showMessageAsync(context) {\n      context.commit(\"showMessage\");\n      //可以多次执行\n    }\n```\n\n然后在组件中调用：\n```js\n  this.$store.dispatch(\"showMessageAsync\");\n  \n```\n\n#### Module\n每一个模块中都包含state,getters以及action以及mutation.\n\n我们可以分多个模块，每个模块中的数据不同。\n\n比如在vuex文件中，我们分模块：\n1. userStore.js\n2. adminStore.js\n\n**XXXStore有自己的state, getters, mutations以及actions。**\n\n然后我们在同目录下的store.js中引入这两个模块。\n\nstore.js\n```js\nimport { createStore } from 'vuex'\nimport userStore from \"./userStore\"\nconst store = createStore({\n  modules:{\n    \"user\": userStore\n  }\n})\nexport default store\n```\n\n同目录下的userStore.js\n``js\nimport { createStore } from 'vuex'\n\nexport default createStore({\n  state: {\n    name: \"用户\"\n  },\n  mutations: {\n  },\n  getters: {\n  },\n  actions: {\n  },\n  modules: {\n  }\n})\n```\n\n然后我们在页面中去引用\n```js\n    <div>获取到userStore模块中的数据：{{ $store.state.user.name }}</div>\n```\n\n\n## Vuex 加 CompositionAPI\n**因为CompositionAPI中没有this，因此我们要从vuex中引用useStore来获取数据。**\n\n1. 直接获取state中的数据\n```js\nimport { computed } from \"vue\";\nimport { useStore } from \"vuex\";\nsetup(){\nconst store = useStore();\nreturn {\n      data: computed(() => {\n        return store.state.name;\n      }),\n    };\n}\n\n//然后前端引用 {{data}}\n```\n\n2. 访问mutations中的方法\n```js\nmutations: {\n    showMessage() {\n      console.log('这是消息！');\n    }\n  },\n\n//setup中定义方法并return出去\nlet showMessage = () => {\n      store.commit(\"showMessage\");\n    };\n\n//前端调用 {{ showMessage() }}\n```\n\n3. 调用getters中的方法（类似于computed）\n```js\nstate: {\n    name: \"用户\"\n  },\ngetters: {\n\treturnMessage(state) {\n\t  return state.name;\n\t}\n},\nconst store = useStore();\nreturnMessage: computed(() => {\n        return store.getters.returnMessage;\n      }),\n\n//前端使用     {{ returnMessage }}\n```\n\n4. 触发actions中的方法\n```js\n  getters: {\n    returnMessage(state) {\n      return state.name;\n    }\n  },\n  actions: {\n    asyncShowMessage(context) {\n      context.commit(\"showMessage\")\n    }\n  },\n  \nlet asyncShow = () => {\n \tstore.dispatch(\"asyncShowMessage\");\n};\nreturn {\n  \tasyncShow,\n};\n\n//前端使用 {{ asynShow() }}\n```\n","tags":["前端框架学习"],"categories":["前端框架学习"]},{"title":"TypeScript学习笔记","url":"/2021/06/11/TypeScript学习笔记/","content":"# TypeScript\nTypeScript是微软开发的一款开源编程语言。\n\n## TypeScript的安装\n```js\nnpm install -g typescript\n```\n\n验证是否安装完毕：\n```js\ntsc -v\n```\n\n## TypeScript的编译过程\n1. 编写TypeScript的.ts文件\n2. 通过TypeScript Compiler编译器\n3. **转化成JavaScript文件**\n\n\n## VS Code 编译 \n1. 创建.ts文件 **typeScriptDemo.ts**\n```ts\nlet message: string = \"Hello World!\";\n\nconsole.log(message);\n```\n\n2. 利用`tsc`编译这个.ts文件，因为浏览器不支持。\n```cmd\ntsc typeScriptDemo.ts\n```\n\n3. 会发现，在相同目录下，会生成对应的.js文件。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210611123420827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n4. 然后使用`node`命令来执行.js文件\n```cmd\nnode typeScriptDemo.js\n```\n\n* 每次都要在控制台中敲`tsc`来手动编译，如何热部署呢？\n\n1. 在当前目录创建`tsconfig.json`\n```cmd\ntsc --init\n```\n\n2. 在`tsconfig.json`中更改生成js的目标位置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210611124010933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**可以看到，将对应的js文件输出到当前的js这个目录下：**\n\n* 现在创建一个新的.ts文件，然后点击VS Code菜单栏中的`Terminal`\n\n* 点击`Run Task`\n\n* 点击typescript 再点击`tsc:watch`\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210611124842228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n现在我们可以直接保存之后用`node .\\js\\demo.js`就可以运行js文件了。\n\n* 现在，我们写一个`.html`网页文件，来引用这个热部署的js文件。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210611133515938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n现在运行ts文件并实时刷新，浏览器控制台即可得到结果。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210611125748176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n\n## TypeScript的数据类型\n### boolean类型\n**TypeScript是强类型规范**的，要求我们定义变量的同时，必须指定类型。\n\n```js\nlet flag:boolean = true;\n```\n\n如果现在我们将flag赋值为字符串或者数值类型，会报错的。\n\n### number类型\n```js\nlet num:number = 123;\n```\n\n注意，TypeScript没有对**整型**或者**浮点型**做一个区分。\n\n同理，赋其他类型的值也会报错。\n\n### string类型\n```js\nlet str:number = \"Hello World!\";\nconsole.log(str);\n```\n\n### array类型\n数组类型，在TypeScript中，我们**建议指定类型**的数组。\n```js\n//1. 第一种方式\nlet arr:number[] = [1, 2, 3, 4, 5]; //指定类型为number的数组\nconsole.log(arr);\n\n//2. 第二种方式 泛型的方式\nlet arr:Array<number> = [1, 2, 3];\n```\n\n### tuple元组\n元组是数组的其中一种，我们可以**指定多个不同类型的值**。\n\n```js\nlet arr:[string, number] = [\"张三\", 98];\n```\n### 枚举类型\n枚举类型是**用来解释说明某些符号的意义**。\n\n比如：pay_status状态码。\n0 代表未支付\n1 代表支付成功\n2 代表交易中\n\n**如果不赋值的话，如果上一个赋值了，就是上个值+1，否则为其在元组中的索引。**\n\n```js\nenum Flag {success=1, error=-1}\nlet f:Flag = Flag.success;\nconsole.log(f) //结果是1\n```\n\n**这样下次我们看到相应的数字 就知道对应的含义！**\n\n### any类型\nany代表任意一个类型，不指定类型，**我们可以多次更改不同类型的值（类型不同也可以）。**\n\n```js\nlet num:any = 123;//执行这句后 当前num变量的类型是number\n\nnum = true; //指定这句后，当前num变量的类型是boolean\n```\n那么，any类型是什么应用呢？\n\n我们在js文件中**定位DOM对象**，由于ts中**不存在对应的Object类型**\n\n因此我们可以赋为any\n\n```js\nlet head:any = document.getElementById('h1');\nhead.style.color = \"red\";\n```\n\n### null与undefined类型\n在JS中我们知道，当我们对变量进行了**定义但没有赋值，默认为undefined。**\n\n**根据TypeScript的强类型引用，我们必须赋值**（我们也可以赋值number或者undefined）。\n\n```js\nlet val:undefined; //我们可以直接输出 结果为undefined\n\n//如果要赋值 要赋值为number类型 如果直接输出 就是undefined\nlet val:number | undefined; \n```\n\n当一个元素可能是多个类型的时候，我们可以在定义的时候，指定。\n```js\nlet num:number|null|undefined;\n```\n\n### void类型\n如果方法没有返回值，我们就这么写：\n```js\nfunction test(): void {\n    console.log('这个方法没有任何返回值！');\n}\n\ntest();\n```\n\n**否则，该方法返回什么，就写什么类型。**\n\n```js\nfunction getSum(x: number, y: number): number {\n    return x + y;\n}\n\nconsole.log(getSum(1, 2));\n```\n### never类型\nnever类型就代表undefined或者null，或者从不会出现的值。\n\n基本不会用到：\n```js\nlet n: never;\nn = (() => { \n    throw new Error('error!');\n})();\n\n```\n\n\n## TypeScript的函数\n1. 函数声明法\n```js\nfunction getStringType(): string {\n    return \"Hello, World!\";\n}\n```\n\n2. 匿名函数法\n```js\nlet fun = function (): number {\n    return 100;\n}\n```\n\n3. 定义函数传参\n```js\nfunction introduce(name: string): string {\n    return \"Hello, My name is: \" + name;\n}\n\nconsole.log(introduce(\"Vincent\"));\n```\n\n* 另外，我们可以通过`而不是字符串的拼接来引用我们的变量。**这种方法更常用！**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210611141518142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n```js\nfunction introduce(name: string): string {\n    return `Hello, My name is ${name}`;\n}\n\nconsole.log(introduce(\"Vincent\"));\n```\n### 可选参数（放在非可选参数的后面）\n**对于，实参与形参如果不一样，必须指定可选参数。**\n\n也就是说，如果传某个可选参数，和如果不传分别都要做处理。\n\n我们在对应的参数后面紧跟一个**问号即可**。\n```js\nfunction introduce(name:string, age?:number):string{\n    //如果调用的时候 提供age参数\n    if(age){\n        return `Hello, my name is: ${name}, and my age is : ${age}!`;\n    }else{\n        return `Hello, my name is: ${name}!`;\n    }   \n}\n\nconsole.log(introduce('Vincent'))\nconsole.log(introduce('Vincent',20))\n```\n* 注意，**可选参数必须配置到所有参数的最后面！**\n* \n### 默认参数\n```js\nfunction introduce(name: string, age: number = 18): string {\n    //如果调用的时候 提供age参数\n    return `Hello, my name is: ${name}, and my age is : ${age}!`;\n\n}\n\nconsole.log(introduce('Vincent')) //这里我们age 会打印出18\nconsole.log(introduce('Vincent', 20))\n```\n\n### 三点运算符\n* 三点运算符，用于接收传过来的不确定的值。\n\n有些时候，我们传过来的参数可能是**三个数**也可能是**四个数**，我们利用三点运算符，可以将**不确定个数的这些数全部装进一个相同类型的数组中**。从而进行相应的处理！\n\n```js\nfunction sum(...result: number[]): number {\n    let sum = 0;\n    for (let i = 0; i < result.length; i++) {\n        sum += result[i];\n    }\n    return sum;\n}\nconsole.log(sum(1, 2, 3)) //我们将1,2,3都装进result中\n\nconsole.log(sum(1, 2, 3, 4)) //我们将1,2,3,4都装进result中\n\n```\n\n### 函数重载\n**重载是指，两个或者以上个同名函数，但是他们的参数不一样（包括参数个数相同但类型不同，或者参数个数不同）。**\n\nTypeScript中的重载，与ES5或者Java中的重载不太相同。\n\n#### 参数个数相同，只是类型不同时\n1. 我们首先定义所有的情况（包括列出不同的参数情况）\n\n2. 实现一个方法，但是要写出根据不同参数来实现不同的情况。\n\n* **关键代码是 if( typeof param === \"\" )**\n\n```js\n//声明第一种情况\nfunction getInfo(myName: string): string;\n\n//声明第二种情况\nfunction getInfo(myAge: number): number;\n\n//写函数 写出重载结果\nfunction getInfo(param: any): any {\n    if (typeof param === \"string\") {\n        return `我的名字是：${param}`;\n    } else {\n        return `我的年龄是：${param}`;\n    }\n}\n\nconsole.log(getInfo('Vincent'));\nconsole.log(getInfo(22));\n```\n\n#### 当参数个数不同时\n同样，也是首先声明所有情况。然后涉及到可选参数！\n\n```js\nfunction getInfo(myName: string): string;\nfunction getInfo(myName: string, age: number): string;\n\n//因为参数个数不同 所以需要声明可选参数\nfunction getInfo(param1: any, param2?: any): any {\n    //如果提供了可选参数\n    if (param2) {\n        return `Hello, my name is ${param1}, and my age is ${param2}`;\n    } else {\n        return `Hello, my name is ${param1}`;\n    }\n}\n\nconsole.log(getInfo('Vincent'));\nconsole.log(getInfo('Vincent', 22));\n```\n\n### 箭头函数\n* **注意，箭头函数里面的this不是外面的this。**\n\n```js\nlet num: number = 10;\nlet _this: any = this;\n\nsetTimeout(() => {\n    // alert(`${num}`);\n    alert(_this.num) \n\t//这两种方法都能打印出setTimeout方法外的变量\n}, 1000)\n```\n\n\n## TypeScript的类\n### （回顾）ES5 中的类与对象\n```js\n//es5 中的类与对象以及方法\nfunction Person() {\n    this.name = \"张三\";\n    this.age = 20;\n}\n\n//原型链创造属性+方法\nPerson.prototype.info = \"信息\";\nPerson.prototype.work = function () {\n    console.log(\"我是\" + this.name + \",\" + \"我在工作！\");\n}\n\n//静态方法\nPerson.getInfo = function () {\n    console.log(this.name);\n}\n\n//创造对象\nlet obj = new Person();\nconsole.log(obj.name + \":\" + obj.age);\n\n//静态方法\nPerson.getInfo();\n```\n\n### TypeScript中\n#### 类以及对象的实例化\n```js\nclass Person {\n    //属性\n    myName: string; //前面省略了public关键词\n\n    //构造函数\n    constructor(myName: string) {\n        this.myName = myName;\n    }\n\n    setMyName(myName: string): void {\n        this.myName = myName;\n    }\n\n    getMyName() {\n        return this.myName;\n    }\n\n    getInfo(): void {\n        console.log(`您好，我是${this.myName}`)\n    }\n}\n\n//实例化对象\nlet p = new Person(\"张三\");\np.getInfo();\np.setMyName(\"李四\");\np.getInfo();\n```\n#### 继承\n```js\nclass Student extends Person {\n    constructor(name: string) {\n        super(name); \n        //调用父类的构造函数 从而继承父类的属性与方法\n    }\n}\n\nlet stu = new Student(\"学生\");\nstu.getInfo();\n```\n\n**注意，当子类中的方法名与其父类相同，那么会执行子类的方法。**\n\n#### 类里面的修饰符\n\n1. public 公有：表示任何地方都能访问**（类里外、子类）**\n\n2. private 私有：表示**类里面可以访问，而子类与类外部无法访问。**\n\n3. protected 保护：表示在**类里面以及子类里面才能访问，类外无法访问。**\n\n* 注意，如果属性不加修饰符，默认为公有public。\n\n#### 静态属性与方法\n* 注意，静态方法中，是不能调用静态属性的。\n\n```js\nclass Person {\n    //属性\n    myName: string; //前面省略了public关键词\n    myAge: number;\n    static mySex: string = \"男\"; //静态方法\n\n    //构造函数\n    constructor(myName: string, myAge: number) {\n        this.myName = myName;\n        this.myAge = myAge;\n    }\n\n\t//静态方法\n    static getInfo(): void {\n        console.log(`${Person.mySex}`);\n    }\n}\n\nPerson.getInfo();\n```\n\n#### 多态\n* 多态指的是，**父类声明一个方法但不实现，让子类来实现，并且每个子类都有不同的实现方法。**\n\n```js\nclass Person {\n    //属性\n    myName: string;\n    constructor(myName: string) {\n        this.myName = myName;\n    }\n\n    work() {}\n}\n\nclass Student extends Person {\n    constructor(name: string) {\n        super(name);\n    }\n\n    work() {\n        console.log(\"我去上学！\");\n    }\n}\n\nlet p = new Person(\"张三\");\np.work();\n\nlet stu = new Student(\"李四\");\nstu.work();\n```\n\n#### 抽象类\n* 抽象类以及抽象函数，一般用于定义标准。**其子类必须包含这些含有abstract的函数。**\n\n**抽象类是不能直接实例化的。**\n\n当然，抽象类可以具有构造函数以及非抽象函数的。**但是对于那些抽象函数，其子类是必须要实现的。**\n\n```js\n//定义一个抽象类以及一个抽象方法\nabstract class Animal {\n    abstract eat(): void;\n}\n\nclass Dog extends Animal {\n    eat(): void {\n        console.log(\"这是狗，实现eat方法。\")\n    }\n}\n\nclass Cat extends Animal {\n    eat(): void {\n        console.log(\"这是猫，实现eat方法。\")\n    }\n}\n\nlet dog= new Dog();\nlet cat= new Cat();\n\ndog.eat();\ncat.eat();\n```\n\n#### 接口\n**函数型接口：**\n\n```js\n\n//定义一个接口 以及相应的规范\ninterface encrypt {\n    (key: string, value: string): string;\n} \n\n//实现这个接口 必须要符合规范\nvar md5: encrypt = function (key: string, value: string): string {\n\n    return key + value;\n}\n\n//使用这个接口\nconsole.log(md5('name', 'zhangsan'))\n```\n\n### TypeScript中的泛型\n* 泛型，即泛指的值，不具体固定的值，**你传入什么类型，我就用什么类型来处理。**\n\n如果简单的话，可以使用`any`类型来处理。但是也存在一个隐患，就是**any代表任意类型，它不强制类型。** \n\n```js\nfunction getData<T>(value: T): T {\n    return value;\n}\n\nconsole.log(getData<string>('Hello, World!'))\nconsole.log(getData<number>(100));\n```\n\n#### 泛型类\n```js\nclass ClassGetFirstItem<T>{\n    public list: T[] = [];\n\n    add(value: T): void {\n        this.list.push(value);\n    }\n\n    getFirstItem(): T {\n        return this.list[0];\n    }\n\n    getList(): string {\n        return `数组是${this.list}`;\n    }\n}\n\nlet cla = new ClassGetFirstItem<number>();\ncla.add(1);\ncla.add(1);\ncla.add(1);\n\nconsole.log(cla.getList());\nconsole.log(cla.getFirstItem());\n```\n\n当然，我们也可以`let cla = new ClassGetFirstItem<string>();`从而声明类型为string类型。\n\n### TypeScript中的模块\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210612162829210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n* 也就是说，我们首先export导出某些变量、函数甚至类，然后在想用的地方去import这个模块，从而能够获取到想要的变量、函数甚至类。\n\n**由于浏览器不能直接获取Js文件中的export。我们用node来看看。**\n\n1. demo.ts中export导出数据\n```js\nexport function getDataInfo(): any[] {\n    return [\n        {\n            username: \"root\"\n        },\n        {\n            password: \"123456\"\n        }\n    ];\n}\n```\n\n2. main.ts中import这个function以及数据\n```js\nimport { getDataInfo } from './demo'\n\nconsole.log(getDataInfo());\n```\n\n3. 使用`node`来运行对应的main.js文件查看\n```cmd\ncd js \n\nnode main.js\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210612163738401.png)\n\nexport default 指的是默认导出，只能有一个默认导出。\n\n比如\n```js\n//文件末尾\nexport default getData;\n\n//另一个想要引入getData的文件\nimport getData from '.../';\n```\n\n# 装饰器\n\n* 装饰器就是一个方法，可以**为某个类动态注入。**\n\n## 类装饰器\n**类装饰器应用于类的构造函数，可以用来监视，修改或者替换类的定义，传入一个参数。**\n\n### 普通装饰器\n不修改类的前提下，动态修改类的属性与方法：\n```js\n//装饰器\nfunction logClass(params: any) {\n\n    //params 就是当前类（我们就可以扩展这个类了）\n    console.log(params);\n\n    params.prototype.apiUrl = \"xxx\";\n    params.prototype.run = function () {\n        console.log('我是run方法！');\n\n    }\n}\n\n@logClass\nclass HttpClient {\n    constructor() { }\n}\n\nlet http: any = new HttpClient();\nconsole.log(http.apiUrl); //打印动态扩展的属性\n```\n\n### 装饰器工厂\n* 装饰器工厂，可以在使用某个装饰器的同时，传入参数进去。\n```js\n//装饰器\n//工厂装饰器 可以接收传过来的参数\nfunction logClass(params: string) {\n    return function (target: any) {\n        console.log(\"target:\" + target);\n        console.log(\"params:\" + params);\n    }\n}\n\n//这个地方 把string类型的hello变量赋给了params \n//而target则代表当前的类\n@logClass('hello')\nclass HttpClient {\n    constructor() { }\n}\n\n//我们实例化的同时 就会执行装饰器中的return中的方法体\nlet http: any = new HttpClient();\n```\n\n## 属性装饰器\n```js\nfunction logProperty(params: any) {\n    return function (target: any, attr: any) {\n        console.log(attr);\n\n        //target相当于this 修改attr为传过来的参数\n        target[attr] = params;\n\n    }\n}\n\nclass HttpClient {\n\n    @logProperty(\"new Attr\")\n    public url: any | undefined;\n\n    constructor() { }\n\n    getData(): void {\n        console.log(this.url);\n    }\n}\n\nlet http = new HttpClient();\nhttp.getData();\n\n```\n\n## 方法装饰器 \n```js\nfunction logMethod(params: any) {\n    //target代表当前实例对象 methodName代表方法名\n    //desc 代表方法的描述\n    return function (target: any, methodName: any, desc: any) {\n        console.log(target);\n        console.log(methodName);\n        console.log(desc);\n        target.getData = function () {\n            console.log('修改！');\n        }\n        target.getData();\n    }\n}\n\nclass HttpClient {\n\n    constructor() { }\n\n    @logMethod(\"www.baidu.com\") //传入参数\n    getData(): void {\n        console.log('getData');\n    }\n}\n\nlet http = new HttpClient();\n```","tags":["前端学习笔记"],"categories":["前端学习笔记"]},{"title":"设计模式学习_抽象工厂","url":"/2021/06/10/设计模式学习-抽象工厂/","content":"\n# 抽象工厂设计模式\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/v-GiuMmsXj4\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n**抽象工厂模式是与工厂模式相联系的。**\n\n前面提到，**工厂模式提供了一种更好创造某个对象**的方式，让子类来决定创造哪一个对象以及怎样创造这些对象。\n\n而本章的<mark>抽象工厂设计模式</mark>是指，在工厂模式的基础上，提供的是：**更好地创造多个对象**。\n\n## 业务场景\n比如，现在我们要设计两套不同操作系统（Windows操作系统与MacOS操作系统）的UI组件，分别是：表单（Form）与按钮（Button），规则是：**所有的UI组件都不能跨操作系统展示。** 也就是说，当使用Windows操作系统时，使用的是WindowsForm与WindowsButton（MacOS同理）。\n\n图解如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210610183912847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n<mark>还是那个逻辑：工厂负责创造对象。</mark>\n\n也就是说，我们现在想要更好地创造**Form与Button对象**（**条件是同处于同一个操作系统下**）。\n\n* **我们可以通过指定在对应的操作系统下，只`return`对应操作系统下的UI组件。**\n\n当然，依照不同的业务场景，如果**你需要若干个对象捆绑在同一个工厂中**，也可以通过这种方式。\n\n下面，我们以代码的形式，来实现。\n\n* 项目结构图如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210610184304276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 代码实现\n### 工厂\n#### 抽象类 操作系统 OperatingSystem.java\n```java\npublic abstract class OperatingSystem {\n    public abstract Form getForm();\n    \n    public abstract Button getButton() ;\n}\n```\n\n#### WindowsFactory.java\n```java\npublic class WindowsFactory extends OperatingSystem {\n\n    @Override\n    public Form getForm() {\n        return new WindowsForm();\n    }\n\n    @Override\n    public Button getButton() {\n        return new WindowsButton();\n    }\n}\n```\n\n#### MacOSFactory.java\n```java\npublic class MacOSFactory extends OperatingSystem {\n\n    @Override\n    public Form getForm() {\n        return new MacOSForm();\n    }\n\n    @Override\n    public Button getButton() {\n        return new MacOSButton();\n    }\n}\n```\n\n### 产品\n#### 接口 按钮 Button.java\n```java\npublic interface Button {\n    void desc();\n}\n```\n\n#### 接口 表单 Form.java\n```java\npublic interface Form {\n    void desc();\n}\n```\n\n#### 实现类 WindowsForm.java\n```java\npublic class WindowsForm implements Form {\n\n    @Override\n    public void desc() {\n        System.out.println(\"当前正使用Windows操作系统下的表单Form！\");\n    }\n\n}\n```\n\n#### 实现类 WindowsButton.java\n```java\npublic class WindowsButton implements Button {\n\n    @Override\n    public void desc() {\n        System.out.println(\"当前正使用Windows操作系统下的按钮Button！\");\n    }\n\n}\n\n```\n\n#### 实现类 MacOSForm.java\n```java\npublic class MacOSForm implements Form {\n\n    @Override\n    public void desc() {\n        System.out.println(\"当前正使用MacOS操作系统下的表单Form！\");\n    }\n\n}\n```\n\n#### 实现类 MacOSButton.java\n```java\npublic class MacOSButton implements Button {\n\n    @Override\n    public void desc() {\n        System.out.println(\"当前正使用MacOS操作系统下的按钮Button！\");\n    }\n\n}\n```\n\n### 主函数 AbstractFactoryPatternDemo.java\n```java\npublic class AbstractFactoryPatternDemo {\n\n    public static void main(String[] args) {\n        //以下是以Windows与MacOS为例 创造多个（Form与Button）存在依赖式的对象\n        WindowsFactory windowsFactory = new WindowsFactory();\n        System.out.println(\"Windows下的一套UI组件信息为：\");\n        windowsFactory.getForm().desc();\n        windowsFactory.getButton().desc();\n\n        MacOSFactory macOSFactory = new MacOSFactory();\n        System.out.println(\"MacOS下的一套UI组件信息为：\");\n        macOSFactory.getForm().desc();\n        macOSFactory.getButton().desc();\n\n    }\n}\n```\n\n### 效果图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210610185134239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n* 当然，也可以像《工厂模式》那样，不细分多个操作系统，而是直接新建一个FormFactory以及ButtonFactory。然后，将Windows与MacOS作为参数传递进去，从而来判断return WindowsForm还是 return MacOSForm。","tags":["设计模式"],"categories":["设计模式"]},{"title":"VUE2.0学习笔记-基础语法及其应用-4-VUE小技巧","url":"/2021/06/04/VUE学习笔记-基础语法及相应应用-4/","content":"\n\n# Vue table数据满足条件才显示按钮\n\n* 比如，当某一个数据项中的“状态”列为“已审核”时，才显示下架按钮！\n\n图解为：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021060713351698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n当然，首先需要查看**每一行有哪些数据：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210607133849447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 代码：\n```java\n\t<el-table-column label=\"操作\" width=\"150\">\n\t  <template slot-scope=\"scope\">\n\t\t<el-button v-if=\"(scope.row.checkflag === '已审核')\" type=\"success\">\n\t\t  下架</el-button\n\t\t>\n\t  </template>\n\t</el-table-column>\n```\n\n**# 注意若有多个Button，写在一个template中即可。**\n\n\n# Vue中ElementUI中el-table当某列元素prop为数组\n* 比如有个玩家el-table，我们每个玩家有**多个擅长英雄**而如果我们从后台传到前台的是一个List数据，我们就要想办法解析出多条数据prop。（如果直接赋值会显示Undefined）\n\n| 玩家名 | 擅长英雄  |\n|--|--|\n| 张三 | 李元芳，后羿 |\n| 李四\t| 赵信，李白\t|\n\n* 控制台图解如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210604202009240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n也就是说，`el-table`中的某一列，仍然是一个`List数组`。\n\n* 后台图解\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210604202850746.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**从上图中，我们可以看到，List中套了一个List。**\n\n## 前端重要代码\n**1. 展示所有的数据（不做任何处理）**\n```js\n    takeMeeting(row) {\n      let meetingid = row.meetingid;\n      let teacherId = this.user.userId;\n      let _this = this;\n      takeMeeting(meetingid, teacherId)\n        .then((res) => {\n          let msgType = \"success\";\n          if (res.data === 2) {\n            msgType = \"warning\";\n          } else if (res.data == 0) {\n            msgType = \"error\";\n          }\n          _this.$sendMessage(res.message, msgType);\n        })\n        .catch((error) => {});\n    },\n```\n\n**2. 对具体含数组的prop做处理**\n```html\n        <el-table-column\n          :formatter=\"takeMeetingListFormatter\"\n          prop=\"takeMeetingList\"\n          label=\"参加人员\">\n          \n        </el-table-column>\n```\n\n* 核心就是，给对应的`el-table-column`绑定:formatter\n\n**3. 对应的处理方法（放在methods中）**\n```js\ntakeMeetingListFormatter(row) {\n      let arr = []\n      row.takeMeetingList.forEach((item, index) => {\n        arr.push(item.teacherId)\n      });\n      //将每个需要的（这里是teacherId）放入新数组中，并用逗号隔开。\n      return arr.join(',')\n    },\n```\n\n## 效果图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021060420431531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n\n# axios封装后的request.js请求. (注意导入时的路径问题)\n\n## request.js\n```js\nimport axios from 'axios'\nimport { Message, MessageBox } from 'element-ui'\nimport { getToken, setToken } from '../assets/js/utils' //从localstorage中\nconst debug = process.env.NODE_ENV !== 'production'\n\n// create an axios instance\nconst service = axios.create({\n  baseURL: \"http://192.168.1.106:8181\", //请求的基础根路径\n  withCredentials: false,//如果遇到网络问题 就置为false\n  timeout: 10000 // 请求超时10秒\n})\n\n// request interceptor\nservice.interceptors.request.use(\n  config => {\n    //如果token为空 说明第一次登录本系统 则不管\n    //如果token不为空 则带着这个给header\n    if (getToken() !== null) {\n      config.headers['token'] = getToken()\n    }\n    if (debug) {\n      console.log(config)\n    }\n    return config\n  },\n  error => {\n    // Do something with request error\n    console.log(error) // for debug\n    Promise.reject(error)\n  }\n)\n\n// response interceptor\nservice.interceptors.response.use(\n  response => {\n    const res = response.data\n\t\n\t//可能要配置相关的返回码200 404 500等等\n    if (res.code === 10010) { \n      MessageBox.confirm(res.message, '提示', {\n        confirmButtonText: '确定',\n        cancelButtonText: '取消',\n        type: 'warning'\n      }).then(() => {\n        window.location.href = \"/\"\n      }).catch(() => {\n        window.location.href = \"/\"\n      });\n    }\n    // 请求成功\n    else{\n      return response.data\n    }\n  },\n  error => {\n    console.log('err' + error) // for debug\n    Message({\n      message: error.message,\n      type: 'error',\n      duration: 5 * 1000\n    })\n    return Promise.reject(error)\n  }\n)\n\nexport default service\n```\n\n## 需要配置axios单个请求参数的文件群 user.js\n```js\nimport request from \"../plugins/request\";\n\n//Get方法\nexport function takeMeeting(meetingid, teacherId) {\n    return request({\n        url: '/takeMeeting',\n        method: 'get',\n        params: {\n            meetingid, teacherId\n        }\n    })\n}\n\n//POST方法\nexport function updatePassword(updateForm) {\n    return request({\n        url: '/updatePassword',\n        method: 'post',\n        data: updateForm\n    })\n}\n```\n\n## 具体使用代码(注意路径问题)\n```js\nimport {updatePassword} from '../../api/user'\n\nupdatePassword(this.updateForm)\n.then( (res) => {\n\t\n}).catch( (error) => {\n\tconsole.log(error)\n})\n```\n\n# axios请求 包括Get请求与Post请求（注意是异步）\n\n因为该方法是异步，**因此无法准确知道元素的执行顺序。**\n\n有可能axios方法后面的方法会提前执行，也有可能会延后执行。\n\n## Get方法\n\n```js\nvar _this = this\nvar _data = this.$data\naxios.get(main.requestAddress + '/book/showAllBooks', {\n\t\tparams: {'pn': _data.queryParams.currentPageNum}\n\t}).then(function (response) {\n\t\t//从后端返回给前端的内容(code、message、data...等等)\n\t}).catch(function (error) {\n\t\t\n\t});\n```\n\n**params:{ 'data': data}** 是指以键值对的方式 往后台传输数据\n\n**因此，后台需要用@RequestParam()标签**\n\n**注意，在main.js中定义一个变量 var requestAddress=\"192.xxx.xxx.xxx\"**\n\n同时**导出这个main.js**\n\n最后使用的时候**记得 import main from 'main.js的路径'**\n\n\n### 请务必注意！\n\n1. 第一种方案：\n**使用axios请求时，如果需要用到在回调函数中用到该网页的内容。**\n\n**必须在axios.get/post方法外 定义一个**\n\n```js \nvar _this = this\n```\n\n注意外面的this与回调函数的this不一样！！！\n\n2. (推荐)如果非要使用`this`，那么我们可以使用箭头函数：\n```js\nsuccess: res => {\n\tthis.xxx = res;\n}\n```\n## Post方法\n\nPOST方法比较复杂，涉及到**数据绑定**\n\n```js\n<el-form :rules=\"loginFormRules\" ref=\"loginForm\" \n\t\t:model=\"loginForm\" label-position=\"right\" \n\t\tlabel-width=\"auto\" show-message>\n\t\t\n\t<span class=\"login-title\">欢迎登录</span>\n\t<div style=\"margin-top: 5px\"></div>\n\t\t\n\t<el-form-item label=\"用户名\" prop=\"username\">\n\t\t<el-col :span=\"22\">\n\t\t\t<el-input type=\"text\" v-model=\"loginForm.username\"></el-input>\n\t\t</el-col>\n\t</el-form-item>\n\t\n\t<el-form-item label=\"密码\" prop=\"password\">\n\t\t<el-col :span=\"22\">\n\t\t\t<el-input type=\"password\" v-model=\"loginForm.password\"></el-input>\n\t\t</el-col>\n\t</el-form-item>\n\t\n\t<el-form-item>\n\t\t<el-button type=\"primary\" @click=\"loginSubmit('loginForm')\">登录</el-button>\n\t\t<el-button type=\"primary\" @click=\"dialogVisible=true\">注册</el-button>\n\t</el-form-item>\n\t\t\t\n</el-form>\n\n```\n\n**ref=\"loginForm\" 与 :model=\"loginForm\" 都是指绑定data中的loginForm**\n\n**rules=\"loginFormRules\" 指的是绑定自定义规则**\n\n**v-model=\"loginForm.username\"指的是 该值双向绑定loginForm里面的username属性**因此，一定记得**prop=loginForm.prop**\n\n点击登录按钮时，**loginForm**作为参数传进去！\n\n**1. loginForm里面的参数->对应的所有prop**\n\n写在**return**里面即可：\n```js\nloginForm: {\n    username: '',\n    password: ''\n}\n```\n\n**2. loginForm对应的规则，也写在return里面**\n```js\nloginFormRules: {\n    username:[\n                {required: true, message: '账号不可为空', trigger: 'blur'}\n            ],\n    password: [\n                {required: true, message: '密码不可为空', trigger: 'blur'}\n            ]\n}\n```\n\n**require表示必须填，触发blur后，会提示message！**\n\n\n这样，在JS中，可以将该表单**loginForm**与它对应的**参数输入规则**绑定在一起验证！\n\n同时也可以自定义验证规则！\n**在data(){这里} 中写**\n\n```js\nconst validateUserName = (rule, value, callback) => {\n\tif(value === 0){\n\t\tcallback(new Error('这里是错误提示'))\t\n\t}else{\n\t\tcallback() //验证成功，通过自定义规则！\n\t}\n}\n```\n其中value是对应输入框的值！\n\ncallback用来回调\n\n**提示对方错误信息** \n\n还是 \n\n**让对方通过**\n\n这样的话，可以在规则中，**声明走自定义的规则方法：**\n\n```js\nloginFormRules: {\n    username:[\n                {required: true, validator: validateUserName,, trigger: 'blur'}\n            ]\n}\n```\n\n**其他自定义规则 看官方文档**\n\n具体登录+验证方法如下：\n```js\nloginSubmit(formName) {\n\tlet _this = this\n\t// 为表单绑定验证功能\n\tthis.$refs[formName].validate((valid) => {\n\t\tif (valid) {\n\t\t\t// 使用 vue-router 路由到指定页面，该方式称之为编程式导航\n\t\t\tthis.$axios.post(main.requestAddress + `/user/login`, _this.loginForm)\n\t\t\t\t.then(res => {\n\t\t\t\t\t_this.$data.message = res.data.message\n\t\t\t\t\t\t//若数据库查询失败 则返回重新登录信息\n\t\t\t\t\t\tif (res.data.data === null) {\n\t\t\t\t\t\t\t_this.openLoginFailMessage();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsessionStorage.setItem(\"token\", true);\n\t\t\t\t\t\tsessionStorage.setItem(\"username\", res.data.data.username);\n\t\t\t\t\t\t_this.$router.push(\"/index\");//路由跳转至 path=> /index 具体看自己的路由配置\n\t\t\t\t\t})\n\t\t\t\t\t.catch(Error => {\n\t\t\t\t\t\tconsole.log(Error)\n\t\t\t\t\t})\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n   }\n```\n\n\n# 全局路由配置（基于session的前端权限）\n\n1.首先搞清楚，除了登录、404..页面，其他的涉及到**必须要先登录的业务数据页面**都是要授权认证的！\n\n2.授权认证，必须要经过**成功登录**\n\n3.每次页面进行跳转都要经过权限认证过程！\n\n## 配置路由，除了登录页面，其他都要认证\n\n**我们给相应涉及业务数据的页面，比如主页面index，加上需要拦截的头信息：**\n\n**注意！登录页面是不需要加的！**\n\n```js\n{\n\tmeta: {\n\t\trequireAuth: true //如果来该页面 需要验证\n\t},\n\tpath: '/index',\n\tname: '业务逻辑',\n\tcomponent: ()=>import('../views/ShowAll')\n}\n```\n\n然后，在页面拦截时，我们需要判断**要去的页面是否需要授权？**\n\n**也就是requireAuth是否是'true'？**\n\n```js\n//添加全局路由拦截\nrouter.beforeEach((to, from, next) => {\n    if (to.meta.requireAuth) {\n        //如果去的页面需要认证 那么就开始认证\n        if (sessionStorage.getItem(\"token\") == 'true') {\n            next(); //放行\n        } else {\n            alert('请您登陆...');\n            //否则下一步也放行 但放行到登录页面\n            next({\n                path: '/login'\n            })\n        }\n    } else { //如果不需要授权 比如直接去登录页面\n        if (sessionStorage.getItem(\"token\") == 'true' && to.path != '/login') {\n            next('/index')\n        } else {\n            next()\n        }\n    }\n})\n```\n\n1. 注意这里的**sessionStorage.getItem(\"token\")**取出来的值是**字符串类型**\n\n2. **这里的 && to.path!='/login' 是用户从index主界面 到login登录页面 而不想已经验证但还是跳到index页面的情况** \n\n3. 如果不指定\n\n```js\nnext({path: '/login'}) \n```\n\n即**指定去登录页面（前提是登录页面的path是'/login'）**，\n\n那么next()就代表**允许去想要去的页面**\n\n4. 因为每次我们要看**sessionStorage.getItem(\"token\")**里面值是不是'true'。因此，我们需要在登录成功的时候！添加对应的**token**信息\n\n## 登录成功添加可“允许通过”的路由信息（Token，Session，Cookies均可）\n\n```js\nsessionStorage.setItem(\"token\", true);\n```\n\n## 过滤路由显示菜单\n\n**如果在菜单中不想让某些通用模块出现（比如登录、注册、注销等功能）**\n\n**可以在对应路由信息中，添加属性: `hidden: true`**\n\n* 在页面中的el-submenu 以及el-submenu-item中 去for循环遍历时，加一个v-if=\"!item.hidden\" \n\n<mark> 注意，v-if 与 v-for 是不能同时出现在属性中 可以将v-for 提前一个标签！</mark>\n\n# Vue 项目中加入常用插件\n\n## 加入插件\n\n**通常，我们通过vue/cli来创建相应的vue项目**\n\n```js\n\tvue create vue_demo\n```\n\n* 注意，如果不想要VUE严格的eslint语法规则。\n\n**可以在创建的时候，取消勾选Fomatter。**\n\n**若需要VUEX全局状态管理，可以勾选。**\n\n**若需要路由router，则可以选择勾选。**\n\n...在经过漫长的cmd后\n\n不用关闭当前**git bash**或者**命令行控制工具Command**\n\n我们首先进入这个项目，直接利用npm配置一些插件。\n\n```js\n\tcd vue_demo\n\tvue add vuetify //下载vuetify移动自适应插件\n\tvue add element //引入elementUI 并且在接下来选择时Fully import还是按需引入\n\tvue add axios //将ajax封装好的axios\n```\n\n**不出意外的话，在具体的项目目录中，可以看到多出一个文件夹plugins。**\n\n**这里装着我们安装进去的插件。**\n\n在配置之后，我们可以用VS code来打开这个文件夹，并且\n\n```js\n\tnpm run serve\n```\n\n运行项目\n\n# VUE中添加Echarts可视化图表\n\n## npm 安装echarts插件\n\n```js\nnpm install echarts --save\n```\n\n**如果npm的安装速度较慢，可以使用cnpm淘宝镜像**\n\n```js\n\n//安装淘宝镜像\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n//从淘宝镜像下载\ncnpm install echarts -S\n```\n\n**当完成npm安装后，echarts插件出现在 node_modules 目录下**\n\n## 全局引入ECHARTS\n\n**main.js 文件**\n\n```js\n// 引入echarts\nimport * as echarts from 'echarts'\n\nVue.prototype.$echarts = echarts\n```\n\n## 初始化图表\n\n```html\n<div  ref=\"chartCircle\" :style=\"{width: '300px', height: '300px'}\"></div>\n```\n\n1. ref属性是为了**JS代码中能引用这个图表**\n\n2. `<div>`属性之间默认隔行 如果想要多个图表在同一行中显示 添加属性：`style=\"display: inline-block\"`\n\n3. 如果想要动态改变 图表的高度与宽度 **可以利用VUE的动态绑定**\n\n## JS画图动态渲染（柱状图与饼状图）\n\n### 饼状图\n**将画图抽象成一个函数 `drawLine()` 这个函数放在mounted() 生命周期函数中**\n\n```js\nthis.drawLine();\n```\n\n**图标参数JSON数据 （定义在data中的return{}）**\n```js\noptionCircle:{\n                    title: {\n                        text: '实时热门图书',\n                        subtext: '站点动态统计',\n                        left: 'center'\n                    },\n                    tooltip: {\n                        trigger: 'item'\n                    },\n                    legend: {\n                        orient: 'vertical',\n                        left: 'left',\n                    },\n                    series: [\n                        {\n                            name: '访问来源',\n                            type: 'pie',\n                            radius: '50%',\n                            data: [],\n                            emphasis: {\n                                itemStyle: {\n                                    shadowBlur: 10,\n                                    shadowOffsetX: 0,\n                                    shadowColor: 'rgba(0, 0, 0, 0.5)'\n                                }\n                            }\n                        }\n                    ]\n                }\n```\n\n**正常情况下，是看不到任何数据的 但是能看到你的饼状图标题**\n\n**接下来，我们要在data中从后台动态添加数据**\n\n**这里我选择 AXIOS 异步刷新数据**\n\n**JS drawLine() 函数**\n```js\ndrawLine(){\n\t // 基于准备好的dom，初始化echarts实例\n\t //通过ref来找到图表\n\tlet myChartCircle = this.$echarts.init(this.$refs.chartCircle);\n\t\n\t//如果这里this.$refs.chartCircle 无效 则给div加一个id为chartCircle \n\t//然后将this.$refs.chartCircle替换成document.getElementById('chartCircle')即可\n\n\t//动态从数据库中取数据\n\t//画饼图\n\tconst _this = this\n\taxios.get(\n\t\tmain.requestAddress +\n\t\t'/book/showPopularBooks').then(function (response) {\n\t\tlet list = response.data.data\n\t\tlet data = _this.$data.optionCircle.series[0].data\n\n\t\tfor(let i =0; i<list.length; i++){\n\t\t\tdata.push({\n\t\t\t\tname: list[i].bookname,\n\t\t\t\tvalue: list[i].borrowNum\n\t\t\t})\n\t\t}\n\t\t//这一句很重要 加载到页面中\n\t\tmyChartCircle.setOption(_this.$data.optionCircle);\n\t}).catch(function (error) {\n\t\talert(error);\n\t});\n}\n```\n\n**可以看到，其实真正的饼状图数据是：**\n\n**\"name\"代表饼图的名称 \"value\"代表对应name的饼图数据**\n\n**值得注意的是，这种push方法是加入新的JSON对象的方法**\n\n```js\n\tdata.push({\n\t\tkey1: value1(可以来自后台),\n\t\tkey2: value2(可以来自后台),\n\t\t...\n\t});\n```\n\n\n**效果图如下：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210416123833199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n### 柱状图\n\n**与饼状图相似，先是配置图标参数，渲染图表，最后是取数据**\n\n#### 配置图表参数\n```js\noptionColumn:{\n\t\ttitle: {\n\t\t\ttext: '实时借书用户'\n\t\t},\n\t\ttooltip: {\n\t\t},\n\t\tlegend: {\n\t\t},\n\t\txAxis: {\n\t\t\tdata: []\n\t\t},\n\t\tyAxis: {},\n\t\tseries: [{\n\t\t\tname: '借阅次数',\n\t\t\ttype: 'bar',\n\t\t\tdata: []\n\t\t}]\n\t}\n```\n\n#### 渲染图表\n```js\nlet myChartColumn = this.$echarts.init(this.$refs.chartColumn)\n\t//使用刚指定的配置项和数据显示图表。\n\t//画柱状图\n\taxios.get(\n\t\tmain.requestAddress +\n\t\t'/book/showPopularUsers').then(function (response) {\n\t\tlet list = response.data.data\n\t\tlet nameArray = _this.$data.optionColumn.xAxis.data\n\t\tlet numArray = _this.$data.optionColumn.series[0].data\n\t\tfor(let i=0; i<list.length; i++){\n\t\t\tnameArray.push(list[i].username);\n\t\t\tnumArray.push(list[i].totalBorrowNum);\n\t\t}\n\t\tmyChartColumn.setOption(_this.$data.optionColumn);\n\n\t}).catch(function (error) {\n\t\talert(error);\n\t});\n```\n\n**可以看到，对于柱状图，我们要配置两个**\n\n1. xAxis 即X轴的数组中的数据\n\n2. series[0]中的data数组 代表从左往右依次的 棱柱所代表的value\n\n**效果图如下**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021041612451596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n# VUEX 存值与取值区域\n\n**在VUE中，如果有些数据我们不太需要后台频繁的查询数据**\n\n我们就可以将这些数据**存放在VUEX中**\n\n## 声明store的index.js\n```js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\n//导出之后 外部可以使用\nexport default new Vuex.Store({\n\tstate:{\n\t\t//放全局变量 比如viewCounter是浏览量统计器\n\t\tviewCounter = 1\n\t},\n\tmutations:{\n\t\t//setter方法区域\n\t\tsetViewCounter(state, viewCounter){\n\t\t\tstate.viewCounter = viewCounter \n\t\t}\n\t},\n\tgetters:{\n\t\t//getter方法区域\n\t\tgetViewCounter: state => state.viewCounter\n\t},\n\taction:{},\n\tmodules:{}\n})\n\n```\n\n\n## 在需要存值、取值的地方 调用方法\n\n### 取值getViewCounter\n```js\n\tthis.$store.getters.getViewCounter\n```\n\n### 存值setViewCounter方法\n```js\n\tthis.$store.commit('setViewCounter', newValue);\n```\n\n# WEB项目实现文件下载与上传\n## SSM项目+非MultipartFile类\n* 在这种类型的项目中，我们需要在相应的Spring MVC.xml配置文件中，去配置一个Bean\n\n代码如下：\n```xml\n<bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n        <property name=\"maxUploadSize\" value=\"104857600\"/>\n        <property name=\"maxInMemorySize\" value=\"4096\"/>\n        <property name=\"defaultEncoding\" value=\"UTF-8\"></property>\n    </bean>\n```\n\n这种，我们就可以在Controller层中，使用@RequestParam(\"file\") MultipartFile file了。\n\n如果前端是Form表单的话，则前端代码如下：\n```html\n<form class=\"form-horizontal \" action=\"/UploadServlet\" id=\"upload\" enctype=\"multipart/form-data\" method=\"post\">\n\t<input class=\"form-control\" type=\"file\">\n\t <button type=\"submit\" class=\"btn btn-success btn-sm\">上传</button>\n\t <div> ${ message } </div>\n</form>\n```\n\n**这样，当我们点击上传后，即会跳转到对应的action，我们用@PostMapping来接收即可。**\n\n后台代码如下：\n```java\n\n \t// 上传文件存储目录\n    private static final String UPLOAD_DIRECTORY = \"upload\";\n\n    // 上传配置\n    private static final int MEMORY_THRESHOLD = 1024 * 1024 * 3;  // 3MB\n    private static final int MAX_FILE_SIZE = 1024 * 1024 * 40; // 40MB\n    private static final int MAX_REQUEST_SIZE = 1024 * 1024 * 50; // 50MB\n    \n @RequestMapping(value = \"/UploadServlet\", method = RequestMethod.POST)\n    public String upload(\n            ModelAndView modelAndView,\n            HttpServletRequest request,\n            HttpServletResponse response) throws IOException, ServletException {\n\n\n        // 配置上传参数\n        DiskFileItemFactory factory = new DiskFileItemFactory();\n        // 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中\n        factory.setSizeThreshold(MEMORY_THRESHOLD);\n        // 设置临时存储目录\n        factory.setRepository(new File(System.getProperty(\"java.io.tmpdir\")));\n\n        ServletFileUpload upload = new ServletFileUpload(factory);\n\n        // 设置最大文件上传值\n        upload.setFileSizeMax(MAX_FILE_SIZE);\n\n        // 设置最大请求值 (包含文件和表单数据)\n        upload.setSizeMax(MAX_REQUEST_SIZE);\n\n        // 中文处理\n        upload.setHeaderEncoding(\"UTF-8\");\n\n        // 构造临时路径来存储上传的文件\n        // 这个路径相对当前应用的目录\n        String uploadPath = request.getServletContext().getRealPath(\"./\") + File.separator + UPLOAD_DIRECTORY;\n\n        // 如果目录不存在则创建\n        File uploadDir = new File(uploadPath);\n        if (!uploadDir.exists()) {\n            uploadDir.mkdir();\n        }\n\n        try {\n            List<FileItem> formItems = upload.parseRequest(request);\n            if (formItems != null && formItems.size() > 0) {\n                // 迭代表单数据\n                for (FileItem item : formItems) {\n                    // 处理不在表单中的字段\n                    if (!item.isFormField()) {\n                        String fileName = new File(item.getName()).getName();\n                        String filePath = uploadPath + File.separator + fileName;\n                        File storeFile = new File(filePath);\n\n                        // 在控制台输出文件的上传路径\n                        String filePathSaved = uploadPath + File.separator;\n\n                        // 保存文件到硬盘\n                        item.write(storeFile);\n                        teacherServer.saveFilePath(filePathSaved, fileName);\n                        request.setAttribute(\"message\", formItems.get(0).getName() + \"文件上传成功!\");\n                    }\n                }\n            }\n        } catch (Exception ex) {\n            request.setAttribute(\"message\", \"错误信息: \" + \"文件上传失败，请检查是否文件为空！\");\n\n        }\n        return \"/teacher/tea_add_paper\";\n    }\n```\n\n**注意到return这里，我们需要配置相应的视图解析器，不然我们不知道return哪个地方去显示。**\n\n```xml\n\t<!--配置试图解析-->\n    <bean class = \"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/\"></property>\n        <property name=\"suffix\" value=\".jsp\"></property>\n    </bean>\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210514102019792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**注意：webapp 就是我们配置的根目录，并且配置的视图后缀为.jsp**\n\n* 这样我们就能在，相应的视图中，看到message的内容了\n\n## SpringBoot项目+JSP+MultipartFile（非AJAX异步）\n\n**首先，我们需要在SpringBoot的配置文件application.yml或者application.properties中配置：**\n\n**application.properties**\n```yml\nspring.servlet.multipart.max-request-size=10MB\n\nspring.servlet.multipart.max-file-size=10MB\n```\n\n**然后我们，在controller中写相应语句：**\n\n* 我们仍然需要配置视图解析器ViewResolver：\n\n**在application.properties中：**\n```java\nspring.mvc.view.prefix=/\n\nspring.mvc.view.suffix=.jsp\n```\n仍与上方图片中的项目结构图一致！\n\n```java\n\n    private static final String UPLOAD_DIRECTORY = \"upload\";\n    \n\t@PostMapping(\"/upload\")\n    @ResponseBody\n    public String upload(@RequestParam(\"file\") MultipartFile file, HttpServletRequest request) {\n        if (file.isEmpty()) {\n        \trequest.setAttribute(\"message\", \"对不起，检测到文件为空！\");\n            return \"/teacher/tea_add_paper\";\n        }\n\n        String fileName = file.getOriginalFilename();\n        String templatePath = request.getServletContext().getRealPath(\"./\") + File.separator + UPLOAD_DIRECTORY;\n\n        File dest = new File(filePath + fileName);\n        try {\n            file.transferTo(dest);\n            request.setAttribute(\"message\", \"文件上传成功！\");\n            return \"/teacher/tea_add_paper\";\n        } catch (IOException e) {\n        \tSystem.out.println(e)\n        }\n        \n        request.setAttribute(\"message\", \"文件上传失败！\");\n        return \"/teacher/tea_add_paper\";\n    }\n```\n\n**接下来，就准备写前端页面请求：**\n```html\n<form method=\"post\" action=\"/uploading\" enctype=\"multipart/form-data\">\n    <input type=\"file\" name=\"file\">\n    <br/>\n    <input type=\"submit\" value=\"提交给服务器\">\n    <div>\n    \t${message}\n    </div>\n</form>\n```\n\n## SpringBoot+VUE+ElementUI前后端分离\n**前提是解决跨域问题，并且直接通过IP地址访问，将这个访问的ip地址存在VUEX中或者Main.js中即可。**\n\n**1. VUE前端页面**\n```html\n<el-upload\n            class=\"uploadDemo\"\n            ref=\"upload\"\n            accept=\".doc\"\n            action=\"https://jsonplaceholder.typicode.com/posts/\"\n            :on-preview=\"handlePreview\"\n            :on-remove=\"handleRemove\"\n            :http-request=\"httpRequest\"\n            :auto-upload=\"false\"\n          >\n            <el-button slot=\"trigger\" size=\"small\" type=\"primary\"\n              >选取文件</el-button\n            >\n            <el-button\n              style=\"margin-left: 10px\"\n              size=\"small\"\n              type=\"success\"\n              @click=\"submitUpload\"\n              >上传到服务器</el-button\n            >\n            <div slot=\"tip\" class=\"el-upload__tip\">\n              只能上传.doc后缀文件，且不超过40MB\n            </div>\n          </el-upload>\n```\n\n2. 写两个函数\n**一个是按钮点击函数，另一个是上传文件的表单具体提交（axios请求）的函数**\n\n* 提交按钮函数\n```js\nsubmitUpload() {\n      this.$refs.upload.submit(); //我们通过el-upload的引用来找到 并让他提交\n    },\n```\n\n**注意，我们这里看到他的action位置，并不是我们的后台地址。**\n\n**也就是说，我们通过先把自己的文件传给他的action，再由他的action服务器地址，传给我们的后台服务器。**\n\n**最后，提交表单后，会走绑定属性httpRequest的方法，即：**\n\n* 表单提交函数\n```js\n//最后上传走这个方法！\n    httpRequest(param) {\n      let fileObj = param.file; // 相当于input里取得的files\n      let data = new FormData(); // FormData 对象\n      data.append(\"file\", fileObj); // 文件对象 后台用@RequestParam来接收\n      const config = { headers: { \"Content-Type\": \"multipart/form-data\" } };\n\n      var _this = this;\n\t  //在这里我将后台的服务器地址 存进了VUEX中\n\t  //并通过相应的getters 来获取\n      this.$axios\n        .post(\n          this.$store.getters.getRequestAddress + `/uploading`,\n          data,\n          config\n        )\n        .then((res) => {\n          let data = res.data;\n          console.log(data);\n          if (data.data === 1) {\n            _this.sendMessage(data.message, \"success\");\n          } else {\n            _this.sendMessage(data.message, \"error\");\n          }\n        })\n        .catch((Error) => {\n          _this.sendMessage(\"请求失败！\", \"error\");\n        });\n    },\n```\n\n**发送消息的方法，记得引入ElementUI**\n```js\n//弹窗发送消息 以传入的参数而定\n    sendMessage(messageContent, messageType) {\n      this.$message({\n        message: messageContent,\n        type: messageType,\n      });\n    },\n```\n\n**然后就是后台接收（如果是SSM项目，在SpringMVC配置文件中配置Bean**\n\n**如果是SpringBoot项目，记得在application.properties中配置：**\n\n<mark> 见上方内容 </mark>\n\n**接下来，我们写后台的具体上传方法。**\n\n```java\n//elementUI 上传方法\n\n\tprivate static final String UPLOAD_DIRECTORY = \"upload\";\n\t\n    @PostMapping(value = \"/uploading\")\n    @ResponseBody\n    public TSMResult uploadFile(@RequestParam(\"file\") MultipartFile file, HttpServletRequest request, TSMResult tsmResult) {\n\n        if (file.isEmpty()) {\n            tsmResult.setData(0);\n            tsmResult.setMessage(\"文件不可为空！\");\n            return tsmResult;\n        }\n        // 获取文件全名a.py\n        String fileName = file.getOriginalFilename();\n        // 文件上传路径<br>        String templatePath = \"E:/file/template/\"\n        String templatePath = request.getServletContext().getRealPath(\"./\") + File.separator + UPLOAD_DIRECTORY;\n\n        System.out.println(\"文件路径：\" + templatePath);\n\n        // 获取文件的后缀名\n        String suffixName = fileName.substring(fileName.lastIndexOf(\".\"));\n\n        //获取文件名\n        String prefixName = fileName.substring(0, fileName.lastIndexOf(\".\"));\n        // 解决中文问题,liunx 下中文路径,图片显示问题\n        //fileName = UUID.randomUUID() + suffixName;\n        File dest0 = new File(templatePath);\n        //prefixName + File.separator +\n        File dest = new File(dest0, fileName);\n\n\n        //文件上传-覆盖\n        try {\n            // 检测是否存在目录\n            if (!dest0.getParentFile().exists()) {\n                dest0.getParentFile().mkdirs();\n                //检测文件是否存在\n            }\n            if (!dest.exists()) {\n                dest.mkdirs();\n            }\n            file.transferTo(dest);\n\n            //上传成功后 将上传路径上传到数据库中\n            String filePathSaved = templatePath + File.separator;\n            teacherServer.saveFilePath(filePathSaved, fileName);\n\n            tsmResult.setData(1);\n            tsmResult.setMessage(\"文件上传成功！\");\n            return tsmResult;\n        } catch (Exception e) {\n            tsmResult.setData(0);\n            tsmResult.setMessage(\"服务器错误，请稍后再试！\");\n            return tsmResult;\n        }\n    }\n```\n```java\n\tteacherServer.saveFilePath(filePathSaved, fileName);\n```\n\n这个代表，我们**将这个上传的文件名字，以及对应的上传路径，写进数据库中**。\n\n对应服务层代码：\n```java\npublic int saveFilePath(String filePathSaved, String fileName) {\n\n        return sourceMapper.saveFilePath(filePathSaved, fileName);\n    }\n```\n\n对应mapper代码：\n```java\n\t@Insert(\"insert into source(source, papername) values (#{filePath},#{fileName})\")\n    int saveFilePath(@Param(\"filePath\") String filePath, @Param(\"fileName\") String fileName);\n\n```\n\n可以建立一个Source实体类，引入Lombok\n```java\n\tprivate Integer id;\n\tprivate String filePath;\n\tprivate String fileName;\n```\n\n**并且数据库也建立一个source表，其中字段名与这个Source实体类的属性名一模一样（避免Mybatis的字段映射ResultMap）**\n\n# 实现文件下载\n\n**# 在实现文件的上传后，我们肯定会有相应的下载功能。**\n\n*即从上传目录中的文件中，去下载对应的文件。*\n\n* 需求：我们将文件的信息以及路径，存进数据库了，也就代表：\n\n* 我们“只能下载那些已经保存在数据库中的文件”\n\n## JSP实现文件下载（且动态检测文件是否可下载）\n\n1. 前端页面动态生成一个锚点（Bootstrap可加上按钮样式类）\n```js\n// 1. 利用Ajax异步获取到分好页的论文（PageHelper插件）\nvar list = result.data.list\n\n// 2. 利用$.each来遍历这些数据 对每个数据进行筛选\n$.each(list, function (index, item) {\t\n\t//3. 首先获取到即将下载的论文名(鉴于我们上传时 是将论文的文件名存进数据库的)\n\tvar papername = item.papername  \n\t\n\t//4. 为每一项“模拟按钮” 动态加上类 方便我们后期动态remove掉\n\tvar download = $(\"<a></a>\").addClass(papername + \" btn btn-danger btn-sm\").append($(\"<span></span>\").addClass(\"glyphicon glyphicon-download\")).append(\"下载\").attr(\"href\", \"/DownloadServlet?paperName=\" + item.papername);\n});\n```\n\n**注意到，我们这里的路径是：/DownloadServlet?paperName=xxx**\n\n因此，我们肯定是以`get`的请求方式\n\n2. 后台controller层代码\n```java\n\n\tprivate static final String UPLOAD_DIRECTORY = \"upload\";\n\t\n\t@RequestMapping(value = \"/DownloadServlet\")\n    public ResponseEntity<byte[]> fileDownload(\n            HttpServletRequest request,\n            @RequestParam(\"paperName\") String fileName,\n            Model model) throws Exception {\n        fileName = new String(fileName.getBytes(\"ISO-8859-1\"), \"UTF-8\"); //后台接受中文数据编码\n        fileName = fileName + \".doc\";\n\n        String filePath = request.getServletContext().getRealPath(\"./\") + File.separator + UPLOAD_DIRECTORY + \"\\\\\" + fileName;\n        File file = new File(filePath);\n        HttpHeaders headers = new HttpHeaders();\n        String downloadFile = new String(fileName.getBytes(\"utf-8\"), \"iso-8859-1\");\n        headers.setContentDispositionFormData(\"attachment\", downloadFile);\n        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);\n        return new ResponseEntity<byte[]>(FileUtils.readFileToByteArray(file), headers, HttpStatus.CREATED);\n    }\n```\n\n**其实，上述代码是不够完整的，因为如果数据库中没有这个以.doc为后缀（后缀写死了）的文件，就会报错。**\n\n**因此，我们需要在前端下载之前就进行一次查询：**\n\n**如果该文件的文件名存到数据库里了，才给予下载（即才动态添加下载的锚点样式）**\n\n* 完整代码：写在$.each遍历中：\n```js\n\n// 1. 利用Ajax异步获取到分好页的论文（PageHelper插件）\nvar list = result.data.list\n\n// 2. 利用$.each来遍历这些数据 对每个数据进行筛选\n$.each(list, function (index, item) {\t\n\t//3. 首先获取到即将下载的论文名(鉴于我们上传时 是将论文的文件名存进数据库的)\n\tvar papername = item.papername  \n\t\n\t//4. 为每一项“模拟按钮” 动态加上类 方便我们后期动态remove掉\n\tvar download = $(\"<a></a>\").addClass(papername + \" btn btn-danger btn-sm\").append($(\"<span></span>\").addClass(\"glyphicon glyphicon-download\")).append(\"下载\").attr(\"href\", \"/DownloadServlet?paperName=\" + item.papername);\n\t\n\t//5. 查询该文件是否可下载\n\t$.ajax({\n\t\turl: \"isExistsFilename\",\n\t\tdata: {\"paperName\": item.papername},\n\t\ttype: \"GET\",\n\t\tdataType: \"JSON\",\n\t\tsuccess: function (result) {\n\t\t\t//数据库存储了文件信息的论文 才可以下载\n\t\t\t//如果为false表示不可下载 则根据对应的papername来remove样式\n\t\t\tif(result.data == false){\n\t\t\t\t$(\".\" + item.papername).remove();\n\t\t\t}\n\t\t},\n\t\terror: function (error) {\n\t\t\tconsole.log(error)\n\t\t}\n\t});\n});\n```\n\n**查询的控制层代码：**\n```java\n\t@RequestMapping(value = \"/isExistsFilename\", method = RequestMethod.GET)\n    @ResponseBody\n    public TSMResult isExistsFilename(\n            @RequestParam(\"paperName\") String paperName) {\n        //处理中文\n        Boolean isExists = false;\n        try {\n            paperName = new String(paperName.getBytes(\"ISO-8859-1\"), \"UTF-8\");\n            paperName = paperName + \".doc\";\n            Source source = adminServer.isExistsPaperFile(paperName);\n            isExists = (source == null) ? false : true;\n        } catch (Exception e) {\n            System.out.println(\"检测到异常！\");\n            e.printStackTrace();\n        }\n        return new TSMResult(200, \"查询成功\", isExists);\n    }\n```\n\n从代码中的三目运算符可以看出：\n\n```java\n\tisExists = (source == null) ? false : true;\n```\n\n* 如果这个文件为空则会true，否则为false\n\n* 也就是说，如果文件不为空，则为false，表示不可下载\n\n**服务层代码：**\n```java\npublic Source isExistsPaperFile(String paperName) {\n        return sourceMapper.selectPaperFile(paperName);\n    }\n```\n\n**具体Source类看上方代码即可。**\n\n**Mapper代码：**\n```java\n    @Select(\"select* from source where papername = #{paperName}\")\n    Source selectPaperFile(@Param(\"paperName\") String paperName);\n```\n\n# 实现通用JS代码全局引用（现在推荐Mixin全局组件复用）\n\n## ElementUI的Message消息提示、Notify通知等等\n\n**我们希望在弹出消息或者通知（Notify）时**\n\n* 根据我们自定义的参数，来相应提示用户\n\n1. 提示用户更改信息成功\n\n2. 这个提示类型是success类型\n\n只需调用：\n```js\nthis.$sendMessage('这是消息内容', 'info/success/error/warning')\n```\n\n*info 是灰色 success是绿色 error是红色 warning是黄色*\n\n### 创建通用功能的utils.js\n\n* 定义多个function 最后导出即可\n\n*注意，这里有一个知识点：对于默认导出的函数，使用时函数名外不需要{xxx}*\n\n*即直接： import XXX from 'xxx/xxx'*\n\n**而如果有多个函数，想要按需引入的话，需要加上{}**\n\n按需引入（包括默认导出函数）：\n\n```js\nimport { fun1, fun2 } from 'xxx/xxx'\n```\n\n```js\n//弹窗发送消息 以传入的参数而定\nexport function sendMessage(messageContent, messageType) {\n\tthis.$message({\n\t\tmessage: messageContent,\n\t\ttype: messageType,\n\t});\n}\n\nexport function alertTest() {\n\talert('这是测试方法！')\n}\n\nexport default sendMessage\n```\n\n### main.js中引入并使用\n```js\nimport { sendMessage,loadingAnimation } from './assets/js/utils'\nVue.prototype.$sendMessage = sendMessage \nVue.prototype.$alertTest = alertTest \n```\n\n这样我们就可以，直接在vue项目中：使用`this.$sendMessage`来使用相应方法了。\n\n# Vue3.x中的Mixin实现组件功能的复用\n为什么要有Mixin呢？从字面意思来说，我们就将**不同组件之间，所具有的相同功能以及相同数据。给他们混合进任意一个组件中MixIn。**。\n\n说白了，就是不同组件中共享公共的代码块。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210618143618684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n但是，比起一般的JS import export。\n\nmixin的优点在**我们可以直接传入涉及到data的数据**\n\n因为我们在传入数据的时候，如果涉及到data(){return{}}中的数据，我们必须在方法体中去处理。\n\n如果是一般的import&export，会找不到这个this，**如果用了Mixin，直接共享在一套data(){}与methods中，就不存在这个问题了。**\n\n代码如下：\n**1. 新建minxin目录写一个baseMixin.js来写所有的公共区域，并在最后export导出。**\n```js\nconst baseMixin = {\n    data() {\n        return {\n            data: \"通用数据\"\n        }\n    },\n    methods: {\n        showInfo() {\n            console.log(\"通用信息！\");\n        }\n    },\n}\n\nexport default baseMixin\n```\n\n**2. 在需要用公共代码块的地方，去import进来，并指定mixin。**\n```js\nimport baseMixin from \"../mixin/baseMixin\";\nmixins: [baseMixin],\ndata() {\n  return {};\n},\nmounted() {\n  console.log(this.data);\n  this.showInfo();\n},\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210618144736479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 当数据属性名字重复的时候：\n\n**如果当前使用Mixin的组件中的数据（1）的名字与Mixin定义的data中的属性名（2）重复时，Vue会使用（1）。**\n\n**如果是方法，也是如此，不会执行通用模板中的方法。**\n\n## 全局配置Mixin\n\n在main.js中定义:\n```js\nimport App from './App.vue'\nconst app = createApp(App)\n```\n\n配置全局Mixin\n```js\nimport baseMixin from 'baseMixin.js的路径'\napp.mixin(baseMixin)\n```\n\n# HTML中引入VUE并使用ElementUI样式\n\n## head标签引入ElementUI的CSS、JS以及VUE的JS\n\n```html\n<link rel=\"stylesheet\" href=\"https://unpkg.com/element-ui/lib/theme-chalk/index.css\">\n<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/element-ui/lib/index.js\"></script>\n```\n\n## 初始VUE（2.0版本）\n1. 页面非body标签 标记\n\n```html\n<div id=\"app\"> \n\n</div>\n```\n2. vue挂载上去（可以**使用template写HTML页面 如果已经有内容了就去掉template**）\n```js\nnew Vue({\n      el: '#app',\n      data() {\n      \treturn {\n      \t\t\t\n      \t}\n      },\n      methods: {\n      \t\n      },\n      created() {\n\t  \n\t  },\n\t  mounted() {\n\t\t\t\n\t  }\n    })\n```\n\n","tags":["前端框架学习"],"categories":["前端框架学习"]},{"title":"Gitee_上传项目","url":"/2021/06/01/Gitee-上传项目/","content":"\n# Gitee上传项目\n## 1. 创建一个仓库（要用到git地址）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210601232408867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n### 配置Git.config\n```java\ngit config --global user.name \"vincent990413\"\ngit config --global user.email \"370216714@qq.com\"\n```\n\n<mark>#点击初始化readme文件</mark>\n\n## 2. 克隆git地址\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210601232702181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n随便创建一个文件夹，**Git Bash**中进入这个文件夹\n\n<mark>（这个文件夹的名字无所谓）</mark>，\n\n输入代码：\n\n```java\ngit clone xxxxx.git\n```\n\n<mark>然后将目标文件夹里面的内容（不包括文件夹）直接复制过来。</mark>\n\n然后输入代码：\n\n```java\ngit add .\n```\n\n然后输入代码：备注：\n```java\ngit commit -m \"备注\"\n```\n\n然后依次输入：\n```java\ngit pull origin master\n\ngit push -u origin master\n```\n\n","tags":["Gitee上传项目"],"categories":["Gitee上传项目"]},{"title":"设计模式学习_工厂方法模式","url":"/2021/05/25/设计模式学习-工厂方法模式/","content":"\n# 工厂方法设计模式 Factory Pattern\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/EcFVTgRHJLM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n## 定义以及抽象层面\n* **工厂方法定义了一种更好地创造对象的方式。但是它让工厂子类来决定怎么创造以及创造哪一个对象。也就是说，工厂模式将创造对象的过程延迟给子类来进行。**\n\n**它以这两种东西组成：**\n\n**1. 我们想要创造的对象。**\n\n**2.我们用来创造这些对象的工厂。**\n\n抽象层面的图所示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021052520590059.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**# 我们可以看到：**\n\n**1. 左边代表的是各个我们需要创建的对象。**\n\n**2. 右边代表的是我们用什么（工厂）来创建，当然了，根据什么规则来创建这些对象，我们也可以写在工厂中。**\n## 具体案例层面以及代码实现\n**# 现在，我们用可以实现的代码形式来说明：**\n\n重要的图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210525210510585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n* 也就是说，业务场景如下：我们需要创造一个可以画出形状的图形：可以是画出长方形，正方形或者圆形。我们利用工厂类来有逻辑地创造这些类。\n\n1. 接口 形状 Shape.java\n```java\npackage com.company.inter;\n\npublic interface Shape {\n    void draw();\n}\n```\n\n2. 具体的实现子类.java\n```java\npackage com.company.impl;\n\nimport com.company.inter.Shape;\n\npublic class Circle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"画出来的是圆形图案...\");\n    }\n}\n```\n\n```java\npackage com.company.impl;\n\nimport com.company.inter.Shape;\n\npublic class Rectangle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"画出来的是长方形图案...\");\n    }\n}\n```\n\n```java\npackage com.company.impl;\n\nimport com.company.inter.Shape;\n\npublic class Square implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"画出来的是正方形图案...\");\n    }\n}\n```\n\n3. 创造指定对象的工厂.java\n```java\npackage com.company.factory;\n\nimport com.company.impl.Circle;\nimport com.company.impl.Rectangle;\nimport com.company.impl.Square;\nimport com.company.inter.Shape;\n\npublic class ShapeFactory {\n    public Shape getShape(String specificShapeName) {\n        //定义如何生成对象的逻辑\n        if (specificShapeName.equals(\"Rectangle\")) {\n            return new Rectangle();\n        } else if (specificShapeName.equals(\"Square\")) {\n            return new Square();\n        }else if (specificShapeName.equals(\"Circle\")) {\n            return new Circle();\n        }\n        return null;\n    }\n}\n```\n\n4. 测试的主函数Main.java\n```java\npackage com.company;\n\nimport com.company.factory.ShapeFactory;\nimport com.company.inter.Shape;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        ShapeFactory shapeFactory = new ShapeFactory();\n\n        //通过指定不同的名字 来创造不同的对象（依照具体的业务场景来定义不同的对象创建规则）\n        Shape s1 = shapeFactory.getShape(\"Circle\");\n        s1.draw();\n\n        Shape s2 = shapeFactory.getShape(\"Square\");\n        s2.draw();\n    }\n}\n```\n\n## 效果图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210525211649951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n","tags":["设计模式"],"categories":["设计模式"]},{"title":"Java技巧_配置视图解析器","url":"/2021/05/23/Java技巧-配置视图解析器/","content":"\n# SpringBoot配置MVC视图解析\n* **首先确保自己创建的是SpringBoot项目**\n\n**项目结构图如下：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210523113008103.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n接下来正式开始配置：\n## 1. 在SpringBoot的配置文件中\n\n```java\nspring.mvc.view.prefix=classpath:/static/\nspring.mvc.view.suffix=.html\n```\n<mark>（主要看图配置！）</mark>\n\n## 2. Controller层写代码跳转即可\n```java\n@RequestMapping(\"/user\")\n@Controller\npublic class User{\n\t@GetMapping(\"/index\")\n\tpublic String toIndex(){\n\t    return \"index\";\n\t}\n}\n```\n\n**注意，这里不能用@RestController注解**\n","tags":["Java编程实用小技巧"],"categories":["Java编程实用小技巧"]},{"title":"Spring Security学习笔记","url":"/2021/05/22/SpringSecurity学习笔记/","content":"\n\n# 安全保证框架\nShiro与Spring security\n\n**他们之间很像，除了名字、类名不一样。**\n\n## Spring Security\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210505205603112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n1. 可以实现定制化身份认证 Authentication\n\n2. 权限控制 Access of Control\n\n权限：\n* 功能权限\n\n* 访问权限\n\n* 菜单权限\n\n**Spring Security 用于简化过滤器&拦截器**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210505210813433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n* WebSecurityConfigurerAdapter：自定义Security策略（适配器模式）\n\n* AuthenticationManagerBuilder：自定义认证策略（建造者模式）\n\n## AOP概念\n我们不用改变原来项目的业务代码，而是在项目中加入`config`。帮我们去做一些事情\n\n\n# 入门案例\n\n* 使用工具idea，新建一个Spring initize项目（只勾选一个web即可）\n\n* 使用SpringBoot 2.2.1版本来使用: pom.xml文件中修改\n\n* 添加springboot-security依赖\n\n## 修改controller 体验security\n在controller包下新增TestController.java\n```java\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/test\")\npublic class TestController {\n\n    @GetMapping(\"/hello\")\n    public String add(){\n        return \"Hello, Spring Security!\";\n    }\n}\n```\n\n## 修改默认端口（避免占用）\n在application.properties中\n\n```java\nserver.port = 8181\n```\n\n## 启动项目并测试\n```html\nlocalhost:8181/test/hello\n```\n\n系统会出现这个界面：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506150610548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\nSpring Security会强制让我们先登录。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021050615072796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n1. 默认的用户名：`user`\n\n2. 控制台（如图）会出现我们的默认密码`Using generated security password`\n\n**在正确输入后，会出现下图效果：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506150809240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n# SpringSecurity 基本原理（过滤链）\nSpring Security框架本质上就是**一套的过滤器链 FilterChain**\n\n也就是说，有很多的过滤器Filter，执行到具体方法时，就会进入过滤器，只有过滤器对其进行过滤放行，才能进入到下一个过滤器。\n\n## 常见三个过滤器\n### FilterSecurityInterceptor\nFilterSecurityInterceptor是一个方法级的权限过滤器，具体有doFilter方法。\n\n首先看之前的过滤器是否执行，如果执行，才执行自己的过滤器。\n\n### ExceptionTranslationFilter\nExceptionTranslationFilter是一个处理权限过程中，出现的异常问题的过滤器。依据每个不同的异常，做不同的处理。\n\n### UsernamePasswordAuthenticationFilter\n对`/login`且使用POST请求过来的表单做一个用户名密码校验。\n\n# SpringSecurity 过滤器的加载过程\n## 使用Spring Security配置过滤器\n如果使用SpringBoot项目的话，自动帮我们集成以下的这些代码。\n\n* 如果不用SpringBoot项目集成SpringSecurity的话，需要写一个DelegationFilterProxy过滤器。\n\n而这个DelegationFilterProxy的doFilter方法中，有一个init初始化方法，这个初始化方法中，用于获得FilterChainProxy，这个Proxy中有一个doFilterInternal方法，这个方法中有一个`List<Filter>`很多个过滤器，并通过迭代的方式`getFilters`获得这些所有的过滤器。\n\n# SpringSecurity 中重要的接口 \n## UserDetailsService 用户细节信息接口\n在实际开发中，我们的账号和密码，并不是Spring Security所默认的user和默认生成密码。\n\n而都是从数据库中查询出来的。\n\n因此，这个接口很方便我们进行自定义逻辑业务开发。\n\n**实现这个UserDetailsService接口即可，在这个实现方法中，写查数据库的方法。**\n\n1. 创建一个类，继承UsernamePasswordAuthenticationFilter过滤器（重写三个方法）\n\n2.  创建一个类，重新UserDetailsService接口，编写查询数据过程，并返回User对象（这个对象由Security提供）\n\n## PasswordEncoder 密码加密接口\n在上一个**UserDetailsService**中我们**需要返回一个Spring Security框架中的User对象，在这个对象中的密码，必须是要返回加密后的密码。而不能是明文。**\n\n\n# Web项目中 认证&授权 思路\n**认证 Authentication**： 就是用户在登录Web中，利用自己的用户名与密码，进行用户认证。\n\n## 设置登录的用户名与密码\n1. 通过 application.properties 配置文件进行配置\n\n2. 通过配置类\n\n3. 通过自定义编写实现类，实现UserDetialsService，返回这个User对象即可\n\n### 1. 通过配置文件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506154818396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n配置代码如下：\n```java\nspring.security.user.name = user\nspring.security.user.password = 123456\n```\n\n\n## 2. 通过自定义配置类\n1. 添加注解@configuration\n\n2. 继承WebSecurityConfigurerAdapter类\n\n3. 重写这个类的方法（如下图）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210506155540523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**在重写这个方法时，我们利用auth来配置用户信息，对于密码需要加密。**\n\n而且，**要记得加一个@bean注解用于验证PasswordEncoder映射**，否则会报错。\n\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n@Configuration\npublic class SecurityConfig  extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        //利用这个auth来设置登录的用户信息\n        // 密码需要加密\n        BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();\n        String  passwordEncoded =  bCryptPasswordEncoder.encode(\"123456\");\n        auth.inMemoryAuthentication().withUser(\"user\").password(passwordEncoded).roles(\"admin\");\n    }\n\n    @Bean\n    PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n现在我们可以用这个**用户名user 密码123456**去登录了。而这个user用户，具有的角色是：**admin**\n\n## 3. 利用UserDetailsService接口配置（开发经常用）\n1. 创建配置类，auth使用UserDetailsService(注入一个UserDetailsService类)\n\n2. 编写实现类，**返回User对象，这个对象由用户名、密码以及权限**\n\n### 创建配置类SecurityUserServiceConfig\n```java\npackage com.vincent.securitydemo.config;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n@Configuration\npublic class SecurityUserServiceConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth\n                .userDetailsService(userDetailsService)\n                .passwordEncoder(passwordEncoder());\n                //1. 使用UserDetailsService\n                //2. 使用返回的PasswordEncoder @Bean加密\n    }\n\n    @Bean\n    PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n### 编写实现类MyUserDetailsService\n编写一个实现类MyUserDetailsService去实现UserDetailsService（我们的配置类需要），重写这个loadUserByUsername方法加载用户信息。\n\n注意：@Service(\"userDetailsService\")\n\n这个参数要与配置类中，@Autowire自动装配的名字一样。不然找不到。\n```java\npackage com.vincent.securitydemo.service;\n\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.AuthorityUtils;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n@Service(\"userDetailsService\")\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        // 手动代替查询数据库操作\n        List<GrantedAuthority> authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\");\n        \n        return new User(\"user\", new BCryptPasswordEncoder().encode(\"123456\"), authorityList);\n    }\n}\n```\n\n* 注意，我们返回的User对象有三个参数：用户名，加密后的密码以及一个Collection表示具有的权限集合\n\n\n## 加入数据库操作 到MyUserDetailsService实现类中\n\n**整合MybatisPlus进入到这一步，实现具体的数据库操作。**\n\n### 引入相关依赖\n\n1. 引入MybatisPlus依赖\n\n2. 引入MySQL依赖\n\n3. 引入工具类Lombok 方便实体类注解\n\n```java\n<!--web项目依赖-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <!--security依赖-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n\n        <!--pojo注解生成get、set方法-->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n        </dependency>\n\n        <!--mybatis依赖-->\n        <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus-boot-starter</artifactId>\n            <version>3.1.1</version>\n        </dependency>\n\n        <!--MySQL依赖-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n\n        <!--测试依赖-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n```\n\n### 处理数据库中的User表\n\n1. id 自增数字主键\n\n2. username varchar类型\n\n3. password varchar类型\n\n\n### 处理Mapper 继承Mybatis+ 给我们写好的基本Mapper即可\n\n1. 创建mapper包 UserMapper接口 extends BaseMapper<T> 泛型\n\n```java\npackage com.vincent.securitydemo.mapper;\n\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.vincent.securitydemo.entity.User;\n\n@Repository\npublic interface UserMapper extends BaseMapper<User> {\n\t\n}\n\n```\n\n### 重写之前MyUserDetailsService实现类中的方法 通过数据库查询\n\n1. Service实现类中 注入UserMapper对象\n\n```java\n@Service(\"userDetailsService\")\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {\n        \n\t\t// 数据库查询语句 用于认证用户\n        //并最终返回Security框架中的User对象\n\t\treturn ...;\n    }\n}\n```\n\n2. 利用Mybatis-plus中的QueryWrapper帮我们规定查询满足的条件 并通过UserMapper中的查询方法，注意判断**根据用户名查询出来的User对象（我们定义的Entity）是否为空**\n\n3. 最终**返回Spring Security框架自己的User对象**\n\n<mark>注意看代码中的注释内容！！！</mark>\n\n```java\npackage com.vincent.securitydemo.service;\n\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.vincent.securitydemo.entity.User;\nimport com.vincent.securitydemo.mapper.UserMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.AuthorityUtils;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n@Service(\"userDetailsService\")\npublic class MyUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        //数据库查询语句 用于认证用户\n        //参数中的s 即代表用户提交表单中的用户名\n        //现在我们要根据用户名 去查询对应的数据库中是否存在这个数据\n\n        QueryWrapper<User> wrapper = new QueryWrapper<>(); //条件构造器 通过这个构造器去做查询 类似UserExample\n        wrapper.eq(\"username\", username);\n        User user = userMapper.selectOne(wrapper);\n\n        if (user == null) { //认证失败 没有存在的用户\n            throw new UsernameNotFoundException(\"用户名不存在\");\n        }\n\n        //注意我们返回的不是自己的实体类User\n        //而是security框架给我们提供的User类\n        List<GrantedAuthority> authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\");\n        return new org.springframework.security.core.userdetails.User(user.getUsername(), new BCryptPasswordEncoder().encode(user.getPassword()), authorityList);\n    }\n}\n```\n\n4. **这一步很关键** 我们要**在SpringBoot启动类中 加一个注解@MapperScan 启动Mapper 不然的话无法识别我们的Mapper**\n\nSecuritydemoApplication.java\n```java\npackage com.vincent.securitydemo;\n\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n@MapperScan(\"com.vincent.securitydemo.mapper\")\npublic class SecuritydemoApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SecuritydemoApplication.class, args);\n    }\n\n}\n```\n\n5. application.properties 配置文件中 配置数据库信息\n\n对于本SpringSecurity测试的SpringBoot版本是SpringBoot 2.2.1 Release\n\n因此，**在引入数据库驱动时，如果使用的是MySQL8.0驱动且加入时区**\n\n引入时，应使用：`com.mysql.cj.jdbc.Driver\n`\n```yml\nserver.port = 8181\n\n#可直接通过配置文件 来配置用户信息\n#spring.security.user.name=user\n#spring.security.user.password=123456\n\n#数据库连接\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.url = jdbc:mysql://localhost:3306/securitydemo?characterEncoding=utf-8&serverTimezone=GMT%2B8\nspring.datasource.username = root\nspring.datasource.password = 123456\n\nspring.jpa.show-sql = true \n```\n\n# 自定义登录页面&设置路径不需要认证\n\n\n**在实际的业务开发中，我们需要自己的好看的登录页面。因此接下来我们将指定登录的页面。**\n\n**在实际的业务开发中，有些Controller是不需要进行验证用户权限的。我们也进行设置。**\n\n\n<mark>主要思路就是，在 SecurityConfig 配置类中，配置一下就可以了。</mark>\n\n值得注意的是，现在我们还是用到configure方法，但是里面的参数不是`AuthenticationManagerBuilder auth`，而是`HttpSecurity http。`\n\n我们通过`http.formLogin()` 进行一系列的设置\n\n1. 设置默认登录页面的路径\n\n2. 设置默认登录的请求路径（SpringSecurity自动帮我们实现）\n\n3. 设置默认登录成功跳转的路径\n\n4. 设置哪些路径不需要认证，直接通过\n\n```java\npackage com.vincent.securitydemo.config;\n\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\n@Configuration\npublic class SecurityUserServiceConfig extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private UserDetailsService userDetailsService;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        //配置用户认证\n        auth\n                .userDetailsService(userDetailsService)\n                .passwordEncoder(passwordEncoder());\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //完成与HTTP请求的配置设置\n        http.formLogin()\n                .loginPage(\"/login.html\") \n                 //自定义自己编写的登录页面 参数是地址\n                .\n                loginProcessingUrl(\"/user/login\")  \n                //定义登录访问的请求路径 但是这个具体的方法过程由SpringSecurity实现\n                \n                .failureUrl(\"/error.html\")\n                //定义登录错误跳转的页面 参数是地址\n\n                .defaultSuccessUrl(\"index.html\").permitAll()   \n                //定义默认登录成功后 跳转到的路径\n                \n                .and().authorizeRequests().antMatchers(\"/\", \"/test/hello\", \"/user/login\").permitAll()\n                .anyRequest().authenticated()\n                //授权通过，这些路径是不需要认证，直接让它过！\n                \n                .and().csrf().disable(); //关闭CSRF认证方式\n    }\n\n    @Bean\n    PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n**现在我们只需要，一个登录页面，一个处理登录成功的controller**\n\n* 注意我们这里的action值，必须**跟config中配置的请求路径相同**，而且**name只能是用户名和密码**。 \n\n*resources/static/login.html*\n```html\n<form action=\"/user/login\" method=\"post\">\n        用户名：<input type=\"text\" name=\"username\"> <br>\n        密码： <input type=\"password\" name=\"password\">\n        <input type=\"submit\" value=\"登录\">\n    </form>\n```\n*resources/static/error.html*\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>错误页面</title>\n</head>\n<body>\n    <h1>抱歉，登录错误！</h1>\n</body>\n</html>\n```\n\n*resources/static/index.html*\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>主页面</title>\n</head>\n<body>\n    <h1>登录成功，这是主界面！</h1>\n</body>\n</html>\n```\n\n*controller/TestController.java*\n```java\n\t@GetMapping(\"/index\")\n    public String toIndex(){\n        return \"Hello, Index!\";\n    }\n```\n\n# 基于角色或者权限的访问控制\n## 1. hasAuthority方法\n\n**对于这个方法，如果用户具有指定的权限，则返回True，否则返回False.**\n\n**# 在config中声明只有哪些权限可以通过这个路径请求**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210522204147176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n```java\n//只有具有admin权限 才能访问这个/test/index这个路径(同时在Service中加入admin）\n.antMatchers(\"/test/index\").hasAuthority(\"admin\")\n```\n\n**# Service中加入这些权限**\n```java\n//在Service中加入admin权限\nList<GrantedAuthority> authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(\"admin\");\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210522205711287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n当出现上述图片时，**代表403权限不够！**\n\n## 2. hasAnyAuthority \n\n* 当某个请求对于声明的角色中，**任意一个角色都可以**通过时使用。\n\n**比如对于学生的管理，教师Teacher与管理员Admin都可以访问这些接口路径。**\n\n```java\n.antMatchers(\"/test/index\").hasAnyAuthority(\"admin,teacher\")\n```\n\n则表示，当权限为teacher或者admin...等等时（用逗号隔开即可）都允许通过！\n\n## 3. hasRole\n\n* 基本用法不变，但是源码显示：它会将我们**声明的角色名xxx**变成**ROLE_+xxx。**\n\n因此，我们在Service中，声明具有的角色时，**应该手动添加为ROLE_xxx。**\n\n#配置类\n```java\n.antMatchers(\"/test/index\").hasRole(\"salesman\")\n```\n\n#Service声明具有的权限\n```java\nList<GrantedAuthority> authorityList = AuthorityUtils.commaSeparatedStringToAuthorityList(\"admin,Role_salesman\");\n```\n\n## 4.  hasAnyRole \n**用法与hasAnyAutority一致。**\n\n# 自定义无权限403页面\n\n* 在配置类中，配置自定义403页面即可。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210522210640704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n```java\nhttp.exceptionHandling().accessDeniedPage(\"/unauth.html\");\n```\n\n如果满足无权限条件的话，会跳转到这个页面。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210522210800475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n# SpringSecurity 认证&授权 常见的注解\n* 注解的作用，就是简化开发。\n\n## @Secured(\"ROLE_XXX, ROLE_YYY\")\n**这个注解表示：用户具有某个角色，可以根据这个角色来访问相应的接口。**\n\n**使用这个注解时，我们要打开注解功能：**\n\n1. 添加注解到**Springboot启动类**或者**Config配置类**上：\n```java\n@EnableGlobalMethodSecurity(securedEnabled = true)\n```\n\n2. 在Controller的方法上面，使用这个注解，自动为我们判断角色权限。\n\n```java\n@GetMapping(\"/deleteUser\")\n@Secured(\"ROLE_admin\")\n public String deleteUser(){\n     return \"通过权限，这是删除页面！\";\n }\n```\n\n**表示这个方法，必须要具有admin角色才能进入。**\n\n## @PreAuthorize\n\n* 这个是**在方法执行之前进行校验。**\n\n1. 在启动类相同位置，逗号，开启**prePostEnabled = true**\n```java\n@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true)\n```\n\n2. 在相应方法上，加入注解**@PreAuthorize()**\n```java\n@GetMapping(\"/updateUser\")\n@PreAuthorize(\"hasRole('ROLE_admin')\")\npublic String updateUser(){\n    return \"通过权限，这是更改页面！\";\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210522212525782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n可以看到，这里可以选择之前的四种：\n\n1. hasRole\n2. hasAnyRole\n3. hasAuthority\n4. hasAnyAuthority\n\n* 注意涉及到Role时，手动添加**ROLE_XXX**即可。\n\n\n## @PostAuthorize\n\n* 这种方式用得频率比较少，**代表：执行方法之后，再进行校验**。**一般适用于，带有返回值的校验方式！**\n\n **也就是说，方法是一定会执行的。**\n\n只不过是，方法执行后，遇到了403权限错误。\n\n```java\n@GetMapping(\"/afterMethodVerify\")\n@PostAuthorize(\"hasRole('ROLE_admin')\")\npublic String afterMethodVerify(){\n\tSystem.out.println('一定会执行的！');\n   return \"通过权限，这是目标页面！\";\n}\n```\n\n# 用户实现注销\n## 1. 配置注销的请求路径以及注销成功后跳转的URL（可以是HTML）\n\n```java\n//配置注销\nhttp.logout().logoutUrl(\"/logout\").logoutSuccessUrl(\"/login.html\").permitAll();\n```\n\n**这里可以看到，我们配置注销url是/logout（框架内置）**\n\n**并且当成功注销后，跳转到login.html。**\n\n## 2.在任意页面中添加/login请求路径\n**比如我们可以在登录后跳转的主界面index.html中，加入一个超链接:**\n```html\n<a href=\"/logout\">点我注销</a>\n```\n**这样就可以实现了。**\n\n测试如下：\n\n**1. 在未认证的情况下，访问index.html。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210523135635391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**此时会自动跳转到，login.html登录页面。**\n\n2. 登录之后**进入index.html**此时点击该页面上的**注销锚点**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210523140202814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**此时进入登录页面，再访问index.html后会自动跳转到login.html。**\n\n# 用户实现自动登录\n## 使用cookie技术\n* 缺点：是客户端技术，如果有**敏感数据，不建议使用**这个技术。\n\n## 使用Spring security安全框架机制实现\n* 实现原理图如下：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210523141512530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n* 详细步骤如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210523142006720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n### 1. 数据库创建表（可选择自动帮我们创建）\n### 2. 配置类注入数据源\n配置类SecurityUserServiceConfig.java\n```java\n//将数据库源\n@Autowired\nprivate DataSource dataSource;\n\n//操作数据库的对象\n@Bean\npublic PersistentTokenRepository persistentTokenRepository(){\n    JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl();\n    jdbcTokenRepository.setDataSource(dataSource);\n     //自动帮我们创建表\n    jdbcTokenRepository.setCreateTableOnStartup(true); \n    return jdbcTokenRepository;\n}\n```\n* **第一次运行时会自动帮我们创建SQL表，之后我们注释到setCreateTableStartup这一行即可。**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021052614194418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n### 3. 配置类设置记住我rememberMe相关信息\n**# 将这个PersistentTokenRepository对象配置进来**\n\n```java\n//设置记住我(自动登录)以及记住的时间长度\n.and().rememberMe().tokenRepository(persistentTokenRepository())\n.tokenValiditySeconds(60).userDetailsService(userDetailsService)\n.and().csrf().disable(); \n//关闭CSRF认证方式\n```\n\n### 4. 前端页面加入记住我复选框\n* 注意，**这里复选框的name属性值**不能是其他名字，**Spring Security规定只能是**`remember-me`。\n\n```html\n   <form action=\"/user/login\" method=\"post\">\n       用户名：<input type=\"text\" name=\"username\"> <br>\n       密码： <input type=\"password\" name=\"password\">\n       <br/>\n       60秒内自动登录：<input type=\"checkbox\" name=\"remember-me\" >\n       <input type=\"submit\" value=\"登录\">\n   </form>\n```\n\n**这样的话，在每次登录时，打开控制台可以看到Cookie相关信息**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210526142502349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210526142539439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n图中可以看到，有一个 `remember-me` Cookie信息。\n\n**在60秒内（配置类中设置时长），可以直接免去登录而跳转到其他页面中。**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210526142954966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n# CSRF理解\n* **CSRF：Cross-site Request Forgery。是一种控制用户在已登录的Web应用程序中执行非本意的操作的攻击方法。简单来说，就是攻击者利用一些技术手段来欺骗用户的浏览器去访问自己曾经认证过的网站并运行一些操作，利用Web中用户认证的漏洞。**\n\n**Spring Security默认打开CSRF防护功能！我们可以手动关闭它的防护功能。**\n\n通过以下代码实现：\n```java\n.and().csrf().disable(); //关闭CSRF认证方式\n```\n\n## Spring Security 中的CSRF\n1. 第一次登录时，由于缺少Token，因此Spring Security会帮我们**生成一定长度的Token**放进**Session或者Cookie**中。\n\n2. 在下次请求时**会带着Token进行请求**，与已有保存的httpToken字符串进行比对！！！**如果比对失败，则不允许。以此来实现防护CSRF攻击！**\n\n### CsrfFilter来实现这个过程","tags":["Spring 全家桶学习"],"categories":["Spring 全家桶学习"]},{"title":"Java适应前端JSON参数_万物皆可Map","url":"/2021/05/19/Java适应前端JSON参数-万物皆可Map/","content":"\n**来源于之前做过的ECharts引入饼图数据：**\n\n[点我回顾ECharts](https://bruce-jj.gitee.io/blog/2021/05/12/VUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%BA%94%E7%94%A8-4/#VUE%E4%B8%AD%E6%B7%BB%E5%8A%A0Echarts%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E8%A1%A8)\n\n我们前端图表data中有两个参数：\n1. name 代表饼图每一部分的名称\n\n2. value 代表饼图每一部分的数据量（自动根据这个数据量更改比例）\n\n**因此我们前端需要复杂处理：name与value**\n\n```js\n//同步请求数据\n$.ajax({\n\turl: \"${request.getContexPath()}/meal/showData\",\n\ttype: \"POST\",\n\tdataType: \"JSON\",\n\tasync: false,\n\t// 回调函数\n\tsuccess: function (res){\n\t\tdata = res //这里具体看链接中 引入的饼图ECharts\n\t},\n\terror: function (error){\n\t\tconsole.log(error)\n\t}\n})\n```\n\n**data中是这样的:**\n```js\ndata:[ { \"name\": \"bookName\", value: \"20\" }]\n```\n\n```java\n    @ResponseBody\r    @RequestMapping(\"/showData\")\r    public List<Map<String,Object>> showData(\n\t\t\tModel model, \n\t\t\tHttpServletRequest request){\n\t\t\t\t\r        //  查询所有订单信息\r        List<OrderItem> list = orderItemService.list();\n\t\t\n\t\t//map: productId(Integer类型) 次数(Integer类型) \r        Map<Integer,Integer> map = new HashMap<>();\n\t\t\n\t\t//遍历所有待处理的list\r        //利用map的键值唯一性统计各（具体item对象）数量\r        list.forEach(i -> {\n\t\t\t//如果存在对应的pid 作为键 那么就累加sum\n\t\t\t//否则（第一次检索） 赋值为默认1\r            map.merge(i.getPid(), 1, Integer::sum);\r        });\r\r        //查询商品名字返回结果集\n\t\t//值用Object更加的灵活\r        List<Map<String,Object>> res = new ArrayList<>();\r\t\t\t\r        //map映射转换为 集合set\r        Set<Map.Entry<Integer, Integer>> entries = map.entrySet();\n\t\t\r        //遍历这个集合\r        entries.forEach(entry -> {\r            Map<String,Object> map1 = new HashMap<>();\n\t\t\t\r            //获取到集合中的每一个key值\r            Integer key = entry.getKey();\n\t\t\t\r            //根据这个key值（也就是pid) 去找对应的product对象\r            Product product = productService.get(key);\n\t\t\t\r            //将需要两个属性 put进去\r            //我们需要前端data的name:val value:value\r            map1.put(\"name\", product.getName());\r            map1.put(\"value\", entry.getValue());\r            res.add(map1);\r        });\r        return  res;\r    }\n```\n\n"},{"title":"设计模式学习_装饰器模式","url":"/2021/05/18/设计模式学习-装饰器模式/","content":"\n# 装饰器模式  Decorator Pattern\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/GCraGHx6gso\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n* 试想有一个**平安夜苹果**，我们用一个精美的盒子将其装入，同时我们可以按照自己的需要，在最外层继续装精美的盒子（例子不太恰当）。\n\n**而这就是装饰器模式，本身的工作原理。**\n\n## 定义\n\n**1. 装饰器模式，允许我们像现有的对象添加新的功能同时不改变其设计结构。**\t\n\n**2. 是作为现有类的一个包装，即本质上，还是这个类**\n\n**3. 动态扩展或者撤销类的功能**\n\n同时，装饰器模式可以解决，一般继承Inheritance的缺陷。\n\n我们知道，**当一个类继承另一个类是，它必须具备这个类的所有功能（包括属性与方法）。**\n\n这样是有缺陷的，比如：\n\n我们有一个**叫做Beverage 饮料的类 是一个抽象类（代表我们不能像接口一样 去实例化）**\n\n其中，Beverage有价格属性以及得到价格的方法\n\n现在Beverage有两个子类：**1. 咖啡 2. 茶**\n\n**现在我们按照一般的思路来添加功能，就是直接在Beverage类中添加（比如咖啡是否加牛奶）**\n\n但是，试想一下，如果有牛奶这个属性，对于茶来说，就可能显得没必要了（抱歉如果你喜欢这么搭配，无意冒犯）\n\n* **也就是说，部分子类有时，没必要拥有父类的所有信息。**\n\n所以，我们的装饰器模式就是来解决这样的问题：**如何在不更改已有代码的同时，更高效地添加对象的功能。**\n\n## UML图示\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210518105159541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n从这个图中，我们需要看到最重要的概念：\n\n1. 对于装饰器来说，它**即具有饮料成员变量，同时自己又是一个饮料**\n\n**很好解释：对于奶茶店里的珍珠，首先它要知道自己加到哪杯饮料上去，其次加到那杯饮料过后，它们共同组成了一杯新的饮料。**\n\n这样，一层一层的包裹，可以动态地延展系统中对象的功能。\n\n## 代码实现\n\n1. 这里我们有Milk与Coffee两种饮料，分别卖5元与10元\n\n2. 这里我们有可选选项Sugar，加糖多加1元\n\n首先我们要有抽象类Beverage.java\n```java\npackage com.company.entity;\n\npublic abstract class Beverage {\n    public abstract int getPrice();\n}\n\n```\n\n然后我们有两个继承Beverage的Milk.java与Coffee.java\n```java\npackage com.company.entity;\n\npublic class Milk extends Beverage{\n\n    //假设菜单上规定 牛奶一杯5元\n    @Override\n    public int getPrice() {\n        return 5;\n    }\n}\n\n```\n\n```java\npackage com.company.entity;\n\npublic class Coffee extends Beverage{\n\n    //假设菜单上规定 咖啡一杯10元（注意，咖啡与牛奶都是基础选项）\n    @Override\n    public int getPrice() {\n        return 10;\n    }\n}\n```\n\n接下来我们要有，一个抽象类AddOnDecorator.java\n```java\npackage com.company.decorator;\n\nimport com.company.entity.Beverage;\n\npublic abstract class AddOnDecorator extends Beverage {\n    public abstract int getPrice();\n}\n\n```\n\n最后我们要有自己的可选选项SugarDecorator.java去继承这个抽象类\n```java\npackage com.company.decorator;\n\nimport com.company.entity.Beverage;\n\npublic class SugarDecorator extends AddOnDecorator {\n\n    //被包裹的内层 不管之前加了什么\n    // （可以是咖啡来加糖 也可以是牛奶来加糖）\n    Beverage beverage;\n\n    public SugarDecorator(Beverage beverage){\n        this.beverage = beverage;\n    }\n\n    //这里糖是可选选项\n    // 当你给已有的饮料加糖时 加上糖后\n    // 仍然是饮料 还可以加其他的东西\n    @Override\n    public int getPrice() {\n        return this.beverage.getPrice() + 1;\n    }\n\n}\n```\n\n**这里的关键代码是：**\n```java\nBeverage beverage;\n...\n\nreturn this.beverage.getPrice() + 1;\n\n```\n\n就相当于**给里层的饮料，加了一层价格1元**，**但是里层的饮料还加了什么我们不在乎。**\n\n因为，**不管加了什么可选选项，它同时就是一杯饮料。**\n\n最后，我们用Main.java运行即可：\n```java\npackage com.company;\n\nimport com.company.decorator.SugarDecorator;\nimport com.company.entity.Beverage;\nimport com.company.entity.Coffee;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Coffee coffee = new Coffee();\n        System.out.println(\"如果只点一杯咖啡，价格是：\" + coffee.getPrice()  + \"元\" );\n\n        System.out.println(\"...\");\n\n        System.out.println(\"咖啡太苦了，准备加糖...\");\n\n        SugarDecorator sugarDecorator = new SugarDecorator(coffee);\n\n        System.out.println(\"加完糖后，整个饮料的价格是：\" + sugarDecorator.getPrice());\n\n    }\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210518110234967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n","tags":["设计模式"],"categories":["设计模式"]},{"title":"毕业答辩_重点图表","url":"/2021/05/17/毕业答辩-重点图表/","content":"\n# E-R 图\n> E-R图也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。\n\n1. **矩形框代表实体**\n\n2. **菱形框代表联系**\n\n3. 实线上的**1:1 1:m m:n**分别代表**一对一、一对多以及多对多关系**\n\n4. **椭圆框代表实体的各个属性**，如果是**主键则加上下划线。**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210517092317501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n# 时序图\n\n> 时序图（Sequence Diagram），又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。它可以表示用例的行为顺序，当执行一个用例行为时，其中的每条消息对应一个类操作或状态机中引起转换的触发事件。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515133106187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**时序图由以下部分构成：**\n1. 角色\n**角色通常是人（图中的教师）**，当然也可以是系统或者子系统\n\n2. 对象\n**对象通常位于时序图的顶部**，一般**直接写类名即可**\n\n3. 生命线\n**对象下面的虚线**即称为生命线，而**消息在两条生命线之间进行传递**\n\n4. 控制焦点\n控制焦点，一般指的是**对象下的矩形框**，即**对象操作的声明周期**\n\n5. 消息\n在两条相邻的生命线中，消息在这之间进行传递，**消息传递的本质就是方法的调用**。\n\n# 数据流图\n> 数据流图（Data Flow Diagram）：简称DFD，它从数据传递和加工角度，以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210517100409218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n> 值得注意的是，数据流图不是传统的流程图或框图，数据流也不是控制流。**数据流图是从数据的角度来描述一个系统**，而**框图是从对数据进行加工的工作人员的角度来描述系统**。\n\n也就是说，数据流图的根本，就是**用不同层级来描述数据是怎样流动的，从哪里到哪里，中间经过了什么加工处理。**\n\n数据流图，分为**顶层与第一层、第二层**...\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210517100810557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n# UML用例图\n> 用例图是用来描述系统功能的技术，表示一个系统中用例与参与者及其关系的图。\n\n也就是说，用例图展示的是，**系统为不同参与者提供的不同（用例）的功能。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515132653252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n1. 参与者一般可以是系统内部的不同角色(**图中的管理员**）、或者也可以是系统外部的参与角色\n\n2. 一个用例是一个基本单元（**图中的个人信息管理、教师管理**等等）\n\n3. 用例与用例之间具备一些关系（比如**图中虚线表示的的包含关系**等等）\n\n\n","tags":["毕业答辩"],"categories":["毕业答辩"]},{"title":"毕业答辩_总体注意事项","url":"/2021/05/17/毕业答辩-总体注意事项/","content":"\n# 答辩需要注意的事情\n\n## 封面一定保持校正一致\n1. **大数据学院加上**\n\n2. **校外指导教师不能少**\n\n3. 日期已正确 勿修改\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515133239479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 摘要\n1. **研究什么东西（涉及到论文题目的解析）** \n\n2. 用的什么**技术（SpringMVC+Spring+Mybatis 凡是论文中出现的英文名 要知道是什么）** \n\n3. 关键词语：**要体现论文的题目 言简意赅 突出业务核心 不要冗余**\n\n## 英文摘要\n\n**检查单词之间是否有空格 首字母大写**\n\n## 目录\n一定要**删掉目录中的目录。**\n\n以及**英文摘要与绪论之间**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515110256221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n## 页眉\n\n记得**要带编号**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515133433501.png)\n\n\n## 绪论 | 前言\n**切记，不要内容太少了。要保证字数要有一页！！！**\n\n**技术介绍：**\n\t1. Tomcat（具体是干什么的？）\n\t2. Spring...（**常见的后台框架**，以及简单的运作原理）\n\t3. Ajax以及前端框架Bootstrap等等（**记得概念**）\n\n* 注意，**格式：如果要么是Mybatis就全文全部都是Mybatis！不要来个mybatis**\n\n## 系统分析\n1. 可行性（XX可行性分析等等）\n\n2.  功能分析（几个角色）\n\n3. 用例分析：（提供**用例图（执行人以及执行功能）**、增加**用例说明（业务逻辑）**）\n\n### 用例图\n* 要了解用例图的意义，以及其中的基本组成成分。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515132653252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**对用例图，要辅佐于一定的用例说明，否则无法根据业务进行代码编写。**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515132707184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n\n### 功能结构图\n**# 注意结构图，要条状清晰，整体对齐**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515111102553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n## 系统设计\n### 数据库设计\n#### 实体图\n**实体图不是E-R图**\n\n一般来说，**写了几个实体图，就要有对应的几个E-R图**。\n\n**每个字段要知道什么意思！**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515132854242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n\n#### E-R图\n注意，要搞清楚一对多的关系！（**检查数据库，表与表之间的关系。**）\n\n**要对应实体图！**\n\n一对多，一对一一般不做多的表，多对多要建立新的表。\n\n### 时序图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515133106187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n## 系统实现\n### 代码讲解\n要**注意找到对应的后台代码**\n\n**以登录举例：（如果老师问，就在对应的页面操作！）**\n\n1. 运行代码，按F12，调出控制台\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515134136702.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n\n2. 点击对应到后台action的事件，看看触发了什么请求方法名？\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515134249327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**login** 那么在对应后台的Controller中找这个方法！\n\n可以使用快捷键：`Ctrl + Shift + R` 全局搜索这个RequestMapping\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515134413767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n* 讲代码的时候，不要乱&按照逻辑来讲，尽量编写代码的时候（**见词生意**）\n\n==遇到不会的，那就点到为止==\n\n**尽量不要贴前端代码，代码不要贴太多，不要超过一页！**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515135042409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n## 系统测试\n**要了解常见的测试方法：黑盒测试，白盒测试。**\n\n最好附上，**系统测试表。**\n\n## 总结\n1. 具体开发个什么东西？\n2. 开发的过程中，用到什么工具？\n3. 开发过程中，遇到什么具体的问题？\n4. 未来维护中，怎么解决所遇到的问题？或者整体是否有更好的架构工具！？\n\n## 参考文献\n**姓名，参考来源，时间。**\n\n不要有其他的特殊符号，中间**一般只有逗号与点**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515135345263.png)\n注意，如果英文参考文献，单词之间间隔过大，可以通过以下办法调整：\n\n1. **选中这段英文参考文献**\n\n2. **右键段落**（Office 2010为例）\n\n3. 中文版式，中选择**允许西文在单词中间换行**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210515135810406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n## 致谢\n\n**检查，不要抄别人的致谢！**\n\n## 遗留重点\n1. 再次熟悉代码\n\n2. 熟悉常见的图（用例图，数据流图，E-R图等等以及其中的概念）\n\n3. 提前检查环境，**数据库+后台+前端页面**\n\n\n","tags":["毕业答辩"],"categories":["毕业答辩"]},{"title":"设计模式学习_观察者模式","url":"/2021/05/16/设计模式学习-观察者模式/","content":"\n# 观察者模式 Observer Pattern\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/_BpmfnqjgzQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n**这很好解释：气象监测总部WeatherStation与我们的手机APP PhoneDisplay之间的关系。**\n\n我们看天气的时候，数据都是依照*最新的数据变化而变化的，而变化的数据，来源于具体发送数据的仪器（比如天气传感器 Weather Sensor）*\n\n也就是说，我们可以利用这种模式，**来更好地在数据变化后，让所有显示器设备更新数据变化消息。**\n## 关键概念\n**1. 观察者模式定义了一种“一对多”的关系。**\n\n**2. 当这个关系中的“一”，数据发生变化时，其中所依赖的“多”将会自动地进行变化。**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210516212737914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**解释：**\n\n1. 这里ISubject与IObserver如何体现一对多关系？\n\n2. 为什么PhoneDisplay与TvDisplay要有WeatherStation呢？\n\n对于第一个问题，我们在每个ISubject中，附上一个`List<IObserver> observers`列表。\n\n对于第二个问题，回答是：我们的显示屏要显示数据变化，**而这些数据来源始终是WeatherStation。**\n\n因此，update函数其实要用到WeatherStation的数据。\n\n## 代码思路&实现：\n* 很简单，如果某一个时刻，WeatherStation中的数据（可以是成员变量）变化了，那么我们就执行notify()来通知List中的每一个Observer。\n\n接下来，我们用代码来实现：\n\n### 抽象接口层面：\n1. ISubject.java\n```java\npackage com.company.inter;\n\npublic interface ISubject {\n    void add(IObserver iObserver);\n    void remove(IObserver iObserver);\n    void notifyObserver();\n}\n\n```\n\n2. IObserver.java\n```java\npackage com.company.inter;\n\npublic interface IObserver {\n    void update();\n}\n```\n\n### 具体实现层面\n1. WeatherStation\n```java\npackage com.company.entity;\n\nimport com.company.inter.IObserver;\nimport com.company.inter.ISubject;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class WeatherStation implements ISubject {\n\n    //被注册进来的所有观察者\n    List<IObserver> observers = new ArrayList<>();\n\n    //温度变量 当温度变量发生变化时 通知所有观察者\n    Integer temperature = 18;\n\n    //将观察者注册进来 其中就是用list add进来\n    @Override\n    public void add(IObserver iObserver) {\n        this.observers.add(iObserver);\n    }\n\n    @Override\n    public void remove(IObserver iObserver) {\n        observers.remove(iObserver);\n    }\n\n    //在温度变量发生变化后 每一个观察者通过update方法来得到最新数据\n    @Override\n    public void notifyObserver() {\n        //通知每一个观察者\n        for(IObserver iObserver: this.observers){\n            iObserver.update();\n        }\n    }\n\n    public Integer getTemperature(){\n        return this.temperature;\n    }\n\t\n\t//模拟实现数据变化\n    public void setTemperature(Integer temperature){\n        this.temperature = temperature;\n    }\n}\n```\n\n2. PhoneDisplay.java\n```java\npackage com.company.entity;\n\nimport com.company.inter.IObserver;\n\npublic class PhoneDisplay implements IObserver{\n\n    WeatherStation weatherStation; \n\n    //我们需要得到变化后的数据信息 因此需要通过构造方法 <绑定> 一个被观察者\n    public PhoneDisplay(WeatherStation weatherStation){\n        this.weatherStation = weatherStation;\n    }\n\n    //通过这个被观察者的public get方法 我们才可以知道最新的数据信息\n    @Override\n    public void update() {\n        System.out.println(\"数据发生变化，最新温度为:\" + \n        this.weatherStation.getTemperature());\n    }\n}\n```\n\n3. TvDisplay.java\n```java\npackage com.company.entity;\n\nimport com.company.inter.IObserver;\n\npublic class TvDisplay implements IObserver{\n\n    WeatherStation weatherStation;\n\n    //我们需要得到变化后的数据信息 因此需要通过构造方法 <绑定> 一个被观察者\n    public TvDisplay(WeatherStation weatherStation){\n        this.weatherStation = weatherStation;\n    }\n\n    //通过这个被观察者的public get方法 我们才可以知道最新的数据信息\n    @Override\n    public void update() {\n        System.out.println(\"数据发生变化，最新温度为:\" +\n         this.weatherStation.getTemperature());\n    }\n}\n```\n\n### 主函数：\n```java\npackage com.company;\n\nimport com.company.entity.PhoneDisplay;\nimport com.company.entity.TvDisplay;\nimport com.company.entity.WeatherStation;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        WeatherStation weatherStation = new WeatherStation();\n        \n        //手机显示器实时绑定天气预报站台\n        PhoneDisplay phoneDisplay = new PhoneDisplay(weatherStation);\n        //电视机显示器实时绑定天气预报站台\n        TvDisplay tvDisplay = new TvDisplay(weatherStation);\n        \n\t\t//天气预报站台将手机显示器注册进来\n        weatherStation.add(phoneDisplay); \n        //天气预报站台将电视机显示器注册进来\n        weatherStation.add(tvDisplay); \n\n        System.out.println(\"天气正常，一直都是：\" + \n        String.valueOf(weatherStation.getTemperature()) + \"摄氏度.\");\n\n\n        System.out.println(\"某一时刻，数据突然发生变化...\");\n        weatherStation.setTemperature(-20);\n\n        System.out.println(\"天气预报站台准备广播消息！Broadcasting...\");\n\n        weatherStation.notifyObserver();\n\n        System.out.print(\"手机显示器这边显示：\");\n        phoneDisplay.update();\n\n        System.out.print(\"电视机显示器这边显示：\");\n        tvDisplay.update();\n    }\n}\n\n```\n\n### 效果图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210517091903993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n","tags":["设计模式"],"categories":["设计模式"]},{"title":"设计模式学习_策略模式","url":"/2021/05/15/设计模式学习-策略模式/","content":"\n# 策略者模式 Strategy Pattern\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/v9ejT8FO-7I\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n## 使用背景\n* 定义： 我们将算法Algorithm与使用者Client分离，让这些使用者自由地选择策略。\n\n想象这样一个场景：\n\n**有一个基类Duck，它具有两个方法：void eat() 与 void fly()**\n\n**eat代表吃 fly代表飞行**\n\n**现在有两个subclass 子类：WildDuck 与 CityDuck**\n\n1. 它们在eat的行为上一摸一样\n\n2. 它们在fly的行为上不一样\n\n试想，如果我们用Java来实现：\n\n整个UML图可能是这样：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210516095210685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**其中，- 代表这是一个私有方法，且void代表它无返回值。**\n\n*前面，我们提到：这两种鸭子的eat行为是一样的，而fly的行为不一样。*\n\n那么，在这种**单重继承**的情况下，如果eat行为一样，我们只能**重复的复制粘贴代码。**\n\n* 想象一下，当子类的数目在需求增大的过程中越来越多？这样的代码不具有高重用性与可维护性。\n\n## 使用策略者模式解决问题\n\n1. 在上述问题中，eat与fly可以代表两种算法或者策略\n\n2. 使用者就是WildDuck以及CityDuck\n\n我们希望对于不同的使用者，可以任意使用策略。\n\n### 解决方案：\n\n**我们将同一种策略，封装成接口Interface，然后采用不同的实现策略（即不同的实现类）**\n\n同时，将这些接口，注入到我们的使用者中。\n\n使用具体的方法时，我们使用**这些使用者的所注入进来的实现类的具体方法。**\n\n直接上UML图：（图不规范，见谅。）\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210516100613284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n从这个图中，我们可以看到：\n\n1. Duck类具有两个接口:IEatBehavior与IFlyBehavior\n\n2. 每个接口都有若干个实现类（策略）\n\n3. 当子类WildDuck与CityDuck继承Duck时，具有父类的所有资源。\n\n* 那么如何用代码实现呢？\n\n### 代码实现：\n\n1. 首先，我们要有一个基类 Duck.java以及它的子类 WildDuck.java与CityDuck.java\n```java\npackage com.company.entity;\n\nimport com.company.inter.IEatBehavior;\nimport com.company.inter.IFlyBehavior;\n\npublic class Duck {\n    IEatBehavior iEatBehavior;\n\n    IFlyBehavior iFlyBehavior;\n\n    public Duck(IEatBehavior iEatBehavior, IFlyBehavior iFlyBehavior) {\n        this.iEatBehavior = iEatBehavior;\n        this.iFlyBehavior = iFlyBehavior;\n    }\n\n    public void eat(){\n        this.iEatBehavior.eat();\n    }\n\n    public void fly(){\n        this.iFlyBehavior.fly();\n    }\n\n}\n```\n**可以看到，这里有两个接口，分别代表两种策略（Eat与Fly）**\n\n**# WildDuck.java**\n```java\npackage com.company.entity;\n\nimport com.company.inter.IEatBehavior;\nimport com.company.inter.IFlyBehavior;\n\npublic class WildDuck extends Duck{\n    public WildDuck(IEatBehavior iEatBehavior, IFlyBehavior iFlyBehavior) {\n        super(iEatBehavior, iFlyBehavior);\n    }\n}\n\n```\n\n**# CityDuck.java**\n```java\npackage com.company.entity;\n\nimport com.company.inter.IEatBehavior;\nimport com.company.inter.IFlyBehavior;\n\npublic class CityDuck extends Duck{\n    public CityDuck(IEatBehavior iEatBehavior, IFlyBehavior iFlyBehavior) {\n        super(iEatBehavior, iFlyBehavior);\n    }\n}\n\n```\n\n2. 定义两种接口\n\n**# iEatBehavior.java**\n```java\npackage com.company.inter;\n\npublic interface IEatBehavior {\n    public void eat();\n}\n\n```\n\n**# iFlyBehavior.java**\n```java\npackage com.company.inter;\n\npublic interface IFlyBehavior {\n    public void fly();\n}\n\n```\n\n3. 定义这些接口的不同策略实现类\n\n**# SimpleEatBehaviorImpl.java**\n```java\npackage com.company.impl;\n\nimport com.company.inter.IEatBehavior;\n\npublic class SimpleEatBehaviorImpl implements IEatBehavior {\n    @Override\n    public void eat() {\n        System.out.println(\"吃：采用正常吃饭的策略！\");\n    }\n}\n```\n\n**# SimpleFlyBehaviorImpl.java**\n```java\npackage com.company.impl;\n\nimport com.company.inter.IFlyBehavior;\n\npublic class SimpleFlyBehaviorImpl implements IFlyBehavior {\n\n    @Override\n    public void fly() {\n        System.out.println(\"飞：采用正常飞的策略！\");\n    }\n}\n\n```\n\n**# JetFlyBehaviorImpl.java**\n```java\npackage com.company.impl;\n\nimport com.company.inter.IFlyBehavior;\n\npublic class JetFlyBehaviorImpl implements IFlyBehavior {\n\n    @Override\n    public void fly() {\n        System.out.println(\"飞：采用喷气式飞行的策略！\");\n    }\n}\n\n```\n\n* 那么目前为止，我们已经将这些策略与使用者分离了。\n\n使用的时候，我们只需要让他们使用不同的策略即可。\n\n**# Main.java**\n```java\npackage com.company;\n\nimport com.company.entity.CityDuck;\nimport com.company.entity.WildDuck;\nimport com.company.impl.JetFlyBehaviorImpl;\nimport com.company.impl.SimpleEatBehaviorImpl;\nimport com.company.impl.SimpleFlyBehaviorImpl;\nimport com.company.inter.IEatBehavior;\nimport com.company.inter.IFlyBehavior;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        //对于城市Duck来说 Eat采用的是simpleEat策略 Fly也采用的是simpleFly策略\n        IEatBehavior iSimpleEatBehavior = new SimpleEatBehaviorImpl();\n        IFlyBehavior iSimpleFlyBehavior = new SimpleFlyBehaviorImpl();\n        CityDuck cityDuck = new CityDuck(iSimpleEatBehavior, iSimpleFlyBehavior);\n        System.out.println(\"城市鸭子采用的策略：\");\n        cityDuck.eat();\n        cityDuck.fly();\n\n        //对于城市Duck来说 Eat采用的是simpleEat策略（直接重用） Fly采用的是jetFly策略\n        IFlyBehavior iJetFlyBehavior = new JetFlyBehaviorImpl();\n        WildDuck wildDuck = new WildDuck(iSimpleEatBehavior, iJetFlyBehavior);\n        System.out.println(\"接下来是野鸭子采用的策略：\");\n        wildDuck.eat();\n        wildDuck.fly();\n\n    }\n}\n\n```\n\n**效果图：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210516102112668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n\n\n","tags":["设计模式"],"categories":["设计模式"]},{"title":"Hexo学习笔记以及常见错误","url":"/2021/05/07/hexo学习笔记以及常见错误/","content":"\n\n# 前提，注意！\n**在进行任何更改后，务必进行以下代码：**\n\n```java\n//在本地看到效果，而不部署git\nhexo clean & hexo s\n\n//想在git上（比如码云或者github）看到效果\nhexo clean & hexo g & hexo d\n```\n\n**在输入hexo g后 才会生成public目录**\n\n\n# 引入别人的主题若启动时报以下错误\n\n**extends includes/layout.pug block content include includes/recent-posts.pug include includes/partial**\n\n则在博客根路径中，键入以下代码：\n```js\nnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\n```\n\n<mark> 在使用别人的主题过程中，一定要去看别人发布的关于这个主题的使用文档！ </mark>\n\n<mark>看文档！</mark>\n\n<mark>看文档！</mark>\n\n<mark>看文档！</mark>\n\n# 博客中的文章字数统计插件\n```js\nnpm install hexo-wordcount --save\n```\n然后在主题中的配置文件中打开wordcount:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210507104215942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n# 博客中的本地搜索插件\n```js\nnpm install hexo-generator-json-content --save\n```\n1. 在blog根目录中的`config.yml`中，键入代码：\n\t```yml\n\t# 本地搜索\n\tsearch:\n\t  path: search.json\n\t  field: post\n\t  content: true\n\t```\n2. 在自己的主题目录下的`config.yml`中打开本地搜索，键入代码：\n\t```yml\n\tlocal_search:\n   \t\t# 是否启用\n   \t\tenable: true\n\t```\n# 博客中的Valine评论（前提是上传到Gitee或者GitHub）\n\n1. 首先在主题中的`config.yml`中 找到对应Valine的区域enable相应的Valine插件\n\t```yml\n\t# Valine\n\t# See: https://valine.js.org/quickstart.html\n\tvaline:\n\t  enable: true\n\t  # Your leancloud application appid.\n\t  appid: LeanCloud上创建的appid\n\t  # Your leancloud application appkey.\n\t  appkey: LeanCloud上创建的appkey\t  \n\t  # Mail notifier.\n\t  notify: true\n\t  # Verification code.\n\t  verify: true\n\t  # Comment box placeholder.\n\t  placeholder: 说点啥再走呗~爱你\n\t  # Gravatar style.\n\t  avatar: mp\n\t  # Custom comment header.\n\t  meta: nick,email\n\t  # Pagination size.\n\t  pageSize: 10\n\t  # Article reading statistics.\n\t  visitor: false\n\t  # Whether to record the commenter IP.\n\t  recordIP: false\n\t  # Optional values: en | zh-cn\n\t  language:\n\t```\n2. 去**LeanCloud上注册相关应用并打开你的白名单域名**（设置，安全中心）https://vincent990413.gitee.io/myblog/根目录，比如：`https://vincent990413.gitee.io/myblog/`\n\n3. 写完博客，成功**部署到这个白名单页面**即可。\n\n# 部署到Gitee过程以及会出现的错误\n\n1. Gitee创建项目 并获得Git拉取地址(....xxx.git)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210507110157389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n```java\n\thttps://gitee.com/vincent990413/myblog.git\n```\n\n2. 在博客根目录配置文件中指定提交的git地址\n```yml\ndeploy:\n  type: git\n  # 这个是克隆项目时的地址！\n  repo: https://gitee.com/vincent990413/myblog.git\n  branch: master\n```\n\n3. 在博客根目录配置文件中引入资源根地址\n```yml\n# URL\n## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'\nurl: https://vincent990413.gitee.io/myblog\nroot: /myblog/\n```\n\n# 部署项目时出现403 have no permission错误\n[点我看解决方案（转）](https://blog.csdn.net/zy_crazy_code/article/details/111227472)\n\n# 部署项目到github&gitee上\n如果出现Can't access... 就是网络问题，重复部署即可。\n\n\n# 部署到Github\n只需要改动博客根目录下的配置文件即可（前提是主题中的配置文件等导航栏、静态图片引入正确）：\n\n```yml\n# 访问项目的URL\n## Set your site url here. For example, if you use GitHub Page, \n## set url as 'https://username.github.io/project'\nurl: https://vincent990413.github.io/\n\n# 部署项目的git地址\ndeploy:\n  type: git\n  # 这个是克隆项目时的地址！\n  repo: https://github.com/vincent990413/vincent990413.github.io.git\n  branch: master\n```\n\n注意：当部署到Gitee码云时，如果页面的静态资源文件无法正常显示，很有可能时引用问题。\n\n比如:\n如果引入某个照片，如果是部署到Github下，键入代码：\n```js\n\turl: /images/myPhoto.jpg\n```\n\n如果是引入到Gitee中，键入代码：\n```js\n\turl: /本页上方关于部署到Gitee git地址末尾的二级目录/images/myPhoto.jpg\n\turl: /myblog/images/myPhoto.jpg\n```\n\n而且，需要将静态资源文件，放在根目录以及主题目录的两个source目录下（都要放）。\n","tags":["Hexo 学习笔记"],"categories":["Hexo 学习笔记"]},{"title":"英语学习_16个代替very的表达","url":"/2021/05/07/英语学习-16个代替very的表达/","content":"\n# Get rid of \"Very X\"\n## 16个代替very + adj 的表达\n| 普通表达 | 进阶表达 |\n|--|--|\n| Very beautiful | Charming, Gorgeous, Stunning |\n| Very tired | Exhausted, Completely exhausted |\n| Very sad | Heart-broken, Devastated |\n| Very happy | Delighted, Thrilled, Be on cloud nine |\n| Very surprise | Amazed, Astonished |\n| Very small | Tiny, Minuscale |\n| Very big | Huge, Massive, Giant, Tremendous,  Humongous |\n| Very bad | Horrible, Terrible, Awful, Horrendous |\n| Very diffcult | Challenging, Demanding |\n| Very simple | A piece of cake, Staightforward |\n| Very smart | Witty, Brilliant, Intelligent |\n| Very important | Crucial, Vital, Essential |\n| Very interesting | Fascinating, Captivating |\n| Very hungry | Starving, Famished |\n| Very angry | Mad, Pissed of, Furious | \n\n\n","tags":["英语学习"],"categories":["英语学习"]},{"title":"基于VUE&Firebase的在线聊天室APP","url":"/2021/05/04/基于VUE-Firebase在线聊天室APP/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# 前言\n**这一期我们准备做一个基于VUE3.0 Composition API与FireBase的在线聊天室**\n\n**用户登陆到我们的在线聊天室进行聊天**\n\n# 前期准备\n**命令行中利用vue-cli创建vue3.0项目**\n```js\nvue create test \n//test是项目名\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504093916655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**选择手动添加Manually select features**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504094100562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**选择上述勾选项**\n\n**接下来，选择3.x（preview）因为要用到VUE的composition API**\n\n**选择with node-sass，如下图所示：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021050409425939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**然后一直enter即可，直到出现package.json，如图所示：**\n\n**选择In package.json**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504094426971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**出现preset选项，选择否 not save**\n\n**然后经过漫长的等待...**\n\n**如果一切顺利，那么会出现下图所示：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504094640180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n```js\nSuccessfully created project test.\nGet started with the following commands:\n\n$ cd test\n$ npm run serve\n```\n\n**cd 切换到这个新项目的工作目录。**\n\n**这个时候我们要安装Firebase数据库用于聊天室中所有消息的存储**\n\n* 注意，Firebase由Google创建并持续维护，安装前请科学上网 ✈ ️\n\n```js\nnpm i firebase\n```\n\n**目前为止，我们的前期工作就已经做好了！**\n\n然后利用VS Code或者IDEA等编译器导入这个VUE项目即可\n\n# 配置项目的数据库Firebase\n\n**首先，我们需要修改一个配置信息**\n\n打开`package.json` 在\"rules\"中添加：\n\n```js\n\"no-unused-vars\": \"off\"\n```\n\n**因为在做一些初始配置，所以演示的时候，可能会因为定义了未被使用的变量而报错。**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504095902400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## Src 目录下创建db.js firebase配置数据库信息\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504100207129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**进入db.js**\n\n输入以下备用代码：\n\n```js\nimport firebase from \"firebase/app\";\nimport \"firebase/database\";\n\nconst config = {\n    //API KEYS\n    \n}\n\nconst db = firebase.initializeApp(config)\n\nexport default db;\n```\n\n**这里注意到，我们的config中还没有配置我们firebase的接口信息（包括你这个应用的KEY、用户KEYS、项目ID等等）**\n\n**因此，接下来我们要去firebase的官网配置：**\n\n1. 点击右上角的转到控制台\n\n2. 点击添加项目并输入项目名称\n\n3. 取消勾选“为此项目启动 Google Analytics分析”\n\n4. 等待正在创建项目...\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504100443748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504100648267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n5. 点击对应的项目名，顺利的话，会进入以下画面：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504100842673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n6. 添加网页端应用，并获取到应用接口信息\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504101140579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n7. 输入我们的应用别名，注册应用后，可以获得Firebase SDK （下图所示）\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504101315653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**由于我们已经在项目中 预先安装了firebase 那么就不用最上面的JS引入语句了**\n\n**JS文件内容如下：**\n\n```js\n<script>\n  // Your web app's Firebase configuration\n  var firebaseConfig = {\n    apiKey: \"AIzaSyAgKkSD7cherkQylfbmrr_cCb6awLk9ynk\",\n    authDomain: \"test-dc7e4.firebaseapp.com\",\n    projectId: \"test-dc7e4\",\n    storageBucket: \"test-dc7e4.appspot.com\",\n    messagingSenderId: \"594878054873\",\n    appId: \"1:594878054873:web:9d533554407419fe7259c8\"\n  };\n  // Initialize Firebase\n  firebase.initializeApp(firebaseConfig);\n</script>\n```\n\n**我们需要将firebaseConfig中的内容粘贴到，我们的db.js中去：**\n\n**我的配置信息如下图所示：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504101612983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n8. 配置实时数据库 RealTime Database \n\n**这一步，是为了查看聊天室中的实时存储的消息。**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504200221560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n导航栏左侧的Realtime Database实时数据库 一步步创建即可\n\n* 记得数据库位置需要选择美国 US 🇺🇸\n\n**那么，到目前为止，数据库配置信息完成了。**\n\n# 进入项目\n## 页面的样式添加\n\n**进入初始话的文件，我们将没用的初始文件都删掉：component以及assets中的内容**\n\n进入APP.vue中，写好初始页面：\n\n```html\n<template>\n\n</template>\n\n<script>\n\texport default{\n\t\tsetup(){\n\t\t\t\n\t\t\treturn{\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n<style lang=\"scss\">\n\n</style>\n```\n\n**我们可以发现，与VUE2.0不同的是，我们使用setup来配置初始化信息，并且在初始化之后，return这些信息，让前端页面任何地方可以引用这些数据（比如用于v-model)。**\n\n接下来，将以下样式贴到style中：\n\n```css\n* {\n\tfont-family: Avenir, Helvetica, Arial, sans-serif;\n\t-webkit-font-smoothing: antialiased;\n\t-moz-osx-font-smoothing: grayscale;\n\tmargin: 0;\n\tpadding: 0;\n\tbox-sizing: border-box;\n}\n.view {\n\tdisplay: flex;\n\tjustify-content: center;\n\tmin-height: 100vh;\n\tbackground-color: #ea526f;\n\t\n\t&.login {\n\t\talign-items: center;\n\t\t.login-form {\n\t\t\tdisplay: block;\n\t\t\twidth: 100%;\n\t\t\tpadding: 15px;\n\t\t\t\n\t\t\t.form-inner {\n\t\t\t\tdisplay: block;\n\t\t\t\tbackground-color: #FFF;\n\t\t\t\tpadding: 50px 15px;\n\t\t\t\tborder-radius: 16px;\n\t\t\t\tbox-shadow: 0px 6px 12px rgba(0, 0, 0, 0.2);\n\t\t\t\th1 {\n\t\t\t\t\tcolor: #AAA;\n\t\t\t\t\tfont-size: 28px;\n\t\t\t\t\tmargin-bottom: 30px;\n\t\t\t\t}\n\t\t\t\tlabel {\n\t\t\t\t\tdisplay: block;\n\t\t\t\t\tmargin-bottom: 5px;\n\t\t\t\t\tcolor: #AAA;\n\t\t\t\t\tfont-size: 16px;\n\t\t\t\t\ttransition: 0.4s;\n\t\t\t\t}\n\t\t\t\tinput[type=\"text\"] {\n\t\t\t\t\tappearance: none;\n\t\t\t\t\tborder: none;\n\t\t\t\t\toutline: none;\n\t\t\t\t\tbackground: none;\n\t\t\t\t\tdisplay: block;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tpadding: 10px 15px;\n\t\t\t\t\tborder-radius: 8px;\n\t\t\t\t\tmargin-bottom: 15px;\n\t\t\t\t\t\n\t\t\t\t\tcolor: #333;\n\t\t\t\t\tfont-size: 18px;\n\t\t\t\t\tbox-shadow: 0px 0px 0px rgba(0, 0, 0, 0);\n\t\t\t\t\tbackground-color: #F3F3F3;\n\t\t\t\t\ttransition: 0.4s;\n\t\t\t\t\t&::placeholder {\n\t\t\t\t\t\tcolor: #888;\n\t\t\t\t\t\ttransition: 0.4s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinput[type=\"submit\"] {\n\t\t\t\t\tappearance: none;\n\t\t\t\t\tborder: none;\n\t\t\t\t\toutline: none;\n\t\t\t\t\tbackground: none;\n\t\t\t\t\tdisplay: block;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tpadding: 10px 15px;\n\t\t\t\t\tbackground-color: #ea526f;\n\t\t\t\t\tborder-radius: 8px;\n\t\t\t\t\tcolor: #FFF;\n\t\t\t\t\tfont-size: 18px;\n\t\t\t\t\tfont-weight: 700;\n\t\t\t\t}\n\t\t\t\t&:focus-within {\n\t\t\t\t\tlabel {\n\t\t\t\t\t\tcolor: #ea526f;\n\t\t\t\t\t}\n\t\t\t\t\tinput[type=\"text\"] {\n\t\t\t\t\t\tbackground-color: #FFF;\n\t\t\t\t\t\tbox-shadow: 0 0 6px rgba(0, 0, 0, 0.2);\n\t\t\t\t\t\t&::placeholder {\n\t\t\t\t\t\t\tcolor: #666;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t&.chat {\n\t\tflex-direction: column;\n\t\theader {\n\t\t\tposition: relative;\n\t\t\tdisplay: block;\n\t\t\twidth: 100%;\n\t\t\tpadding: 50px 30px 10px;\n\t\t\t.logout {\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: 15px;\n\t\t\t\tright: 15px;\n\t\t\t\tappearance: none;\n\t\t\t\tborder: none;\n\t\t\t\toutline: none;\n\t\t\t\tbackground: none;\n\t\t\t\t\n\t\t\t\tcolor: #FFF;\n\t\t\t\tfont-size: 18px;\n\t\t\t\tmargin-bottom: 10px;\n\t\t\t\ttext-align: right;\n\t\t\t}\n\t\t\th1 {\n\t\t\t\tcolor: #FFF;\n\t\t\t}\n\t\t}\n\t\t.chat-box {\n\t\t\tborder-radius: 24px 24px 0px 0px;\n\t\t\tbackground-color: #FFF;\n\t\t\tbox-shadow: 0px 0px 12px rgba(100, 100, 100, 0.2);\n\t\t\tflex: 1 1 100%;\n\t\t\tpadding: 30px;\n\t\t\t.message {\n\t\t\t\tdisplay: flex;\n\t\t\t\tmargin-bottom: 15px;\n\t\t\t\t\n\t\t\t\t.message-inner {\n\t\t\t\t\t.username {\n\t\t\t\t\t\tcolor: #888;\n\t\t\t\t\t\tfont-size: 16px;\n\t\t\t\t\t\tmargin-bottom: 5px;\n\t\t\t\t\t\tpadding-left: 15px;\n\t\t\t\t\t\tpadding-right: 15px;\n\t\t\t\t\t}\n\t\t\t\t\t.content {\n\t\t\t\t\t\tdisplay: inline-block;\n\t\t\t\t\t\tpadding: 10px 20px;\n\t\t\t\t\t\tbackground-color: #F3F3F3;\n\t\t\t\t\t\tborder-radius: 999px;\n\t\t\t\t\t\tcolor: #333;\n\t\t\t\t\t\tfont-size: 18px;\n\t\t\t\t\t\tline-height: 1.2em;\n\t\t\t\t\t\ttext-align: left;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t&.current-user {\n\t\t\t\t\tmargin-top: 30px;\n\t\t\t\t\tjustify-content: flex-end;\n\t\t\t\t\ttext-align: right;\n\t\t\t\t\t.message-inner {\n\t\t\t\t\t\tmax-width: 75%;\n\t\t\t\t\t\t.content {\n\t\t\t\t\t\t\tcolor: #FFF;\n\t\t\t\t\t\t\tfont-weight: 600;\n\t\t\t\t\t\t\tbackground-color: #ea526f;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfooter {\n\t\t\tposition: sticky;\n\t\t\tbottom: 0px;\n\t\t\tbackground-color: #FFF;\n\t\t\tpadding: 30px;\n\t\t\tbox-shadow: 0px 0px 12px rgba(100, 100, 100, 0.2);\n\t\t\tform {\n\t\t\t\tdisplay: flex;\n\t\t\t\tinput[type=\"text\"] {\n\t\t\t\t\tflex: 1 1 100%;\n\t\t\t\t\tappearance: none;\n\t\t\t\t\tborder: none;\n\t\t\t\t\toutline: none;\n\t\t\t\t\tbackground: none;\n\t\t\t\t\tdisplay: block;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tpadding: 10px 15px;\n\t\t\t\t\tborder-radius: 8px 0px 0px 8px;\n\t\t\t\t\t\n\t\t\t\t\tcolor: #333;\n\t\t\t\t\tfont-size: 18px;\n\t\t\t\t\tbox-shadow: 0px 0px 0px rgba(0, 0, 0, 0);\n\t\t\t\t\tbackground-color: #F3F3F3;\n\t\t\t\t\ttransition: 0.4s;\n\t\t\t\t\t&::placeholder {\n\t\t\t\t\t\tcolor: #888;\n\t\t\t\t\t\ttransition: 0.4s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinput[type=\"submit\"] {\n\t\t\t\t\tappearance: none;\n\t\t\t\t\tborder: none;\n\t\t\t\t\toutline: none;\n\t\t\t\t\tbackground: none;\n\t\t\t\t\tdisplay: block;\n\t\t\t\t\tpadding: 10px 15px;\n\t\t\t\t\tborder-radius: 0px 8px 8px 0px;\n\t\t\t\t\tbackground-color: #ea526f;\n\t\t\t\t\tcolor: #FFF;\n\t\t\t\t\tfont-size: 18px;\n\t\t\t\t\tfont-weight: 700;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n## 登陆模块\n* 定义默认提交进入的方法 @submit.prevent=\"Login\" 绑定事件\n\n* 定义登陆时，输入框中输入的信息所绑定的变量(导入vue的ref) const inputUsername = ref(\"\");\n\n* 登录时，将输入框中的值对应的信息保存数据库中，否则下次登陆系统后，以前的信息（包括用户名与消息）都不会保存起来(导入vue的reactive响应变动)\n\n1. JS中的setup中配置相应的变量与方法（记得返回这些数据让页面显示可以使用）\n\n```js\nimport { reactive, onMounted, ref } from 'vue';\nimport db from './db';\n\nexport default{\n\tsetup () {\n\t\t//定义输入框输入绑定的变量 以及 保存用户信息的state变量\n\t\tconst inputUsername = ref(\"\"); //初始化为空 相当于vue2.0的 inputUsername: ''\n\t\tconst state = reactive({ //用户发的信息 后面会用到\n\t\t\tusername: \"\",\n\t\t\tmessages: [] \n\t\t});\n\t\t\n\t\t//定义表单提交绑定的方法\n\t\tconst Login = () => {\n\t\t\t//与vue2.0不同的是 我们不再用this.val\n\t\t\t//检测到用户输入信息 就存储用户登陆信息\n\t\t\tif(inputUsername.value != \"\" || inputUsername.value != null){\n\t\t\t\tstate.username = inputUsername.value;\n\t\t\t\tinputUsername.value = \"\";\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn{\n\t\t\tinputUsername,\n\t\t\tLogin,\n\t\t\tstate\n\t\t}\n\t}\n}\n```\n2. 页面显示\n\n```html\n<template>\n  <div class=\"view login\" v-if=\"state.username === '' || state.username === null\">\n    <form class=\"login-form\" @submit.prevent=\"Login\">\n      <div class=\"form-inner\">\n        <h1>Login to FireChat</h1>\n        <label for=\"username\">Username</label>\n        <input \n          type=\"text\" \n          v-model=\"inputUsername\" \n          placeholder=\"Please enter your username...\" />\n        <input \n          type=\"submit\" \n          value=\"Login\" />\n      </div>\n    </form>\n  </div>\n  \n  <div class=\"view chat\" v-else>\n\t<h1> 这是聊天室显示区域 </h1>\n  </div>\n  \n</template>\n```\n\n**用户界面效果图，如下图所示：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504194806246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**可以看到，我们使用了v-if进行判断**\n\n**如果存储在state中的用户名信息不为空（即表示用户填入了信息想进入聊天室）**\n\n**则显示这是聊天室显示区域 否则会显示登陆区域让用户进行登陆(由于是在线聊天室，不设置密码)**\n\n3. 从聊天室中注销出来\n\n**刚才我们模拟进入了聊天室，现在我们添加注销功能**\n\n```html\n<div class=\"view chat\" v-else>\n\t<header>\n      <button class=\"logout\" @click=\"Logout\">Logout</button>\n      <h1>Welcome, {{ state.username }}</h1>\n    </header>\n  </div>\n```\n\n**前端页面写好了，补充JS中的Logout方法，还是写在setup中**\n\n```js\nconst Logout = () => {\n\tstate.username = \"\";\n}\n\n//别忘了return 让前端页面调用\nreturn{\n\t...Login,\n\tstate,\n\tLogout \n}\n```\n\n**前面提到了，当state中的username为空或者为null时，会显示登陆区域。**\n\n4. 为聊天室添加（发送消息，查看消息功能）\n\n**这是最后一个步骤了，也是需要用到firebase（特别是我们刚才配置的实时数据库）的一步**\n\n首先在刚才注销区域`<header>`标签 的下方，加入代码：\n\n```html\n<section class=\"chat-box\">\n  <div \n\tv-for=\"message in state.messages\" \n\t:key=\"message.key\" \n\t:class=\"(message.username == state.username ? 'message current-user' : 'message')\">\n\t<div class=\"message-inner\">\n\t  <div class=\"username\">{{ message.username }}</div>\n\t  <div class=\"content\">{{ message.content }}</div>\n\t</div>\n  </div>\n</section>\n\n<footer>\n  <form @submit.prevent=\"SendMessage\">\n\t<input \n\t  type=\"text\" \n\t  v-model=\"inputMessage\" \n\t  placeholder=\"Write a message...\" />\n\t<input \n\t  type=\"submit\" \n\t  value=\"Send\" />\n  </form>\n</footer>\n```\n\n*可以看到，我们用到了SendMessage方法用来发送数据*\n\n* 用到了state中的messages并且将当前用户的前端样式区别于其他用户\n\n* 并且从messages中取出所有消息 利用v-for在前端中显示\n\n* 输入的消息绑定v-model inputMessage\n\n<mark>那么，下面就可以定义消息变量以及相应发送消息的函数！</mark>\n\n**还是写在setup中 并注意return给前端使用**\n\n```js\n\t//const inputUsername = ref(\"\");\n\tconst inputMessage = ref(\"\");\n\t\n\tconst SendMessage = () => {\n\t\tconst messagesRef = db.database().ref(\"messages\"); //firebase数据库\n\t\tif(inputMessage.value === \"\" || inputMessage.value === value){ //用户不能发送空消息\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tconst message = { //准备将发送的消息存储至数据库中\n\t\t\tusername: stae.username,\n\t\t\tcontent: inputMessage.value\n\t\t}\n\t\tmessageRef.push(message); //相当于MySQL中的insert firebase是基于JSON的 故用push\n\t\tinputMessage.value = \"\";\n\t}\n```\n\n**那么，到目前位置，我们写入数据库的操作就写完了。**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504201725607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n* 但是现在是无法实时看到，任何用户发送的消息的，为什么？\n\n* 因为，我们虽然存储到了firebase数据库中去，但是我们每次v-for取出的数据，是从state中取出的\n\n**因此，下一步我们需要，在进入聊天室时，将数据库中的数据赋给state**\n\n5. firebase检索数据(写在onMounted钩子函数中)\n\n```js\nonMounted(() => {\n  const messagesRef = db.database().ref(\"messages\"); //选择数据库\n  messagesRef.on('value', snapshot => { //on 用于firebase数据库检索数据\n\tconst data = snapshot.val();\n\tlet messages = [];\n\tObject.keys(data).forEach(key => {\n\t  messages.push({\n\t\tid: key,\n\t\tusername: data[key].username,\n\t\tcontent: data[key].content\n\t  });\n\t});\n\tstate.messages = messages;\n  });\n});\n```\n\n**其中，data是我们从数据库中查询到的所有数据。**\n\n**如果我们试着打印以下内容，你会发现：**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210504202829214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n*因为，Firebase中存储的信息都是JSON对象，那么，我们就要用相应的方法来遍历每个对象，并将所有对象存储在messages中*\n\n**最后将messages的内容，赋给我们的state 好让我们的v-for循环遍历数据可以生效！**\n\n**并且值得注意的是，每次有新的内容添加至数据库时（即每次发送消息时）**\n\n* 这个messagesRef.on('value', ...) 都会被调用一次，我们可以看成是事件监听（每当有新的数据时，会被调用！)\n\n# 文末总结\n\nP.S. 该文所有的代码以及教程均来自YT博主（非自己原创）只不过自己以文字思路的形式写成笔记而已\n\n1. [点我查看源码地址](https://github.com/TylerPottsDev/FireChat-Vue)\n\n2. [点我查看视频教学](https://www.youtube.com/watch?v=72Fk9i9HcZM&t=197s)\n\n**如果哪里有写的不对的地方，多多包涵，请于文章下方的评论区告知，谢谢！**\n","tags":["前端项目"],"categories":["前端项目"]},{"title":"VUE2.0学习笔记-基础语法及其应用-2-深入组件开发","url":"/2021/04/27/VUE学习笔记-基础语法及相应应用-2/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n[（转）本文笔记&源码地址_JS胖](http://www.jspang.com/detailed?id=69)\n\n# 了解组件，什么是组件概念？\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210427202040534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n从图中我们可以看到，总共的**大区域分为了三个板块**\n\n**上面一个Header，下面左边一个LeftSide以及右边的RightSide**\n\n根据每个区域，又可以分为两个（最下层的绿色中间）、以及三个（最下层的绿色右边）\n\n## 组件定义：\n\n**所谓组件，我们就可以看成是：一个页面中的某一个Section，通过不同的组件共同拼凑**\n\n从而，形成一个完整的组件，这也是目前前端最流行的开发方式：\n\n**vue_component.html**\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <script src=\"https://unpkg.com/vue@next\"></script>\n</head>\n<body>\n    <div id=\"app\"></div>\n</body>\n</html>\n\n<script>\n    const app=Vue.createApp({ })\n    const vm=app.mount(\"#app\")\n</script>\n```\n\n**我们可以看到，现在我们将一个新的VUE实例挂载到页面ID为app的区域**\n\n# 定义全局组件并使用\n\n现在我们的app可以注册全局的组件，注册好后可以直接在根组件上进行使用\n\n**比如我们要显示两个信息（紧接着上方的基本代码）**\n\n1. 这是我的网站\n\n2. https://www.vincent990413.gitee.io/myblog\n```js\n//第一个全局组件\napp.component('my-component-describe',{\n\ttemplate:` <h1> 这是我的网站 </h1> `\n})\n\n//第二个全局组件\napp.component('my-component-website',{\n\ttemplate:` <h1> https://www.vincent990413.gitee.io/myblog </h1>`\n})\n\n```\n\n**以上就完成了对组件的定义，接下来我们要做的就是使用这些组件**\n\n```js\n//在创建实例的同时 使用自己的组件\nconst app = Vue.createApp({\n\ttemplate:`\n\t\t<my-component-describe />\n\t\t<my-component-website />\n\t`\n})\n```\n\n**可以将这些步骤想象成 “初始化数据” 初始化数据之后 -> 最后一步才是挂载在网页中**\n\n## 全局组件的可复用性\n\n**什么叫可复用性，就是可重用性，我们将一个组件封装好之后，**\n\n**可以在网页中的各个区域去重复引用这个组件**\n\n## 全局组件的弊端？！\n\n**全局组件是有弊端的，因为你处处都可以使用，但是性能不高，应用打开就开始复杂的初始化**\n\n# 局部组件\n\n**针对与局部组件：我现在不注册，我要用的时候才注册这个组件，才进行使用**\n\n**而全局组件是，我不用之前一直都被注册了，一直都存在在那里！**\n\n<mark>我们可以把局部组件，想象成，一个变量！我定义这个变量，我用的时候再注册它。</mark>\n## 创建局部组件\n```js\nconst myComponentCounter = {\n\tdata(){\n\t\treturn{\n\t\t\tcount: 0  \n\t\t}\n\t},\n\ttemplate:` <div> {{count}} <button @click=\" count++ \">增加1</button> </div> `\n}\n```\n\n**通过这种定义“变量”的方式，我们就已经定义好一个组件了，接下来我们需要在vue.CreateApp()方法里去注册**\n\n**直接用component: { myComponentCounter }, 声明即可**\n\n```js\nconst app = Vue.CreateApp({\n\tcomponents: {'my-component-counter':myComponentCounter}, //声明我的组件 前面的别名可以去掉\n\ttemplate: `\n\t\t<h1>这是我的网站</h1>\n\t\t<my-component-counter/> \n\t`\t//在父组件中的任何位置 都可以调用已经注册了的组件\n})\n```\n\n**我们的局部组件一般使用驼峰命名法**\n\n**但多个单词，我们应该遵守规范，**\n\n**1. const变量用驼峰myComponentCounter**\n\n**2. 起别名时 单引号且中间加- 小写每个字母: my-component-counter**\n\n(具体见上方代码)\n\n# 父组件与子组件以及他们之间的静态、动态传值\n\n## 什么是父组件，什么是子组件？\n\n<mark>我们在父组件中，定义子组件并使用子组件</mark>\n\n**被注册，被使用的那个组件叫做：子组件**\n\n**使用 “定义好的组件” 的组件叫做父组件**\n\n## 定义全局组件Son 并在父组件中使用\n\n```js\napp.component('Son',{\n\ttemplate: `\n\t\t<div> 这是子组件 Son div </div>\n\t`\n})\n\nconst app = Vue.CreateApp({\n\ttemplate: `\n\t\t<h1>下面调用子组件</h1>\n\t\t<Son /> \n\t`\n\t// 调用Son 子组件\n})\n\nconst vm=app.mount(\"#app\")\n```\n\n## 父组件的参数传给子组件（静态传值）\n\n**所谓父组件向子组件传值，就是在调用子组件的时候，静态绑定props参数**\n\n```js\n//父组件传入name参数 那么子组件就要有一个name处于prop数组中\n<Son name = \"vincent\"/>\n\napp.component('Son',{\n\tprop:['name']\n\ttemplate: `\n\t\t<div> 这是子组件，父组件传过来的参数name值为：{{name}} </div>\n\t`\n})\n```\n\n**这种方法是静态传输，一旦运行起来，就无法改变了**\n\n## 父组件的参数传给子组件（动态传值）\n\n**一般我们利用：将父组件中data中的参数与传入子组件的参数进行绑定**\n\n**从而使得传入的值，是动态的，是可变的**\n\n```js\nconst app = Vue.CreateApp({\n\tdata(){\n\t\treturn{\n\t\t\tname: 'Beatrix'\n\t\t}\n\t},\n\ttemplate: `\n\t\t<h1>下面调用子组件</h1>\n\t\t<Son :name=\"name\" />  \n\t`\n\t// 此时是动态传入给子组件的参数 \n})\n\napp.component('Son',{\n\tprop:['name']\n\ttemplate: `\n\t\t<div> 这是子组件，父组件传过来的参数name值为：{{name}} </div>\n\t`\n})\n```\n\n**这样通过修改data中的参数 完成动态绑定**\n\n## 父组件的参数传给子组件（传入函数参数）\n```js\n//父组件\nconst app=Vue.createApp({\n\tdata(){\n\t\treturn{\n\t\t\tname: 'Beatrix'\n\t\t}\n\t},\n\tmethods:{\n\t\ttalk(){\n\t\t\treturn \"你好，我是Vincent.\"\n\t\t}\n\t},\n\ttemplate:`\n\t\t<h1>下面调用子组件并传入函数参数talk</h1>\n\t\t<Son :talk = \"talk\" />\n\t`\n})\n\n//子组件\napp.component('Son', {\n\tprops:['talk'],\n\tmethods:{\n\t\tbuttonTalk(){\n\t\t\t//弹窗显示 父组件传来的函数参数\n\t\t\talert(this.talk())\n\t\t}\n\t},\n\ttemplate:`\n\t\t<div> 这是子组件Beatrix，我想知道你是谁？</div>\n\t\t<div> <button @click=\"buttonTalk\">点我就知道了</button> </div>\n\t`\n})\n\nconst vm=app.mount(\"#app\")\n```\n## 父组件的参数传给子组件（Slot插槽）\n\n**这种情况适用于，父组件传入给子组件一段HTML代码，欲在部分区域显示：**\n\n1. 在子组件想要显示的区域，声明插槽\n\n2. 在父组件使用子组件的双标签形式，并插入HTML代码/其他子组件 `<Son> <div> {{counter}}: <my-component-others /></div> </Son>` \n\n```js\nconst app = Vue.createApp({\n\tdata(){\n\t\treturn{\n\t\t\tcounter:1\n\t\t}\n\t},\n\ttemplate:`\n\t\t<h1>父组件调用子组件并传入HTML代码/其他组件</h1>\n\t\t<Son> <div style=\"background-color:red;\"> {{ counter }}</div> </Son>\n\t`\n})\n\napp.component('Son', {\n\tdata(){\n\t\treturn{\n\t\t\t\n\t\t}\n\t},\n\tmethods:{\n\t\t\n\t},\n\ttemplate:`\n\t\t<h1>子组件的标题</h1>\n\t\t<slot></slot>\n\t`\n})\n\nconst vm = app.mount(\"#app\")\n```\n\n<mark>值得注意的是，当父组件与子组件具有同名的变量时，我们父组件传入参数时，子组件的slot中会显示父组件的属性。</mark>\n\n* 父模板里调用的数据属性，使用的都是父模板里的数据。\n\n* 子模板里调用的数据属性，使用的都是子模板里的数据。\n\n`{{counter}}` 是在父模板中调用的，那么使用的是父模板的数据。\n\n### slot中的默认数据\n\n**当slot中无数据传递过来是，写在slot中的数据就是默认显示数据。**\n\n```js\n<slot> 这是默认数据 </slot>\n```\n\n### 指定若干个插槽的位置(指定不同的name)\n\n```js\napp.component('Son',{\n\ttemplate:`\n\t\t<slot name=\"first\"></slot> \n\t\t<div>这是第二个</div>\n\t\t<slot name=\"third\"></slot>\n\t`\n})\n```\n\n**我们可以看到，指定了name显示区域，在父组件传值的时候，也指定显示在对应name的区域即可。**\n\n```js\nconst app = Vue.createApp({\n\tdata(){\n\t\treturn{\n\t\t\t\n\t\t}\n\t},\n\tmethods:{\n\t\t\n\t},\n\ttemplate:`\n\t\t<Son>\n\t\t\t<template v-slot:first> <div>这是First的参数值</div> </template>\n\t\t\t<template v-slot:third> <div>这是third的参数值</div> </template>\n\t\t</Son>\n\t`\n})\n```\n**在代码中，我们可以看到，利用 `v-slot:XX` 可以指定显示在对应子组件name为XX的区域**\n\n<mark>也可以简写成 `#XX` </mark>\n\n\n\n# 子组件\n## 子组件向父组件传递数据\n\n* 子组件调用父组件事件\n\n* 子组件向父组件事件中传递参数\n\n* 子组件传递参数时，如何通过`emits`进行校验\n\n**根据组件之间的单向数据流，子组件是没办法直接更改父组件传递过来的参数**\n\n**解决办法**\n\n**1. 将父组件传递过来的参数赋给子组件的数据 在子组件中更改自己的数据（本段稍后一点内容）**\n\n**2. 我们可以调用父组件的 “可以改变这个参数值” 的方法，本质上是父组件来改变（紧接着读下去）**\n\n比如：我们用父组件更改传递给子组件的counter变量（用一个方法）\n\n在子组件中调用这个方法\n\n**仔细看懂，接下来的代码！**\n\n**仔细看懂，接下来的代码！**\n\n**仔细看懂，接下来的代码！**\n\n```js\n//父组件\nconst app=Vue.createApp({\n\tdata(){\n\t\treturn{\n\t\t\tcounter: 1\n\t\t}\n\t},\n\tmethods:{\n\t  parentUpdateCounter(){\n\t\t  this.counter++;\n\t  }      \n\t},\n\ttemplate:`\n\t\t<h1>下面调用子组件传入参数counter</h1>\n\t\t\n\t\t<h1>子组件通过父组件的方法，更改这个传递过去的参数（注意区分直接赋给子组件中的data参数）</h1>\n\t\t\n\t\t<Son :counter=\"counter\" @parentUpdateCounter=\"parentUpdateCounter\"  />\n\t`\n})\n\n//子组件\napp.component('Son', {\n\tprops: ['counter'],\n\temits:['parentUpdateCounter'],\n\tdata(){\n\t\treturn{\n\n\t\t}\n\t},\n\tmethods:{\n\t\tchildUpdate(){\n\t\t\tthis.$emit('parentUpdateCounter')\n\t\t}\n\t},\n\ttemplate:`\n\t\t<div> 这是子组件，我想看到数据变化！</div>\n\t\t<div> {{ childCounter }}  \n\t\t   {{ counter }} <button @click=\" childUpdate \">点我就知道了</button>\n\t\t </div>\n\t`\n\t//可以看到 上面是{{ counter }} 直接引用父组件传过去的参数\n})\n\nconst vm=app.mount(\"#app\")\n```\n\n### 关键代码：\n\n**1. 首先在父组件中定义传递过去的变量counter `data(){return{ counter:1 }}`**\n\n**2. 父组件传递过去 `<Son :counter=\"counter\" />`**\n\n**3. 子组件中声明props用来接收 `props:[ 'counter' ]`**\n\n**4. 父组件中写可以更改counter变量的方法 `methods:{parentUpdateCounter(){this.counter++}}`**\n\n**5. 父组件传递过去 `<Son :counter=\"counter\" @parentUpdateCounter=\"parentUpdateCounter\"/>` (@引用名=“父组件方法名”)**\n\n**6. 子组件中声明emits用来接收 ` emits:['parentUpdateCounter'] `(与父组件传递过来的引用名一致)**\n\n**7. 子组件在需要的时候(一般在子组件自己的方法内部)，调用这个父组件的引用名（代表对应的父组件方法）`this.$emit('parentUpdateCounter')`**\n\n## 子组件利用slot向父组件传递List中的数据\n\n**在Javascript中的list中，我们视为对象，因此调用属性是需要 `obj.item`**\n\n1. 为子组件中添加list数据\n```js\napp.component('Son',{\n\tdata(){\n\t\treturn{\n\t\t\tnames: ['Vincent', 'Beatrix', 'James']\n\t\t}\n\t},\n\ttemplate:`\n\t\t<div>\n\t\t\t<slot v-for=\"name in names\" :item=\"name\"> </slot>\n\t\t</div>\n\t`\n})\n```\n\n* 最重要的就是我们为这个插槽，绑定了item属性，这样父组件可以调用到这个属性。\n\n2. 父组件调用这个子组件，并得到绑定的item值\n```js\nconst app=Vue.createApp({\n\tdata(){\n\t\treturn{\n\t\t\t\n\t\t}\n\t},\n\ttemplate:`\n\t\t\t<Son v-slot=\"props\"> \n\t\t\t\t<div> {{ props.item }} </div>\n\t\t\t</Son>\n\t\t`\n})\n```\n\n* props可以任意取名字，但是一定是要绑定`item`这个属性\n\n\n# 校验器（引入 ElementUI）\n[点我，见图书管理系统的前端项目地址](https://gitee.com/vincent990413/book-store-front-end)\n\n# 组件之间的单向数据流\n\n**一句话说明，就是数据从父级组件传递给子组件，只能这样单向（从父到子）绑定**\n\n**子组件内部不能直接修改从父组件传递过来的数据**\n\n**比如我们在父组件中定义一个计数器counter，传给子组件后，在子组件中更改这个数据**\n\n结论是，我们没办法看到这个数据的变化。\n\n<mark>既然我们没办法，直接改变父组件传过来的变量，不如我们只更改子组件data中的变量</mark>\n\n**但将这个子组件data中的变量 赋值为父组件传过来的变量**\n\n```js\n\n比如父组件传过来的变量为counter\n\n//父组件\nconst app=Vue.createApp({\n\tdata(){\n\t\treturn{\n\t\t\tcounter: 1\n\t\t}\n\t},\n\tmethods:{\n\n\t},\n\ttemplate:`\n\t\t<h1>下面调用子组件并静态传入函数参数talk</h1>\n\t\t<Son :counter = \"counter\" />\n\t`\n})\n\n//子组件中\napp.component('myComponentCounter',{\n\tprops: ['counter'],\n\tdata(){\n\t\treturn{\n\t\t\t//关键一步，我们赋给可以改变的childCounter\n\t\t\tchildCounter: this.counter\n\t\t}\n\t},\n\ttemplate:`\n\t\t{{ childCounter }} <button @click=\" childCounter++ \"> 点我可以看到数据的变化 </button>\n\t`\n})\n\n```\n\n**这样我们就可以看到数据的变化了！**\n\n* 思考，为什么要有单向数据流的概念呢？\n* 因为，如果父组件使用多个相同的子组件，传入不同的参数，我们希望这些子组件互不干扰。\n\n**也就是说，子组件不能直接更改父组件的数据，而是更改自己的数据。**\n\n# 异步组件和Promise讲解\n\n## 异步的概念\n**所谓异步，就是几个操作不是按严格的顺序执行（真正的执行顺序未知）**\n\n**与它相反的概念是同步：**\n\n* 举个例子，如何将大象塞到冰箱里？\n\n1. 打开冰箱\n\n2. 将大象塞进去\n\n3. 关掉冰箱门\n\n以上的操作就是同步的，具有严格的前后时序。\n\n*一般而言，我们将经常要去后台请求数据的业务/组件，封装成异步的。*\n\n## Promise\n```js\napp.component('async-component',Vue.defineAsyncComponent(()=>{\n    return new Promise((resolve,reject)=>{\n        setTimeout(()=>{\n            resolve({\n                template:`<div>这是一个异步组件</div>`\n            })\n        },3000)\n    })\n}))\n```\n\n**我们在调用这个组件时，三秒钟后，会出现对应组件中的内容**\n\n* 关于Promise的概念，详情[点我去JavaSCript基础教程](https://vincent990413.gitee.io/myblog/2021/03/15/JavaScript/#promise-%E7%B1%BB%E8%A7%A3%E5%86%B3%E5%89%8D%E7%AB%AF%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E5%90%8E%E5%8F%B0%E6%95%B0%E6%8D%AE)\n\n# 爷孙级别组件数据传递（多用于多级组件）\n\n## 顺序依次继承数据\n**如果有一个爷爷，他现在有一套房子（北京四合院），想过继下去。**\n\n我们就可以实现：\n\n1. 从爷爷过继给父亲，再从父亲过继给孙子 props参数\n```js\nconst app=Vue.createApp({\n\tdata(){\n\t\treturn{\n\t\t\thouse: '北京四合院，价值8000万！'\n\t\t}\n\t},\n\ttemplate:`\n\t\t<h1> 这是爷爷，爷爷过继给儿子！ </h1>\n\t\t<Son :house=\"house\" />\n\t`\n})\n\napp.component('Son',{\n\tprops:['house'],\n\ttemplate:`\n\t\t<h2>儿子接受房子，这个房子是： {{ house }} <h2>\n\t\t<h2>儿子继续过继给孙子</h2>\n\t\t<Grandson :house=\"house\" />\n\t`\n})\n\napp.component('Grandson',{\n\tprops:['house'],\n\ttemplate:`\n\t\t<h3>这是孙子，接受房子，房子信息是： {{house}} </h3>\n\t`\n})\n\nconst vm=app.mount(\"#app\")\n```\n\n**这样通过依次继承的方法，的确可以做到将“爷爷”级别的组件数据传递给“孙子”组件**\n\n*但如果项目中出现5，6次继承层次的孙孙孙...这样代码就太冗余了*\n\n## 指定组件层次接受参数 Provide&Inject\n\n**Provide意为提供参数，Inject引入接受、注入参数**\n\n**也就是说，我们在“祖先”级别的组件提供某个参数，可以跳过中间的若干个组件，直接过继给指定的组件**\n\n```js\nconst app=Vue.createApp({\n\tdata(){\n\t\treturn{\n\t\t\thouse: '北京四合院，价值8000万！'\n\t\t}\n\t},\n\tprovide:{\n\t\thouseDirectlyToGrandson: '给孙子的海景房！'\n\t},\n\ttemplate:`\n\t\t\t<h1> 这是爷爷，爷爷不过继给儿子，直接给孙子！ </h1>\n\t\t\t<Son/>\n\t\t`\n})\n\napp.component('Son',{\n\tprops:['house'],\n\ttemplate:`\n\t\t<h2>这是儿子，不接受参数，不传递参数！</h2>\n\t\t<Grandson/>\n\t`\n})\n\napp.component('Grandson',{\n\tprops:['house'],\n\tinject:['houseDirectlyToGrandson'],\n\ttemplate:`\n\t\t<h3>这是孙子，接受房子，房子信息是： {{houseDirectlyToGrandson}} </h3>\n\t`\n})\n\nconst vm=app.mount(\"#app\")\n```\n\n**关键代码：**\n\n1. 在爷爷组件中，提供属性 ` provide:{ newHounse:'新房子' } `\n\n2. 在任意后代组件中，提供注入参数：`inject:['newHouse']` 即可引用\n\n* 如果这种层级关系达到5-6级，再使用props进行传递，那就会非常麻烦，而且会有大量的代码冗余。\n\n* 使用provide和inject可以解决这个问题。","tags":["前端框架学习"],"categories":["前端框架学习"]},{"title":"Java反射机制-学习笔记","url":"/2021/04/15/Java反射机制-学习笔记/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# Java中的反射机制-笔记\n## 反射原理的介绍(能利用反射做什么)\n  \n- 获得类的信息 Class\n- 获得类中的属性信息 Field\n- 获得类中的方法信息 Method\n- 获得类中的修饰符 Classifier  \n- 获得类中的构造方法 Constructor  \n- 获得该类所继承的父类 SuperClass 所实现的接口 Interface  \n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021041417283795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 测试类 User.java(含属性以及Setter、Getter方法)\n![测试类](https://img-blog.csdnimg.cn/20210414172902285.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 利用反射获取该User类\n![获取类](https://img-blog.csdnimg.cn/20210414172921833.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 获取User类中的方法以及属性\n![获取方法](https://img-blog.csdnimg.cn/20210414172947638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 获取User类所继承的父类（默认为Object）以及实现的接口\n![获取父类以及接口](https://img-blog.csdnimg.cn/20210414173008844.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)","tags":["编程语言"],"categories":["编程语言"]},{"title":"Java集合框架-基础学习","url":"/2021/04/14/Java集合框架-基础学习/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# Collecion 集合框架\n## ArrayList(动态数组-顺序表）\n**ArrayList是一个可动态修改数据、删除数据的数组**  \n\n**没有固定的大小限制（可以看做是Vector的定义）**\n\n![ArrayList基本图](https://img-blog.csdnimg.cn/20210414111059118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n### （附）Java集合中各个容器的关系\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210414111647555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n### 添加数据、删除数据等操作\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210414111653473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n### 迭代方法以及其他常见方法\n\n更多见： **[菜鸟教程集合框架...](https://www.runoob.com/java/java-collections.html)**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210414111657315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## LinkedList(链表）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210415143500877.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210415143505267.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## HashMap(基于键值对Key-Value的哈希映射）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210415143513937.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210415143518117.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n\n## HashSet(基于HashMap的不重复元素的集合）\n![HashSet 集合](https://img-blog.csdnimg.cn/20210415135927238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n![HashSet 集合](https://img-blog.csdnimg.cn/20210415135931624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n","tags":["编程语言"],"categories":["编程语言"]},{"title":"SpringRedis_存储Map中的KV与读取","url":"/2021/04/10/Java技巧-Redis存储/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# 依赖注入\n```java\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n# 配置文件 application.yml\n```java\nspring:\n  redis:\n    port:6379\n```\n\n# 实例代码（存储同一个map下的->key:value值）\n\n## Controller层注入StringRedisTemplate\n\n**关于Redis在SpringBoot中，有两个**\n\n第一个是**RedisTemplate**\n\n第二个是**StringRedisTemplate**\n\n如果想以字符串的形式存储，选择**StringRedisTemplate**即可。\n\n**存值**\n\n```java\n@Autowired\nprivate StringRedisTemplate stringRedisTemplate;\n\n//存值：\nstringRedisTemplate.opsForHash().put(\"student\", \"name1\", \"vincent\");\nstringRedisTemplate.opsForHash().put(\"student\", \"name2\", \"Jack\");\n```\n\n**取值**\n```java\n//结果是vincent\nString redisCode = (String) stringRedisTemplate.opsForHash().get(\"student\", name1);\n```\n\n# 通过Redis-cli查看\n## 首先打开redis-serve.exe\n## 打开redis-cli.exe\n\n```java\n\t//hget map key 返回value\n\thget student name1 \n```\n\n```java\n\thset student name1\n```\n\n```java\n\thdel student name1\n```","tags":["Java编程实用小技巧"],"categories":["Java编程实用小技巧"]},{"title":"PageHelper根据页数数据分页显示","url":"/2021/04/10/Java技巧-SpringBoot-PageHelper根据页数数据分页显示/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# 引入依赖\n```js\n<!-- pagehelper -->\n<dependency>\n\t<groupId>com.github.pagehelper</groupId>\n\t<artifactId>pagehelper-spring-boot-starter</artifactId>\n\t<version>1.2.5</version>\n</dependency>        \n```\n\n# 配置文件\n```java\npagehelper:\n  helperDialect: mysql\n  reasonable: true\n  supportMethodsArguments: true\n  params: count=countSql\n```\n\n# 实例代码\n```java\n//startNum=1, pageSize=5\n//页数为第一页 每页大小为5\nPageHelper.startPage(startNum, pageSize);\nList<Book> list = bookService.findAllBooks();\nPageInfo pageInfo = new PageInfo(list, pageSize);\nreturn new ApiResponse(200, \"请求成功\", pageInfo);\n```\n\n","tags":["Java编程实用小技巧"],"categories":["Java编程实用小技巧"]},{"title":"政治上60分就够了？不是吧，你一定要看看","url":"/2021/04/09/不会吧考研政治/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# 政治准备书籍或资料\n## 1. 徐涛老师的《核心考案》\n\n徐涛老师的核心考案就像是一本书的大纲一样，从马原的第一章到思修法基的最后一章。\n\n该书都涵盖了该有的考点，当然最好是能够：\n\n**边看核心考案，边做笔记，老师会勾画重点**\n\n## 2.肖秀荣老师的《1000题》\n\n可以说，市面上的题目质量，最好的前几名，肖老师的《1000题》一定名列前茅。\n\n可以选择一手听徐涛老师的强化课，\n\n一手**做肖老师的1000题** 当然最好是能反复！！\n\n我的方法就是：\n**第一遍用铅笔做，答案都写在题目的左侧**\n\n**然后第二遍可以，用中性笔做，记得标出经常错的题目**\n\n## 3. 腿姐的技巧班\n\n腿姐的技巧班可以说，真的是**实战**。\n\n不玩虚的，就是教你如何从**历年真题出发，到底如何高效地做题**\n\n如果有条件，**一定听一下腿姐的相关配套课程！**\n\n## 4. 肖老师的《肖四》《肖八》\n\n针对于去年考研，我想说：\n\n我绝对会给这两本书**五颗星** ☆☆☆☆☆\n\n原因不详细阐述，我多次在公开场合提到，你一定要备这两本书！\n\n## 5.注意关注徐涛老师的微博、徐涛老师的微信公众号\n\n# 时间安排\n## 7月份~开始复习\n\n基本上你会看到，大部分同学都是在这个时间点开始复习。\n\n我是在七月份开始**复习政治与专业课**\n\n政治每天安排：\n\n**傍晚：1~2节徐涛老师的视频课**\n\n**然后做一做肖老师的《1000题》**\n\n## 9月份-技巧阶段\n\n在这个时候 基本上 **你应该完成考研政治的大部分内容了**\n\n这个时候，其实是比较建议**听腿姐老师的《核心技巧班》**\n\n因为还是那句话，我们最终是要上考场做题的\n\n所以，技巧班能从题目本身教我们如何做题？\n\n避免以自己的思维来做题\n\n## 12月份 “背多分” 协奏曲！\n\n可以说，政治考得好不好。就看最后这些时间\n\n**我强烈建议 要多看肖秀荣老师的《肖四》 《肖八》**\n\n当然如果能够买一本**徐涛老师的“小黄书”《背诵笔记》**，辅佐以素材是更好的了\n\n","tags":["研究生入学考试经验贴"],"categories":["研究生入学考试经验贴"]},{"title":"2021年计算机重庆邮电大学研究生入学考试经验","url":"/2021/04/09/2021年计算机重庆邮电大学研究生入学考试经验/","content":"\n# 前言 Preface\n一年一度的全国研究生入学考试终于落下帷幕。今天是2021-04-09，距离2121届研究生入学考试已经过去了几个月的时间。\n\n现在终于能够静下心来，好好分析自己走过的旅程。以及总结踩过的雷区，错误的学习方法以及可以分享给大家的**好方法**，\n\n当然百密难逃一疏，恳请理解。\n\n# 感谢信 Acknowledgement\n在我写这篇文章的时候，首先感谢**在考研过程中**给我提供帮助的小哥哥、小姐姐。\n\n首先感谢我的本科学校：攀枝花学院\n\n真的是所很棒的学校 我在这里遇到了很多优秀的人！感谢你PANDA\n\n感谢我在考研前期准备阶段给我提供资料、一直给我打气的**权哥、涛兄**（什么时候开博客啊？我给您们开友链呢！）\n\n感谢提供给我关于专业知识的2016级直系**高学长**，谢谢你\n\n感谢在复试过程中给予我帮助，曾面试我给我宝贵面试经验的莲莲学姐（抱歉我不知道您的真名）\n\n感谢我们的**301寝室的小哥哥**、**尤其感谢一起备考的李总**（李总博客会放在友链里面，咱们得支棱起来！）\n\n感谢外语院的摄影师秋水（一定前程似锦）\n\n```java\n❤ 感谢我的宝贝儿乐乐 谢谢你在我考研路上出现在我的生命里 爱你么么哒 ❤\n```\n\n☆☆☆ 特别感谢：\n\n**直系学姐-小七，非常，非常，非常感谢在我初试、复试过程中的无私帮助！简直就是我的贵人，大佬受小弟一拜。**\n\n有想学舞蹈的小姐姐可以找她，专业的！\n\n\n**需要任何帮助可以加我的微信噢**，我会及时回复：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210409165733759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n\nWithout further ado 废话少说还是直接进入正题。\n\n：）老规矩，介绍自己参加考研的**基本情况**。\n\n报考院校：**重庆邮电大学**（忍不住Bold字体，真的是好学校）\n\n专业/类型：电子信息（**专业型硕士学位**）\n\n\n# 考研分数情况 Info\n##（初试分数：复试分数=6：4）\n\n```java\n☆ 初试：（总分357分）\n\t1. 政治： 71分\n\t2. 英语： 79分\n\t3. 数学： 116分\n\t4. 专业课： 91分（计算机网络）\n\n☆ 复试：\n\t1.英语口语、听力：18.8分（总分20分）\n\t2.笔试分数：92分（总分100分）\n\t3.综合面试：90分（总分100分）\n```\n\n![初试成绩](https://img-blog.csdnimg.cn/2021040920533010.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n![总体成绩](https://img-blog.csdnimg.cn/20210409205536318.png)\n\n\n\n# 初试过程 Process\n## 1.考研择校\n### 择校成功 = 考研成功1/4\n\n我想特别说明关于你的**target university目标院校**的重要性！\n\n首先你可以通过你的**目标院校研究生院**获得相关信息\n\n比如重庆邮电大学为例：\n\n[点我进入重庆邮电大学官网研究生院](http://yjs.cqupt.edu.cn/ejlby.jsp?a7t=28&a7p=5&a7c=10&urltype=tree.TreeTempUrl&wbtreeid=1006)\n\n那么看什么？\n\n```java\n首先看报考的目标专业招多少人？\n\n初试科目考哪些？考英语一还是英语二？专业课考408还是只考其中部分科目？\n\n以及对应的科目参考书籍。\n\n```\n\n注意：有可能**你想报考的专业分布于不同学院：比如**软件学院、XX学院、然后**不同学院招收的人数不同**。\n\n这里我给出地址（方便各位下载）：\n\n[2021年计算机科学与技术学院/重邮科大讯飞人工智能学院硕士研究生招生报考指南：](http://yjs.cqupt.edu.cn/info/1006/6529.htm)\n\n网址里面有：\n1. 学院的**招生专业信息**\n\n2. **初试参考书目**\n\n3. **初复试考试大纲**\n\n4. 最新的**初试专业课真题！**\n\n如图所示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021040915320363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n2. 看完相应的科目，要顺便看看：**学术型硕士与专业型硕士**参考科目的不同。\n\n以**重庆邮电大学**为例（注意，这里的专业课不同的学校可能是不同的，**而且考的门数也不同，要仔细看看**）\n\n```java\n* 专业型硕士：\n\t1. 数学二（高等数学+线性代数）\n\t2. 英语二\n\t3. 政治\n\t4. 计算机网络\n* 学术型硕士：\n\t1. 数学一（高等数学+线性代数+概率论）\n\t2. 英语一\n\t3. 政治\n\t4. 数据结构\n```\n\n直接上图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210409153859210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210409153927492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n上图是**学术型硕士的基本招收信息**\n\n下图是**专业型硕士的基本招收信息**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210409154041948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n具体看你所报考的院校基本信息！\n\n那么，以上就是**真正地准备初试所需要的基本信息收集**\n\n## 2. 各科目准备过程\n### 数学（初试中的爸爸ROLE）\n\n本人基本情况，高考数学没及格。大学数学也学得不好。根据自己严格的做题方法和做题步骤，最终能够拿到这个成绩，真的很不容易。**Trust Me**，考研数学，其实没有想象中的那么难。\n\n数学整体题目分布（转自新东方网）：\n\n**数学一：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210409172313915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**数学二**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210409172350108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**数学三**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021040917240528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n\n\n* 针对数学二部分的备考经验、以及各个Section的备考方法。同在我个人博客网站中，链接如下：\n\n[考研数学到底怎么样才能上一百分？我来告诉你...](https://bruce-jj.gitee.io/blog/2021/04/09/%E4%B8%8D%E4%BC%9A%E5%90%A7%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/)\n\n### 让人头疼的英语\n考研英语分为英语二与英语一，本人基本情况是，大一通过四六级。\n\n回归考研英语本身：\n\n题目分布：\n```java\n1. 完形填空20个（每个0.5分）共10分\n2. 经典阅读理解题，四篇20个，每个2分，共40分\n3. 新题型（段落匹配、连线等）10分\n4. 英译汉（15分）\n5. 作文一：书信10分\n6. 作文二：图表15分\n```\n\n英语一不同的地方在于，书信是一样的，但是**图表作文换成了图画作文。**\n\n同时英语二的翻译是，**翻译整篇短文**\n\n英语一的翻译是：**挑选一篇文章中的五句话，要求结合上下文进行翻译**\n\n* 针对英语部分的备考经验以及各个Section的备考方法。同在我个人博客网站中，链接如下：\n\n[不会吧？都2021年了，还有人觉得考研英语简单！？](https://bruce-jj.gitee.io/blog/2021/03/11/%E4%B8%8D%E4%BC%9A%E5%90%A7%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD/)\n\n### “价值连城”的政治！\n政治是很重要的科目，同时政治也是比较容易速成的科目！\n\n总体而言，考研政治分为几大板块：\n```java\n1. 第一部分 马克思主义基本原理概论（马原）\n2. 第二部分 毛泽东思想和中国特色社会主义理论体系概论（毛中特\n3. 第三部分 中国近现代史纲要（近现代史）\n4. 第四部分 思想道德修养与法律基础（思修法基\n```\n\n其中，马原占到试卷的24%，\n\n毛中特占到试卷的30%，\n\n近现代史占到14%\n\n最后思修法基占到16%\n\n总共38道题，1~16题是单项选择题，\n\n17~33题是多选题**（多选题是爸爸，分值高分值低都看多选题！！！）**\n\n最后的34~38题是分析题**（分析题也可以挽救你，只要你字写得好看，答题1、2、3地按序，按重点答）**\n\n\n* 针对政治部分的备考经验以及各个Section的备考方法。同在我个人博客网站中，链接如下：\n\n\n[政治上60分就够了？不是吧，你一定要看看](https://bruce-jj.gitee.io/blog/2021/04/09/%E4%B8%8D%E4%BC%9A%E5%90%A7%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB/)\n\n### 备受“争议”的专业课\n\n专业课满分150分，各个院校的专业课组成部分不同。\n\n譬如有的考两三门，有的考一门，有的考四门：\n\n但大致上，针对计算机专业的大部分院校，都由以下几门专业课组成：\n\n```java\n数据结构 严蔚敏著\n\n计算机网络 谢希仁著\n\n操作系统 汤子瀛著\n\n计算机组成原理 唐朔飞著\n```\n\n我备考的时候专硕只考一门课：计算机网络\n\n**参考书目是：谢希仁著的，《计算机网络》（第七版）**\n\n总体来说，这门课考得有点不好，91分。\n\n这是我没有想到的，但是我想肯定是自己在答题方面，没有发挥好。\n\nOR\n\n就是自己太菜了！\n\n部分知识理解 就不跟大家分享了~\n\n那么主要是还是要从备考本身 \n\n**分享一些好的学习 渠道吧**\n\n#### ☆ 王道还是天勤？\n\n了解计算机考研的都应该知道这两个机构。\n\n其实我想说，不管是王道的**计算机网络讲义**还是天勤的**高分笔记**\n\n都是大牛编者编写的，只不过在个人使用方面，\n\n我比较推荐都看哈哈哈哈！\n\n#### ☆ 思维导图有多重要？\n\n**重要的事情说三遍：很重要，很重要，很重要！**\n\n对于计算机网络这门课程，一定要有思维导图，\n\n当然如果你购买了王道、天勤的课程或者他们的书籍\n\n一定是会有相应的思维导图的！\n\n对于这门课程，我想整体一定要有清楚的认知。每章的重点在哪里？\n\n#### ☆ 历年真题！！！Five Stars ☆☆☆☆☆\n针对目标院校的真题，一定要反复研读！\n\n很多题目，不说完全重复，但是非常相近！\n\n不是这个考点，就是这个考点的情况，非常多！！！务必引起大家的重视。\n\n# 复试过程 Re-Examination\n\n富强、民主、文明、和谐、自由、平等、公正、法治、爱国、敬业、诚信、友善。\n\n# 我的建议：Recommendation\n## 1. 如果能有跟自己并肩作战的研友是最好不过的了！\n## 2. 一定要去图书馆！！！ \n## 3. 重要的是效率！高效的6h > 盲目的12h\n## 4. 学累了就放松 放松够了就继续冲！\n## 5. 考研不是终点 考上了也要付出多出常人的努力！\n### （考不考得上 你都是王者 需要这种心态！）\n## 6. 遇到自己喜欢的另一半 就在一起吧 不要错过爱情~","tags":["研究生入学考试经验贴"],"categories":["研究生入学考试经验贴"]},{"title":"hello","url":"/2021/04/09/hello/","tags":["hello"],"categories":["hello"]},{"title":"考研数学到底怎么样才能上一百分？我来告诉你...","url":"/2021/04/09/不会吧考研数学/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n接下来我将以：\n```java\nn月份~6月份\n\n7月份~9月份\n\n以及最后考试前两个月的时间段来描述具体如何备考\n```\n\n# 6月份之前（基础阶段）：\n这个时间段，是铁定的**基础阶段**，当然这个基础阶段是要打上引号的！所谓的基础阶段，**并不是单纯地看本科阶段所学科目的书！而是从->本科书->到名师基础班的过渡。**\n\n也就是说，这个阶段最重要的事情就是：打好基础！越牢越好，切忌好高骛远，埋头苦干。\n\n我复习的时候，看的老师：\n\n## 高等数学：汤家凤（基础阶段）\n\n## 线性代数：李永乐\n\n**基础阶段**我建议，先看高等数学、线性代数的书，入门知识过一遍。能够掌握做**课后习题**的方法即可！不要做太难的题。\n\n再看完高等数学、线性代数的书后，可以开始进入真正的**考研数学基础班**了。\n\n还是建议**数学汤家凤**基础阶段紧跟！\n\n值得一提的是，我非常建议\n```java\n买汤家凤老师的《接力题集1800》\n\n汤家凤老师的高等数学讲义\n\n关注汤家凤老师的微信、微博（关注寒暑假等假期的的直播课程）\n```\n**对的，必买！！！**\n\n汤老师在课程中，会讲数学一、数学二、数学三的公共部分！\n\n对于**数学科目的独属部分以及题集的部分讲解**，会在公众号以直播的形式播出！\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210409165805541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n\n\n**给出自己基础阶段的复习方法：**\n\n**高等数学跟汤家凤老师，线性代数跟李永乐老师即可。**\n\n☆ 第一、看对应的汤老师视频课程，但不要看多了，建议是看数集视频（看自己的状态）然后立马投入到1800题集的题海中！\n\n过完一章后，最好是看看这一章学到了什么？可不可以以笔记的形式过一遍。\n\n☆ 第二、《接力题集1800》，一定要**关注、标黑错题**。错题是很有价值的，到底自己是错在哪里？\n\n详细看看答案，为什么汤老师要这么写？\n\n如果不知道，**那么，看了答案后，下次是否能够同步汤老师的思维！** 看到该类型的题，就要想起：\n\n```java\n\n这个题是涵盖哪些章节的知识（真正的考题都是综合题）\n\n解该题的基本方法是什么？\n\n在计算的过程：字迹工整！！思路清晰（对，恨不得给出注释那种）\n\n```\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210409160908307.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n为数不多还遗留下来的笔记了！\n\n这个阶段不是很困难，但是一定要养成基本的解题素养！要知道常见的题型，以及常见的解法！\n\n长时间的 **Deliberate Practice（刻意练习）** 即可！重复重复再重复。\n\n第三、线性代数我想特别说明：\n\n由于线性代数的抽象性！导致我们看了老师的课程内容 != 我们会做对应的题目，\n\n这个时候我们要**反复地看书、经典的例题**！！！\n\n* 重难点绝对是：**向量，方程组以及特征值、特征方程**~（大题就是这么来的）\n\n# 7/8月份~9月份（强化阶段）：\n\n## 高等数学：汤老师的1800题集、武忠祥老师的系统强化课\n## 线性代数：李永乐老师的系统强化课\n\n**这个阶段就是决定自己到底能不能在数学科目有所突破！有所成长的关键时候了。**\n\n对，这个阶段要**做大量的题，高难度的题，综合的题**\n\n请注意！我这里说的难题，是指**贴合考研数学考场难度的题目**\n\n这个阶段我推荐：\n\n```java\n汤老师的 《接力题集1800》强化篇 （除开基础篇即可）\n\n武忠祥老师的《高等数学辅导讲义》\n\n李永乐老师的《线性代数辅导讲义》\n\n武忠祥、李永乐老师（好像今年他们去到不同的机构）的330重点题\n```\n\n**☆ 强化班：听武忠祥老师的课程！！！**\n\n**☆ 强化班：听线性代数，李永乐老师的课程！！**\n\n其他阶段的课程我不建议反复听，但是：\n\n**强化班的课程很有必要反复听！！！**\n\n听课的同时，一定要加强自己计算的能力！速度，准确度！\n\n强化班不是基础班，是真正要上战场的预备课！练习的题目也都是大量**高于考场的题目**，不要畏难！\n\n这个阶段是绝对适合做高难度的题目的。\n\n* 同时！基础阶段的**标黑题目、多次错误题目**也不能落下他们，因为很有可能是因为自己的**哪一部分的基础不扎实**！\n\n很有必要在这个阶段提一嘴！所谓的多种方法，其实在考场上是不适用的。\n\n**let's put it another way，也就是说你会什么方法，就用什么方法解题。熟悉自己的解题方法，熟练自己的解题方法即可。**\n\n# 10月份国庆~12月份（冲刺阶段）\n\n## ☆☆☆ 汤老师的套题\n## ☆☆☆☆ 李永乐老师团队的套题\n## ☆☆☆ 张宇老师的闭关修炼\n## ☆☆☆☆☆ 李林老师的套题\n\n在大量方法的灌输下，**国庆节之后**，我们可以开始做套题了！\n\n☆☆☆☆☆ 李林老师的四套卷、八套卷\n\n☆☆☆ 汤老师的卷子（不做参考，因为部分题源是1800题集上的题目）\n\n其他的卷子没有做过..不予评价\n\n**请千万记住，不能按照自己做模块题目的思路去做题，一定要强迫自己在规定的时间2~2.5h内做完卷子！！**\n\n**请千万记住，做卷子的目的不是，所有的题目都要做出来！而是拿到对于这张卷子，自己能拿到的分数！**\n\n否则，**只会懊悔自己，为什么自己的分数不如自己所愿！**\n\n就像我的好研友李总说的那样，**你上岸又不是一定要数学150分**！\n\n说的很好，每个人对数学的理解能力不同，**要求自己做对能做对的题目（这点很重要）**\n\n对于实在不会或者算不出来的题目，字迹要工整、思路要清晰**，是老师给你评分，不是你自己的思路给你自己评分！**\n\n一定要老师知道，你每一步的意义。**老师也是** **按点给分，按步骤给分！**\n\n同时，如果有条件。可以看看**数学张宇老师的《闭关修炼》**，为的是拓展自己的数学思维！\n\n注意！越是临近考试，越不能放弃考研数学的本质！刷题。结合**强化阶段的题目以及做套题的错题**\n\n**考研数学真题>模拟套题**\n\n刷题最开始的阶段，请选择 **x年到2010年**，x为自己决定起点年份的卷子！\n\n对于近年的真题卷子，一定要珍惜不能浪费！\n\n* 建议整理真题、部分精彩的模拟题的错题！反复阅读。\n\n那么，到了最后的冲刺阶段：\n\n是一定要多看**李林老师的《四套卷》、《六套卷》**\n\n**By the way 直到考试前的早上！我还在看六套卷的选择题。结果你懂的**\n\n上考场的具体答题顺序建议：**高等数学、线性代数的顺序做题方式。**","tags":["研究生入学考试经验贴"],"categories":["研究生入学考试经验贴"]},{"title":"Ajax请求PostAndGet","url":"/2021/04/05/Java技巧-Ajax请求PostAndGet/","content":"\n# Ajax的Get与Post方法\n\n**请注意，必须引入JQuery**\n\n**CDN代码如下：**\n\n```html\n<script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js\"></script>\n```\n\n## Get方法\n**请注意GET方法一般用于从后台中获取数据，而不是提交数据**\n\n默认是GET方法，速度很快。但是由于**数据将直接以localhost:8080?data1=111&data2=222**的形式\n\n出现在浏览器的地址栏中，\n\n**因而Get方法一般不用于：敏感、隐私的数据传输**\n\n```js\nvar id = $(\"input[name='editor']\").val() \n$.ajax({\t\n\t//后台的请求路径 一般在@Controller层中添加相关注解\n\t//注解一：@RequestMapping(value=\"/show_paper\")或者指定@GetMapping(value=\"/show_paper\")\n\turl:\"show_paper\", \n\tdata:{\"Id\":, id}, \n\ttype:\"GET\",\n\t//注解二：由于指定返回类型为JSON数据\n\t//@ResponseBody\n\tdataType:\"JSON\",\n\tsuccess:function(result){\n\t\t//后台的回调函数中 result中可以找到 后台返回的JSON数据\n\t\tconsole.log(result);\n\t},\n\terror:function () {\n\t\talert(\"抱歉，请求失败，请重新发出请求！\")\n\t}\n});\n```\n\n### 1. **在SpringBoot中，@RestController=@Controller+@ResponseBody**\n\n### 2. **使用Get方式请求时，后台SpringMVC用@RequestParam(\"Id\")来获取**\n\n\n\n## Post方法\n与Get方法不同的是，**Post方法一般用于向服务器提交数据。而不是获取数据！**\n\n因此，我们可以将**需要隐私处理的数据以POST方式以服务器交互：比如账户密码，业务逻辑数据等等**\n\n### 1. 网页中没有form标签\n```js\n\t\tvar username = $(\"input[name='username']\").val() \n\t\tvar password = $(\"input[name='password']\").val() \n        $.ajax({\n\t\t\t//对应的Controller 指定登录\n            url:\"login\",\n\t\t\t//字符串拼接的方式添加参数 后台可用MVC捕捉 或创建Bean对象\n            data:{\"username\":username , \"password\":password}, \n            type:\"POST\",//HTTP请求方式\n            dataType:\"JSON\",//返回值的类型。\n            success:function(result){ //请求事件成功的回调函数\n                console.log(\"JSON:\"+result);\n            },\n            error:function(data){//处理页面出错以后执行的函数\n                console.log(data);\n                window.location.replace(\"./index.jsp\");\n            }\n        });\n```\n\n#### 1. 后台函数参数中可以使用与前端同名的变量\n```java\npublic void fun(String username, String password)\n```\n\n#### 2. 后台可以使用Bean对象 User类 其中属性与前端参数同名\n**UserController.java**\n```java\npublic void fun(User user)\n```\n\n**User.java**\n```java\npublic class User{\n\tprivate Integer id;\n\tprivate String username;\n\tpruvate String password;\n\t\n\t...省略GET、SET方法\n}\n```\n\n### 2.网页中有form标签（更便捷）\n\n**关键代码**\n```js\ndata:$(\"#form\").serialize(),\n```\n\n解释：\n1. 给网页中的**form表单一个id=\"form\"**\n\n2. 在进行AJAX请求时 找到这个表单\n\n3. **对这个表单中的数据进行序列化serialize()**\n\n**注意：后台用对象User来接收，并且前端name中的值需要与Bean对象User中的private属性一一对应**\n\n```js\n$.ajax({\n        url:\"addUser\",\n        type:\"POST\",\n        data:$(\"#form\").serialize(),\n        success:function (result) {\n            showData(result);\n        }\n    });\n```\n","tags":["Java编程实用小技巧"],"categories":["Java编程实用小技巧"]},{"title":"VUE2.0学习笔记-基础语法及其应用-3-SpringBoot+SpringJPA+Vue开发实战","url":"/2021/04/01/VUE学习笔记-基础语法及相应应用-3/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# 原生VUE实战（查询数据）（含SpringBoot+Vue）\n\n## 1.创建VUE项目\n\n**在命令行中输入**\n```js\nvue ui\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401092413748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 2.进入dashboard中 创建项目\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401092523236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 3.进入VUE 工程管家创建工程\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401092946618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n**修改以下参数**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401093021644.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401093044712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401093103753.png)\n创建完之后就可以了。\n\n## 4.从IDEA中导入项目编写前端代码\n打开IDEA->导入项目....\n\n1. 安装Vue.js插件\n2. 修改JavaScript语言为**ECMAScript 6**\n3. 在控制台中输入**npm run serve**来启动项目\n\n# *******************\n\n# （开发从这里开始）VUE前端项目的结构图\n项目结构图如图所示：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401093525334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n通过结构图我们可以知道：\n\n- App.vue 是网页的主界面，页面中包括许多**组件 component**\n- 其中Home、About都是导航栏，但注意**我们导航至Home与About并不代表像传统意义那样，我们去打开一个新的页面。**而是说，**我们在页面上加载不同来源的内容**\n\n具体含义，如图所示：\n\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401094008692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n```html\n<template>\n  <div id=\"nav\">\n    <router-link to=\"/\">Home</router-link> |\n    <router-link to=\"/about\">About</router-link>\n  </div>\n  <router-view/>\n</template>\n```\n\n在上述代码中，我们可以看出**router-link标签负责导航栏 to表示导航路径**\n而具体的**路径配置**是交给项目结构中的\n**router下的index.js来配置**\n\n**index.js中的关键代码如图**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401094243603.png)\n**import代表从那个vue页面中导入相关组件**\n\n而在routes中具体配置相应的**路径，名字，以及组件的名字**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401094402953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n1. 这里的path需要**与前端页面vue中router-link中的to属性参数一一对应**\n2. name可以不填写，但最好与组件名一致\n3. component代表组件 **这里的component需要与import导入语句后面一致**\n\n**而对于VUE3.0，我们建立导航可以用新的写法：**\n\nimport语句可以省略，除了写**path与name**参数之外，\n我们的**component参数**可以变成：\n\n```js\ncomponent:()=>import('../views/About.vue)\n```\n\n# 创建SpringBoot项目\n添加以下依赖：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401095150394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401095205169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401095231868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**1. Lombok\n2. Spring Web\n3. Spring Data JPA\n4. MySQL Driver**\n\n以上四个依赖\n\n1.资源文件中添加数据库文件连接信息：\n```yml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/vuetest?characterEncoding=utf-8&serverTimezone=GMT%2B8\n    username: root\n    password: 123456\n\n  jpa:\n    show-sql: true\n    properties:\n      hibernate:\n        format_sql:true\nserver:\n  port: 8181\n```\n\n1. 连接数据库信息\n2. JPA打印SQL 格式化SQL\n3. 端口8181 避免占用（vue的端口与后台的端口占用）\n\n# 建立实体类\n## User类（注意使用@Entity @Data注解 @Id放在主键属性上）\n**值得注意的是，类中的每个属性，在首字母小写后-必须等于数据库表中的字段名**\n\n```java\nimport lombok.Data;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\n\n@Entity\n@Data\npublic class User {\n    //默认是类名首字母小写 与数据库中的表进行对应\n\n    @Id\n    private Integer id;\n    private String username;\n    private String password;\n    private String email;\n\n}\n```\n\n## ApiResponse 后端前台通用-交互类\n\n```java\n\nimport lombok.Data;\n\n@Data\npublic class ApiResponse{\n\n    private int code;\n    private String message;\n    private Object data;\n\n    public int getCode() {\n        return code;\n    }\n\n    public void setCode(int code) {\n        this.code = code;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public void setMessage(String message) {\n        this.message = message;\n    }\n\n    public Object getData() {\n        return data;\n    }\n\n    public void setData(Object data) {\n        this.data = data;\n    }\n}\n\n```\n\n# 建立Repository层或称DAO层\n## UserRepository类 extends JpaRepository<User, Integer>\n\n**（其中User是对应的类 Integer是主键）利用这种方法，可以避免写一些比如1.查询一条数据2.查询全部数据3.根据主键查询数据...**\n**已经封装好了 常见的DAO层操作**\n\n```java\n\nimport com.example.demo.entity.User;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\n//继承已经封装好了的 JPA不用自己去写简单的 增删改查接口\npublic interface UserRepositery extends JpaRepository<User, Integer> {\n\n}\n```\n\n## 建立RepositoryTest测试类 先看看能不能获得到数据库的数据！\n1. 在类名上右键\n2. Goto中选择test\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20210401145910741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n3. 命名UserRepositeryTest\n```java\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\nclass UserRepositeryTest {\n\n    @Autowired\n    private UserRepositery userRepositery;\n\n    @Test\n    void findAll(){\n        System.out.println(userRepositery.findAll());\n    }\n}\n```\n4. 点击函数名左边的运行！测试看控制台能否读取数据库数据。\n\n# 建立Service层以及对应的Impl实现类\n**值得注意的是 注解@Service应加在实现类上**\n\n## UserService接口\n```java\nimport com.example.demo.entity.User;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\npublic interface UserService {\n    List<User> showAllTheUsers();\n}\n\n```\n\n## UserServiceImpl实现类\n```java\nimport com.example.demo.entity.User;\nimport com.example.demo.repository.UserRepositery;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport java.util.List;\n\n@Service\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserRepositery userRepositery;\n\n    @Override\n    public List<User> showAllTheUsers() {\n        return userRepositery.findAll();\n    }\n}\n```\n\n# 建立Controller层\n## UserController\n```java\nimport com.example.demo.entity.ApiResponse;\nimport com.example.demo.entity.User;\nimport com.example.demo.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.List;\n\n@RestController\n@RequestMapping(value = \"/user\")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @GetMapping(\"/show\")\n    public ApiResponse showAll(){\n        ApiResponse apiResponse = new ApiResponse();\n        List<User> users = userService.showAllTheUsers();\n        apiResponse.setData(users);\n        apiResponse.setMessage(\"返回成功！\");\n        return apiResponse;\n    }\n}\n```\n\n**值得注意的是：@RestController = @Controller + @ResponseBody**后台从数据库中查询到的数据\n以XML或者JSON的格式，返回给前端。\n\n# 解决端口跨域的问题\n**由于我们修改了SPRINGBOOT的端口为8181 而VUE默认是8080**因此，我们需要对SpringBoot做一个配置！\n\n## 新建config.CorsConfig类\n```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\nimport org.springframework.web.filter.CorsFilter;\nimport org.springframework.web.servlet.config.annotation.CorsRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer {\n\n    @Bean\n    public CorsFilter corsFilter() {\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        CorsConfiguration config = new CorsConfiguration();\n        config.addAllowedOriginPattern(\"*\");\n        config.setAllowCredentials(true);\n        // 允许服务端访问的客户端请求头\n        config.addAllowedHeader(\"*\");\n        // 允许访问的方法名,GET POST等\n        config.addAllowedMethod(\"*\");\n        // 对接口配置跨域设置\n        source.registerCorsConfiguration(\"/**\" , config);\n        return new CorsFilter(source);\n    }\n}\n```\n\n到此为止，后台的代码基本算是完成了！\n接下来开始编写\n\n# *******************\n\n# (前端代码开始)User导航栏\n**修改App.vue文件中的template标签为**\n```html\n<template>\n  <div id=\"nav\">\n    <router-link to=\"/\">Home</router-link> |\n    <router-link to=\"/about\">About</router-link>|\n    <router-link to=\"/user\">User</router-link>\n  </div>\n  <router-view/>\n</template>\n```\n\n**同时在router文件夹中的index.js文件中 配置router导航映射**（见文章前部分内容！）\n\n**第一种方式：适用于VUE2（显式声明）**\n```js\nimport User from '../views/User.vue' //建立VUE页面与组件的映射\n\nconst routes = [\n  {\n    path: '/',\n    name: 'Home',\n    component: Home\n  },\n  {\n    path: '/about',\n    name: 'About',\n    component: About  \n  },\n  {\n    path: '/user',\n    name: 'User',\n    component: User //从上方的import User中建立映射\n  }\n]\n```\n\n**第二种方式：建立隐式映射**\n```js\n//注释掉上方的import User from '../views/User.vue' \n\n//但是下方变成：\n{\n    path: '/user',\n    name: 'User',\n    component: ()=>import('../views/User.vue') //边声明组件 边建立映射\n  }\n```\n\n# 创建User.vue 具体显示内容\n在views文件夹下创建User.vue文件：\n\n## Style CSS样式\n```css\n<style scoped>\n    table{\n        font-size:25px;\n    }\n    table{\n        table-layout:fixed;\n        empty-cells:show;\n        border-collapse: collapse;\n        margin:0 auto;\n    }\n    td{\n        height:20px;\n    }\n</style>\n```\n\n## JavaScript 利用axios与后台交互\n### 第一步、添加axios插件（并修改一些内容）\n**首先，在命令行中输入**\n\n```js\n vue add axios\n```\n\n然后找到**项目结构图中的plugins文件夹下面的axios.js**\n粘贴以下代码：\n\n```js\n\"use strict\";\n\nimport Vue from 'vue';\nimport axios from \"axios\"\n\n// Full config:  https://github.com/axios/axios#request-config\n// axios.defaults.baseURL = process.env.baseURL || process.env.apiUrl || '';\n// axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n// axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n\nlet config = {\n  // baseURL: process.env.baseURL || process.env.apiUrl || \"\"\n  // timeout: 60 * 1000, // Timeout\n  // withCredentials: true, // Check cross-site Access-Control\n};\n\nconst _axios = axios.create(config);\n\n_axios.interceptors.request.use(\n  function(config) {\n    // Do something before request is sent\n    return config;\n  },\n  function(error) {\n    // Do something with request error\n    return Promise.reject(error);\n  }\n);\n\n// Add a response interceptor\n_axios.interceptors.response.use(\n  function(response) {\n    // Do something with response data\n    return response;\n  },\n  function(error) {\n    // Do something with response error\n    return Promise.reject(error);\n  }\n);\nexport default _axios\n```\n\n## 第二步、引用axios并发起get请求\n```js\n<script>\n    import axios from \"../plugins/axios\"; //引用axios \n    \n    export default {\n        name: \"User\",\n        data(){\n            return{\n                // 具体的变量\n                msg: 'Hello, Vue!',\n                users:[]\n            }\n        },\n        created(){  //当网页准备就绪时\n            const _data = this //利用这个this好使得在回调函数中 调用回调函数外的data中的数据\n            axios('http://localhost:8181/user/show').then(function (response) {\n                _data.users = response.data.data //将controller返回给后台的data 赋给data中的数组\n            }) //跟ajax一样 直接请求8181端口下的请求路径 注意 已经配置了跨域！不用担心\n        }\n    }\n</script>\n```\n\n## 第三步、将数据显示在网页中\n\n## template HTML内容\n```html\n<template>\n    <!--template中写html代码 且只能有一个根div节点-->\n    <div>\n        <table>\n            <tr>\n                <td>id</td>\n                <td>用户名</td>\n                <td>密码</td>\n                <td>邮箱</td>\n            </tr>\n            <tr v-for=\"user of users\"> \n            <!--利用for循环 加载data中users数组中数据-->\n                <td >{{user.id}}</td>\n                <td >{{user.username}}</td>\n                <td >{{user.password}}</td>\n                <td >{{user.email}}</td>\n            </tr>\n        </table>\n    </div>\n</template>\n```\n\n到此为止。一个简单的**查询数据库所有数据的请求就完成了**\n\n项目效果图如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021040115270020.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n","tags":["前端框架学习"],"categories":["前端框架学习"]},{"title":"VUE2.0学习笔记-基础语法及相应应用-1-基本语法","url":"/2021/03/28/VUE学习笔记-基础语法及相应应用-1/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n \n# Vue开头好戏-小案例\n## Hello World\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Hello World</title>\n    <script src=\"https://unpkg.com/vue@next\"></script>\n</head>\n\n<body>\n    <div id=\"app\"></div>\n</body>\n<script>\n    Vue.createApp({\n        template: '<div>Hello World</div>'\n    }).mount(\"#app\")\n</script>\n</html>\n```\n\n## 面向数据编程->实现计时器\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>计数器</title>\n    <script src=\"https://unpkg.com/vue@next\"></script>\n</head>\n\n<body>\n    <div id=\"app\"></div>\n</body>\n\n<script>\n    Vue.createApp({\n        data(){\n            return {\n                counter:1 \n            }\n        }, //需要一个mounted方法 自动执行\n        mounted(){ //页面渲染完 就自动执行\n            setInterval(()=>{\n                this.$data.counter += 1\n            }, 1000) //周期执行\n        },\n        template: '<div>{{counter}}</div>' //字面量 双括号 放JS表达式或者变量\n    }).mount(\"#app\")\n</script>\n</html>\n```\n### mounted()表示当文档加载时 就执行该函数\n### data(){}中存放类似 全局数据\n### template:放入全局数据 {{val}}取值\n\n\n## 绑定数据&事件->编写方法\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>象牙山洗脚城</title>\n    <script src=\"https://unpkg.com/vue@next\"></script>\n</head>\n\n<body>\n    <div id=\"app\"></div>\n</body>\n\n<script>\n    Vue.createApp({\n        data(){\n            return {\n                content:\"\", \n                num:0, \n                Menu:'真空套餐 帝王套餐 夏日套餐 学生套餐',\n                isShowMenu: false //标志不展示\n            }\n        },\n        methods:{\n            welcomeBtnClick(){\n                this.content = \"欢迎光临, 贵宾\" + ++this.num + \"位\"\n            },\n            byeBtnClick(){\n                if(parseInt(this.num) == 0){\n                    alert(\"操作有误，无人可离.\")\n                    return;\n                }\n                this.content = \"还剩贵宾\" + --this.num + \"位, \"+\"欢迎下次光临!\"\n            },\n            hideBtnClick(){\n                this.isShowMenu = !this.isShowMenu\n            }\n        },\n        template: //波浪 代表多行 v-on:click=\"\" 表示对某个标签绑定某个函数 \n                  //{{content可以看做是数据绑定 从data中取出的数据}}\n        `   \n            <div>\n                <div>{{content}}</div> \n                <button v-on:click=\"welcomeBtnClick\">有顾客来</button> &nbsp; \n                <button v-on:click=\"byeBtnClick\">顾客离开</button>\n                <div>\n                    <div v-if=\"isShowMenu\">{{Menu}}</div>    \n                    <button v-on:click=\"hideBtnClick\">显示/隐藏套餐</button>\n                </div>\n            </div>\n        ` //字面量 双括号 放JS表达式或者变量\n    }).mount(\"#app\")\n</script>\n</html>\n```\n### data(){} 中可以放多个数据\n### template: ``波浪中可以放多行的 前端代码\n### v-on:click=\"function\" 指定点击事件\n### <div v-if=\"boolData\">{{data}}<div>  当变量boolData为真时 变量data才会显示出来\n### parseInt(val) 可以将val值转换为数值型数据\n\n## for循环增加佳丽（技师）\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>for循环遍历佳丽</title>\n    <script src=\"https://unpkg.com/vue@next\"></script>\n</head>\n\n<body>\n    <div id=\"app\"></div>\n</body>\n\n<script>\n    Vue.createApp({\n        data(){\n            return {\n                waitresses: ['小红', '小丽', '小芳']\n            }\n        },\n        methods:{\n\n        },\n        template: \n        `   \n            <div>\n                <div>\n                    <ul>\n                        <li v-for=\"(waitress, index) of waitresses\">[{{index}}]{{waitress}}</li>\n                    </ul>    \n                </div>\n            </div>\n        ` \n    }).mount(\"#app\")\n</script>\n</html>\n```\n#### v-for=\"(item, index) of list\" 属性 代表从数组list中遍历每个item且附上索引 index\n\n## 将手动输入的值 添加佳丽\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>手动输入增加佳丽数据</title>\n    <script src=\"https://unpkg.com/vue@next\"></script>\n</head>\n\n<body>\n    <div id=\"app\"></div>\n</body>\n\n<script>\n    Vue.createApp({\n        data(){\n            return {\n                waitresses: ['小红', '小丽', '小芳'],\n                inputWaitress:''\n            }\n        },\n        methods:{\n            addWaitress(){\n                this.waitresses.push(this.inputWaitress)                \n\t\t\t\tthis.inputWaitress = ''\n            }\n        },\n        template: //波浪 代表多行 v-on:click=\"\" 表示对某个标签绑定某个函数 \n                  //{{content可以看做是数据绑定 从data中取出的数据}}\n        `   \n            <div>\n                <div>\n                    <input v-model=\"inputWaitress\" /> <button v-on:click=\"addWaitress\">增加技师</button>\n                </div>\n\n                <div>\n                    <ul>\n                        <li v-for=\"(waitress, index) of waitresses\">[{{index}}]{{waitress}}</li>\n                    </ul>    \n                </div>\n            </div>\n        ` //字面量 双括号 放JS表达式或者变量\n    }).mount(\"#app\")\n</script>\n</html>\n```\n#### v-model=\"stringVal\" 定义输入的值 传给变量stringVal \n#### 同时给按钮绑定函数 将对应输入的值 尾添至数组中（同时输入框值清空）\n\n# Vue重要概念：组件式开发\n### 什么是组件？组件就像是 “网页窗体中-一个又一个不同的Section” 网页上所看到的任何东西 都可以写成组件\n### 比如在上个例子中的->增加佳丽 就可以利用这种思想来-> 组件式开发\n### 把可以抽出来或者说可能重复被用到的代码块 抽离出来\n\n## 小案例：组件式开发-洗脚城系统\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>手动输入增加佳丽数据</title>\n    <script src=\"https://unpkg.com/vue@next\"></script>\n</head>\n\n<body>\n    <div id=\"app\"></div>\n</body>\n\n<script>\n    //app是一个可以将自己的内容 挂载在id为app区域上的变量\n    const app = Vue.createApp({\n        data(){\n            return {\n                waitresses:['小红', '小芳', '小丽'],\n                inputValue:' '\n            }\n        },\n        methods:{\n            add(){\n                this.waitresses.push(this.inputValue)\n                this.inputValue = ' '\n            }\n        },\n        template: `\n            <my-title/>   \n\n            <input v-model=\"inputWaitress\"/>\n            <button v-on:click=\"add\">添加佳丽</button>\n\n            <div>\n                <ul>\n                    <my-waitress \n                        v-for=\"(item, index) of waitresses\"\n                        v-bind:item=\"item\"\n                        v-bind:index=\"index\"\n                    />\n                </ul>    \n            </div>\n        `\n    })\n \n    app.component('my-title',{\n        template:'<h1 style=\"text-align=center\">洗脚城</h1>'\n    })\n\n    //抽离出上个例子中 动态地渲染 参数为props列表中的值\n    app.component('my-waitress', {\n        props:['item', 'index'],\n        template:`<li>[{{index}}] {{item}}</li>`\n    })\n\n    app.mount(\"#app\")\n</script>\n</html>\n```\n## VUE的组件式开发之总结：\n1. 在代码中，首先将app作为一个const常量（不可更改） 创建出来->  const app = Vue.createApp({})\n2. 然后编写这个app常量的各个组件- app.component('name',{data})\n3. ....重复编写组件\n4. 最后选择把这个app挂载在 网页中的某个区域（可以id选择器，class选择器等..) app.mount(\"#id_name\")\n\n### 重要属性:\n#### 1.组件中的template:''/ ``分别填写单行、多行HTML\n#### 2.v-on:click=\"fun_name\" 绑定单击事件\n#### 3.v-for=\"(item, index) of list\" 利用for循环遍历数组\n#### 4.v.bind->绑定这个自定义组件中的props参数数组中的参数\n\n## VUE的createApp()方法 与 mount()方法讲解\n```js\nconst app = Vue.createApp({})\napp.mount(\"#app\")\n```\n\n1. createApp就是**Vue创建一个应用**\n2. mount方法就是**挂载到某一个DOM节点**上\n\n## VUE的设计模式：mvvm->model, view, viewModel\nVue的编程设计模式应该叫做mvvm的设计模式。什么叫做mvvm？它首先是面向数据的编程，程序中定义了数据，然后定义了模板，Vue就可以把数据和模板自动进行关联。最后挂载到真实的DOM上，展示给用户。\n\n```js\nmvvm解释: 第一个m代表model数据，第一个v代表view视图，最后两个字幕vm代表viewModel视图数据连接层。\n```\n\n### 小案例认识 “数据” “模板” “数据视图连接层”\n```js\n<script>\n    const app = Vue.createApp({\n        data() {\n            return {\n                message: 'vincent99013.github.io'   //1.在这里定义了数据，也就是`model`数据\n            }\n        },\n        template: \"<h2>{{message}}</h2>\" //2.在这里定义了模板，也就是`view`，\n        //定义后的自动关联，就叫做`vm`，viewModel数据视图连接层。\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n1. data(){} 中放数据\n2. template:\"\" 中放模板view 即HTML代码\n3. {{message}}使得数据与视图之间得以连接\n\nmodel数据，是我们自己定义的，view模板也是我们自己定义的，但是vm是Vue自动给我们关联的。\n\n当我们明白了什么是mvvm后，你就知道为什么我们给根组件起名vm了。\n\n当我们获取了vm根节点后，其实就可以操作里边的数据了。比如在控制台中输入下面的代码：\n```js\nvm.$data.message = 'vincent'\n```\n\n如果在app里 我们使用this指针操作data数组中某个变量\n\n## 自动执行函数的理解\n\n说起自动执行函数，还要从**被动执行函数**说起。比如给网页某一个元素一个点击事件：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Demo7</title>\n    <script src=\"https://unpkg.com/vue@next\"></script>\n</head>\n\n<body>\n    <div id=\"app\"></div>\n</body>\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '弹窗成功'\n            }\n        },\n        methods: {\n            clickFun() {\n                alert(this.message)\n            }\n        },\n        template: `<div>\n                        <button v-on:click=\"clickFun\">点击我弹窗（被动事件）</button>\n                   </div>`\n    })\n\tapp.mount(\"#app\")\n</script>\n</html>\n```\n\n在面向数据编程中，此时给该按钮加入点击事件。**只有当该按钮被点击时，事件才会被触发。这就是被动函数的概念！**\n\n而对于自动执行函数..不需要相应的点击事件才触发\n\n## 自动执行函数-> mounted() \n```html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Demo7</title>\n    <script src=\"https://unpkg.com/vue@next\"></script>\n</head>\n\n<body>\n    <div id=\"app\"></div>\n</body>\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '弹窗成功'\n            }\n        },\n\t\tmounted(){\n\t\t\talert('自动弹出的内容')\n\t\t},\n        methods: {\n\t\t\t\n        },\n        template: `<div>\n\t\t\t\t\t\t<h1>不用点击 自动弹窗</h1>\n                   </div>`\n    })\n\tapp.mount(\"#app\")\n</script>\n</html>\n```\n\n在网页加载完成后，自动进入mounted函数中，即自动执行里面的代码块。\n\n## （很重要！）VUE的所有生命周期 \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210329210051193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 重要的四个基本生命周期函数\n1. beforeCreate(): 在实例生成之前会自动执行的函数\n2. created(): 在实例生成之后会自动执行的函数\n3. beforeMount(): 在模板渲染完成之前执行的函数\n4. mounted(): 在模板渲染完成之后执行的函数\n\n那么，现在用具体的例子来演示一下这四个基本周期函数吧：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Demo7</title>\n    <script src=\"https://unpkg.com/vue@next\"></script>\n</head>\n\n<body>\n    <div id=\"app\"></div>\n</body>\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '弹窗成功'\n            }\n        },\n\t\tbeforeCreate() {\n\t\t\tconsole.log('beforeCreate')\n\t\t},\n\t\tcreated() {\n\t\t\tconsole.log('created')\n\t\t},\n\t\tbeforeMount() {\n\t\t\tconsole.log('beforeMount')\n\t\t},\n\t\tmounted() {\n\t\t\tconsole.log('mounted')\n\t\t},\n        methods: {\n\t\t\t\n        },\n        template: `<div>\n\t\t\t\t\t\t<h1>不用点击 自动弹窗</h1>\n                   </div>`\n    })\n\tapp.mount(\"#app\")\n</script>\n</html>\n```\n\n浏览器的控制台：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210329210625512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**可以看到：执行流程是: beforeCreate -> created -> beforeMount -> mounted**\n\n## beforeUpdate和updated生命周期函数\n这两个周期函数是在VUE中的data数据发生变化时，才会被执行，**一个是在变化之前，一个是在变化之后。**\n\t\n用一个改变data中变量message的值的例子来说明：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Demo7</title>\n    <script src=\"https://unpkg.com/vue@next\"></script>\n</head>\n\n<body>\n    <div id=\"app\"></div>\n</body>\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '初始值'\n            }\n        },\n\t\tbeforeUpdate(){\n\t\t\tconsole.log('当前的值未被改变！')\n\t\t},\n\t\tupdated(){\n\t\t\tconsole.log('当前的值已被改变!')\n\t\t},\n\t\tmethods: {\n\t\t\tclickFun(){\n\t\t\t\tthis.message = '恭喜您，成功更改message的值！'\t\t\n\t\t\t}\n\t\t},\n        template: `<div>\n\t\t\t\t\t\t<div>{{message}}</div>\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<button v-on:click=\"clickFun\">点击改变data中的数据值</button>\n\t\t\t\t\t\t</div>\n                   </div>`\n    })\n\tapp.mount(\"#app\")\n</script>\n</html>\n```\n\n## beforeUnmount和unmounted周期函数\n这两个生命周期函数是在VUE销毁时自动执行的函数，一个是销毁前执行，一个是销毁后执行。\nbeforeUnmount(): 当VUE应用失效时，会自动执行。\nunmounted():当VUE应用失效，且DOM完全销毁之后，会自动执行。\n\n代码演示如下：\n```js\n\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '初始值'\n            }\n        },\n\t\tbeforeUnmount(){\n\t\t\tconsole.log('beforeUnmount！')\n\t\t},\n\t\tunmounted(){\n\t\t\tconsole.log('unmounted!')\n\t\t},\n\t\tmethods: {\n\t\t\tclickFun(){\n\t\t\t\tthis.message = '恭喜您，成功更改message的值！'\t\t\n\t\t\t}\n\t\t},\n        template: `<div>\n\t\t\t\t\t\t\n                   </div>`\n    })\n\tapp.mount(\"#app\")\n\tapp.unmount()\n</script>\n```\n\n可以看到，页面在调用unmount函数前后，控制台会打印：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210330090649903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n在**app.unmount()**函数执行后，在**beforeUnmount()**方法里，DOM还是有内容的，然后到了**unmounted**方法中，就已经没有任何的DOM内容了。\n\n## VUE中最重要的概念-八大生命周期\n### 创建，挂载，更改，非挂载\n记住八大生命周期，可回想安卓中的生命周期函数！\n各有两个**un-XX**与**xx-ed**\n\n如图所示：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210330091336939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 插值表达式与v-bind数据绑定\n在之前的代码类似 **content** 这种，正确叫法是 **插值表达式** 当然也可以叫做 **字面量**\n\nJSP中从后台SpringMVC中的ModelAndView中存储的数据 利用EL表示JSP网页取值一样\n\n```js\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {message: '数据'}\n        },\n        template: \"<div>{{message}}</div>\"\n    })\n\tapp.mount(\"#app\")\n</script>\n```\n\n在以上代码中，我们利用面向数据编程的**插值表达式** {{message}} 在模板template当中显示出data数组中的数据。\n\n但有时可能我们需要显示的一些数据变量，中含有HTML标签，我们想**在网页中以标签的形式显示出来而不是字符串的内容（即不会把<>这样的内容也显示出来），这样我们就需要用到** v-html=\"message\" ，**需要注意的是，我们需要用多行代码块`而不是单行代码块\"**\n\n具体代码如下：\n```js\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '<i>斜体的内容（不含标签）<i>'\n            }\n        },\n        template: `<div v-html=\"message\"></div>`\n    })\n\tapp.mount(\"#app\")\n</script>\n```\n\n## VUE中的数据双向绑定\n在模板template中引用的data数据，被绑定到模板对应mount挂载的网页区域中。当data中的数据发生改变时，对应网页中显示出来的内容也会发生改变。这就是双向数据绑定，**而有时我们只需要这样的数据，让它只在第一次渲染出来，而之后不再跟随data中的数据的值变化而变化。**这样的思想，我们可以用v-once属性完成！\n\n代码如下：\n```js\n\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: 'message数据的初始内容'\n            }\n        },\n\t\tmethods:{\n\t\t\tfun(){\n\t\t\t\tthis.message = '更改数据中...'\n\t\t\t}\n\t\t},\n        template: `\n\t\t<div>\n\t\t\t<div v-once>只会显示初始数据：{{message}}</div>\n\t\t\t<div><button v-on:click=\"fun\">点击我但不会改变message的初始值</button>\t\t\t\t\t</div>\n\t\t</div>`\n    })\n\tapp.mount(\"#app\")\n</script>\n```\n\n在上述代码中，我们无论点击多少次按钮，带有v-once属性的div中的字面量数据，绝对不会再次渲染新值\n\n## 插值表达式中-使用JS代码（三目运算）\n比如我们要实现这么一个功能：这里有一个灯（不是开着的，就是关着的），我们利用嵌入JS代码至插值表达式中，实现开关灯。\n\n```js\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tSwitch: true //我们默认灯是开着的\n            }\n        },\n\t\tmethods:{\n\t\t\tfun(){\n\t\t\t\tthis.Switch = !this.Switch //点击一下 就改变一下灯的状态\n\t\t\t}\n\t\t},\n        template: `\n\t\t<div>\n\t\t\t<div>状态：{{Switch? '灯已关闭': '灯已打开'}}</div>\n\t\t\t<div><button v-on:click=\"fun\">开关灯</button></div>\n\t\t</div>`\n    })\n\tapp.mount(\"#app\")\n</script>\n```\n\n**在某些情况下，我们需要这种“非真即假”的场景，来为我们改变一些元素的状态！**\n\n## v-bind 给某个元素绑定属性\n假设我们data数组中有message这个数据，而我们想要某个元素有一个title属性，同时这个**title**的值为message的值。（联想我们插入HTML标签，而不是标签变成了字符串）\n\n代码如下：\n```js\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '数据内容'\n            }\n        },\n        template: `\n\t\t<div v-bind:title = \"message\" > {{message}} </div>`\n    })\n\tapp.mount(\"#app\")\n</script>\n```\n\n**此时我们将鼠标移到对应的数据内容上，悬停出来的内容即为title，而title的值也是数据内容。说明，我们利用v-bind属性给这个元素赋值了message变量中的内容。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210330101906688.png)\n\n## v-on 的基本用法及简写\nv-on 是用来绑定响应事件的，在之前提到：\n\n```js\nmethods:{\n\talert('显示数据中...')\n},\ntemplate:\" <button v-on:click=\"fun\">点击我弹窗显示数据</button> \"\n```\n\n**现在可以利用@click来代替：v-on:click事件**\n\n也就是说 **@事件=v-on:事件**\n\n完整代码：\n```js\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '数据内容'\n            }\n        },\n\t\tmethods: {\n\t\t\tfun(){\n\t\t\t\talert(this.message)\n\t\t\t}\n\t\t},\n        template: \n\t\t`\n\t\t\t<button @click=\"fun\">点击我弹窗显示数据</button>\n\t\t`\n    })\n\tapp.mount(\"#app\")\n</script>\n```\n\n效果图如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210330190500540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n\n## v-bind绑定的基本用法及简写\n\n与v-on一样，v-bind也可以用来绑定属性。基本用法是：\n\n:title=\"val_name(变量名)\"，即绑定title为data中的变量名。\n\n```js\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '数据内容',\n\t\t\t\ttitle: ':title生成的按钮标题'\n            }\n        },\n\t\tmethods: {\n\t\t\tfun(){\n\t\t\t\talert(this.message)\n\t\t\t}\n\t\t},\n        template: \n\t\t`\n\t\t\t<button @click=\"fun\" :title=\"title\">点击我弹窗显示数据</button>\n\t\t`\n    })\n\tapp.mount(\"#app\")\n</script>\n```\n效果图如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210330190953268.png)\n## 模板动态参数\n### 属性动态参数\n对于绑定的title属性，我们可以看成是一个动态变量**parameter**里面，赋值为**title**，title的值为相应的变量名。\n\n所以我们可以利用这样的形式来写：\n**简写bind函数时，我们不用title（:title），我们把title抽离出来，看成是一个parameter变量的值**\n\n代码如下：\n```js\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '数据内容',\n\t\t\t\tname: 'title',\n\t\t\t\tval: '标题值'\n            }\n        },\n\t\tmethods: {\n\t\t\tfun(){\n\t\t\t\talert(this.message)\n\t\t\t}\n\t\t},\n        template: \n\t\t`\n\t\t\t<button @click=\"fun\" :[name]=\"val\">点击我弹窗显示数据</button>\n\t\t`\n    })\n\tapp.mount(\"#app\")\n</script>\n```\n\n### 事件动态绑定\n与属性动态绑定一样，我们可以**将点击这个动作抽象成一个变量event**，其值为click作为参数。对应的值不变！仍为data中的变量。\n\n```html\n<button @[event]=\"fun\" :[name]=\"val\">点击我弹窗显示数据</button> \n```\n\n```js\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '数据内容',\n\t\t\t\tname: 'title',\n\t\t\t\tval: '标题值',\n\t\t\t\tevent: 'click'\n            }\n        },\n\t\tmethods: {\n\t\t\tfun(){\n\t\t\t\talert(this.message)\n\t\t\t}\n\t\t},\n        template: \n\t\t`\n\t\t\t<button @[event]=\"fun\" :[name]=\"val\">点击我弹窗显示数据</button>\n\t\t`\n    })\n\tapp.mount(\"#app\")\n</script>\n```\n\n通过事件绑定，属性绑定，这样我们可以动态切换对应的事件。只需要更改this.event以及this.parameter的值\n\n\n## VUE阻止默认事件（比如表单的默认提交）\n最常见的事件就是阻止表单的默认提交，**比如在表单的数据还没有完全验证成功情况下。是必须阻止表单默认提交的！**\n\n通常我们的代码会像这样：\n```js\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '数据内容',\n\t\t\t\tname: 'title',\n\t\t\t\tval: '标题值',\n\t\t\t\tevent: 'click'\n            }\n        },\n\t\tmethods: {\n\t\t\thandleButton(e){\n\t\t\t\te.preventDefault()\n\t\t\t}\n\t\t},\n        template: \n\t\t`\n\t\t\t<form action=\"https://www.baidu.com\">\n\t\t\t\t<button type=\"submit\" @click=\"handleButton\">提交数据</button>\n\t\t\t</form>\n\t\t`\n    })\n\tapp.mount(\"#app\")\n</script>\n```\n\n1. 我们给一个自定义的阻止事件handleButton(e)\n2. 这个e看做是触发事件的**源按钮** 看做是**哪一个按钮触发了这个事件，就指哪一个按钮**\n3. 调用**e.preventDefault()**函数以阻止默认事件\n\n**对于那些经常要做的阻止操作而言，这种方法太低效了。**\n\n因而，VUE给我们提供了一个**模板修饰符**，直接可以阻止默认行为，写法如下：\n\n```html\n<form action=\"https://www.baidu.com\" @click.prevent=\"handleButton\">\n\t<button type=\"submit\">提交<button>\n</form>\n```\n上述代码中:**@click.prevent=\"阻止之后 转而进入的事件**\n完整代码如下：\n\n```js\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tmessage: '数据内容',\n\t\t\t\tname: 'title',\n\t\t\t\tval: '标题值',\n\t\t\t\tevent: 'click'\n            }\n        },\n\t\tmethods: {\n\t\t\thandleButton(){\n\t\t\t\talert('拦截成功...')\n\t\t\t}\n\t\t},\n        template: \n\t\t`\n\t\t\t<form action=\"https://www.baidu.com\" @click.prevent=\"handleButton\">\n\t\t\t\t<button type=\"submit\" >提交数据</button>\n\t\t\t</form>\n\t\t`\n    })\n\tapp.mount(\"#app\")\n</script>\n```\n\n## VUE中模板的条件判断 v-if\n前面我们提到了三目运算符，结合例子说明：\n```js\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tnum: 10,\n\t\t\t\tinputNum:'',\n\t\t\t\tflag: false,\n\t\t\t\tmessage: ''\n            }\n        },\n\t\tmethods: {\n\t\t\thandleButton(){\n\t\t\t\tthis.message = (parseInt(this.inputNum)>this.num)? '你输入的数比10大': '并没有比10大'\n\t\t\t}\n\t\t},\n        template: \n\t\t`\n\t\t\t<input v-model=\"inputNum\"/>\n\t\t\t<button @click=\"handleButton\">查询</button>\n\t\t\t<div>{{message}}</div>\n\t\t`\n    })\n\tapp.mount(\"#app\")\n</script>\n```\n\n**当输入的数字大于10或者小于10时 都会提示**\n\n现在从这种三目运算符到v-if的过渡：\n\n**如果有这么一个场景，当输入的值为“蓝色”时，标签的背景是蓝色，如果是红色，背景是红色。**\n\n代码实现如下：\n```html\n\n<script>\n\tconst app = Vue.createApp({\n        data() {\n            return {\n\t\t\t\tnum: 10,\n\t\t\t\tinputValue:'',\n\t\t\t\tflag: false,\n\t\t\t\tmessage: ''\n            }\n        },\n\t\tmethods: {\n\t\t\thandleButton(){\n\t\t\t\tthis.message = this.inputValue\n\t\t\t}\n\t\t},\n        template: \n\t\t`\n\t\t\t<input v-model=\"inputValue\"/>\n\t\t\t<button @click=\"handleButton\">查询</button>\n\t\t\t<div v-if=\"message=='红色'\" class=\"red\">这片区域是红色</div>\n\t\t\t<div v-if=\"message=='蓝色'\" class=\"blue\">这片区域是蓝色</div>\t\t\t\n\t\t`\n    })\n\tapp.mount(\"#app\")\n</script>\n\n<style type=\"text/css\">\n\t.red{color:red}\n\t.blue{color:blue}\n</style>\n```\n\n## VUE中的computed域\n\n**对应一般的方法而言，若页面重新渲染；则相应需要计算的方法，会再进行一次计算。**\n\n比如，现data数据中有val，和content两个变量；\n有一个涉及val变量的方法，计算val*10的值。\n\n现在若在普通方法中，更改**同在data中的变量content**，那么val变量会重新计算一遍。\n\n现在将代码放入computed域中，**现在更改content的值时涉及val的方法不会再执行**\n\n## VUE中的watch域\n\nWatch译为监听，则我们可以将一些需要**监听数据变化，并对这些变化作出一些操作的数据源**，\n放在Watch域中。**而且可以获取到 改变前的值&改变后的值**\n\n```js\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                num: 1\n            }\n        },\n        computed:{\n            \n        },\n        methods:{\n            fun(){\n                this.num--;\n            }\n        },\n        watch:{\n            num(current, prev){\n                alert(\"你的num数据从\" + prev + \"变化到了\" + current)\n            }\n        },\n        template:`\n            <div>{{num}}</div>\n            <div><button @click=\"fun\">点我减一</button></div>\n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n\n## VUE中的模板样式绑定详细讲解\n\n### 单个样式动态绑定\n现有三种样式，我们动态地引用这三个样式：\n\n```css\n.red{color:red}\n.green{color:green}\n.back{background-color:orange}\n```\n\n完整代码如下：\n```html\n\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                className:'red'\n            }\n        },\n        template:`\n        <h1 :class=\"className\">初始字体颜色为红色</h1>\n        <h2>您可以通过在控制台中修改vm.$data.className来动态引用class</h2>\n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n\n<style>\n.red{color:red}\n.green{color:green}\n.back{background-color: orange;}\n</style>\n```\n\n**其中利用动态绑定:class=\"className\"，而在data中的变量className值代表真正的class值**\n因此，我们可以在控制台中修改：<i>vm.$data.className='green'</i>\n\n使得我们在**style**标签中的CSS样式能够生效。\n\n### 对象形式绑定多个样式\n\n**在上个例子中，我们有字体颜色.red类，有背景颜色.back类**\n现在我们想要绑定这个DOM元素，既让它有样式.red，又让它有样式.back\n则我们可以利用一个自定义对象classObject，将想要生效的样式置为true\n\n完整代码如下：\n```js\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                className:'red',\n                classObject:{'red':true, 'back':true}\n            }\n        },\n        template:`\n        <h1 :class=\"cl assObject\">初始字体颜色为红色</h1>\n        <h2>您可以通过在控制台中修改vm.$data.className来动态引用class</h2>\n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n\n**其中，我们看到，相应的red、back样式类都为true**\n\n## VUE中的for循环（以及如何避免重新渲染）\n\n在之前的for循环，我们每次都是重新渲染页面：\n**如果有含初始数据的数组，我们只需要重新渲染“新数据”的内容**\n每次添加数据 我们可以避免重新渲染之前的已有数据\n\n**利用 :key=\"index+item\" 绑定key属性！**\n\n完整代码如下：\n```js\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                list:['初始值']\n            }\n        },\n        methods:{\n            fun(){\n                this.list.push('尾添数据')\n            }\n        },\n        template:`\n            <button @click=\"fun\">点我</button>\n            <ul>\n                <li v-for=\"(item, index) in list\" :key=\"index+item\"> \n                    [{{index}}]{{item}}\n                </li>    \n            </ul>\n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n\n## VUE中的事件对象-event\n\n### 无参函数\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                list:['初始值']\n            }\n        },\n        methods:{\n            fun(event){\n                console.log(event)\n            }\n        },\n        template:`\n            <button @click=\"fun\">点我</button>\n           \n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n\n#### tips: 我们用event.target看到事件触发源\n\n### 含参函数\n\n**当我们有参数时，调用函数若想用event**，\n\n此时应用**click(para1, para2 ..., $event)**\n\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n            }\n        },\n        methods:{\n            fun(num, event){\n                alert(++num)\n                console.log(event.target)\n            }\n        },\n        template:`\n            <button @click=\"fun(1, $event)\">点我+1</button>\n           \n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n\n## VUE中一个按钮绑定两个方法\n\n有时，我们可能需要同时对一个按钮绑定一个事件。**并同时执行两个方法fun1与fun2**\n\n**@click=\"fun1(), fun2()\"**可以完成这个功能。会顺序执行这两个方法！\n\n完整代码如下：\n```js\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n            }\n        },\n        methods:{\n            fun1(){\n                alert(\"小明取走100元\")\n            },fun2(){\n                alert(\"银行少了100元\")\n            }\n        },\n        template:`\n            <button @click=\"fun1(), fun2()\">点我交易</button>\n           \n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n\n## VUE中的事件修饰符\n\n**VUE中有六种常见的事件修饰符**他们分别是：\n\n1. stop\n2. prevent\n3. capture\n4. self\n5. once\n6. passive\n\n### 停止事件的冒泡机制-事件修饰符@click.stop\n\n**所谓冒泡机制（就像水里面的泡泡，DOM树中的事件就像泡泡一样向上逐个被捕捉！）**\n\n比如网页结构是！\n```html\n\t<body>\n\t\t<h2>\n\t\t\t<button>\n\t...省略闭合标签\n```\n\n**那么此时给button加的事件，会自底向上得逐个被各个标签捕获**\n也就是说，若给h2添加点击事件，给button添加点击事件。\n\n最终根据冒泡机制，**会执行h2的点击事件**。\n完整代码如下：\n```js\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                count: 1\n            }\n        },\n        methods:{\n            divClick(){\n                alert('最终被标签捕捉到了！')\n            },\n            btnClick(){\n                this.count++\n                console.log(this.count)\n            }\n        },\n        template:`\n            <div @click=\"divClick\">\n                <button @click=\"btnClick\">点击我体验冒泡机制</button>\n            </div>    \n        \n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n\n而我们可以用**@click.stop=\"btnClick\"**给下边的按钮添加，避免它往上冒泡被捕获到。\n\n### prevent修饰符：阻止默然行为的修饰符@click.prevent\n\n例如阻止form表单的默认提交行为。\n```html\n<form @click.prevent=\"handleButton\">\n\n</form>\n```\n\n**上述代码可以避免自动form自动提交，转而转向handleButton函数**\n\n### capture修饰符，冒泡反方向(自顶向下)\n### once修饰符，事件只执行一次\n\nonce修饰符修饰的事件，只会执行一次。\n\n完整代码如下：\n```js\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                count: 1\n            }\n        },\n        methods:{\n            divClick(){\n                alert('最终被标签捕捉到了！')\n            },\n            btnClick(){\n                this.count++\n                console.log(this.count)\n            }\n        },\n        template:`\n            <div @click=\"divClick\">\n                <button @click.once=\"btnClick\">只会自增一次</button>\n            </div>    \n        \n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n\n### passive修饰符：解决滚动时性能的修饰符\n\n## VUE中的MOUSE、KEYBOARD鼠标&键盘按键绑定\n\n**在某种场景下，我们需要按下Enter键登录&注册**\n**我们需要在鼠标hover悬停于某个元素上方时，进行交互**\n\n这样的操作还涉及到键盘、鼠标之间的事件\n\n### KEYDOWN事件绑定 敲下键盘里的某个键（input属性）\n\n在输入框中输入内容时，会触发**keydown**事件\n\n完整代码如下：\n\n```js\n\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                count: 1\n            }\n        },\n        methods:{\n            keyDownHandler(){\n                console.log('正在键入....')\n            }\n        },\n        template:`\n            <div >\n                <input @keydown=\"keyDownHandler\" />\n            </div>    \n        \n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n\n### 单个特定键位检测(input属性)\n\n**对于特定的键Enter、Space等键**有时我们会需要检测\n比如实现表单的Enter提交方式\n\n完整代码如下：\n```js\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                count: 1,\n                username:''\n            }\n        },\n        methods:{\n            keyEnterDownHandler(){\n                console.log('提交成功！您的数据为' + this.username)\n            }\n        },\n        template:`\n            <div >\n                <input @keydown.enter=\"keyEnterDownHandler\" v-model=\"username\"/>                \n            </div>    \n\n            <div>\n                <button >提交表单</button>\n            </div>\n\n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n\n# 表单的数据双向绑定\n## 什么叫数据的双向绑定？\n**所谓数据的双向绑定，就是指：data中的变量val与页面中的字面量{{val}}相互绑定**\n1. 当data中的val发生改变时 前端页面显示的值会发生变化\n2. 当前端中的内容发生变化（比如输入框输入不同的值） 那么data中的内容也会发生变化\n\n**这种两方中其中一方发生变化，而另一方必然随之变化的过程，称为双向绑定**\n\n# 表单INPUT TEXTAREA文本框的绑定\n比如**data**中有一个变量**val**\n\n```js\n\tdata(){\n\t\treturn{\n\t\t\tval:''\n\t\t}\n\t}\n```\n\n而前端页面中，输入的值赋给**val**\n```js\ntemplate:\"<input v-model=\"val\" />\"\n```\n\n这样，输入不同的前端页面，**data中的val**也会不同！\n\n1. input单行文本框添加**v-model=\"val\"**属性\n2. **textarea**多行文本框同样适用\n\n# 表单单选框RADIO的绑定\n\n**单选框一般用字符串接收**\n\n参与单选框中的v-model对应的data中的字符串变量命名意义是：这些若干同属的类别\n**比如男、女 其v-model=\"gender\"**这样命名\n\n其次，应有不同的value属性值来区分这些单选框！\n\n完整代码如下：\n```js\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                gender:''\n            }\n        },\n        methods:{\n            keyEnterDownHandler(){\n                console.log('提交成功！您的数据为' + this.username)\n            }\n        },\n        template:`\n            <div >\n                <input type=\"radio\" v-model=\"gender\"  value=\"男\"/>男\n                <br>\n                <input type=\"radio\" v-model=\"gender\" value=\"女\"/>女             \n            </div>    \n\n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n\n# 表单多选框CHECKBOX的绑定\n\n对于多选框的每个框**要么属于checked被选中的状态 要么没被选中**\n\n1. 所以**如果只有一个选项 我们应用Bool值true与false**来确定多选框的选中状态\n2. 如果有多个选项，我们**应该用一个数组[]**来装！\n\n完整代码如下：\n\n```js\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                gender:'',\n                interests:[]\n            }\n        },\n        methods:{\n            keyEnterDownHandler(){\n                console.log('提交成功！您的数据为' + this.username)\n            }\n        },\n        template:`\n            <div >\n                <input type=\"checkbox\" v-model=\"interests\"  value=\"打篮球\"/>打篮球\n                <br>\n                <input type=\"checkbox\" v-model=\"interests\" value=\"游泳\"/>游泳             \n            </div>    \n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n\n# 深入v-model\n## 1.LAZY 懒显示\n对于双向绑定，当输入框绑定data中的变量**content**后，如果页面的某一个区域**立即用到了这个content**\n那么在输入的过程中，页面会**实时显示content的值**\n\n**我们使用 v-model.lazy=\"val\" 来懒显示，即输入框失去焦点后，内容才会发生变化**\n\n代码如下：\n```js\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                content:''\n            }\n        },\n        template:`\n            输入框失去焦点才会显示的content：{{content}}\n            <div >\n                <input v-model.lazy=\"content\"/>\n            </div>    \n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n\n## 2.NUMBER 输入数字\n**默认输入的内容是字符串类型 为避免后台转换数字**\n\n**我们可以使用v-model.number=\"val\" 来转换成输入绑定data中的变量val**\n\n代码如下：\n```js\n<script>\n    const app = Vue.createApp({\n        data(){\n            return{\n                content:''\n            }\n        },\n        template:`\n            输入的数据类型是：{{typeof content}}\n            <div >\n                年龄：<input v-model.number=\"content\"/>\n            </div>    \n        `\n    })\n    const vm = app.mount(\"#app\")\n</script>\n```\n\n## 去除前后空格-trim\ntrim属性用来消除input框输入内容前后的空格的。现在我们再字符串上输入空格，其实它会在DOM元素上进行增加空格的，这个可以在控制台清楚的看出(详细请看视频操作)。 加入trim修饰符后，Vue就会自动给我们去除前后的空格.\n\n```js\nv-model.trim=\"content\"\n```","tags":["前端框架学习"],"categories":["前端框架学习"]},{"title":"翻译作品--如何像母语者一样说英语","url":"/2021/03/26/翻译作品-如何像母语者一样说英语/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# How to speak English fast and understand natives (Part I) | 如何更快理解母语者\n\n## 该视频由YouTube博主讲述如何像母语者一样说英语\n\nDo you really need to speak English fast? When native English speakers speak fast, the boundaries between words disappear and this gives the impression of talking fast. In reality, they are not talking faster than normal —it’s just that the sounds in their pronunciation flow together in the most smooth and efficient way.\n你一定要说得快吗?当以英语为母语的人说得很快时，单词之间的界限就消失了，这会给人一种说得很快的印象。在现实生活中，他们并没有说得比平时快，只是他们的发音中的声音以最流畅和有效的方式衔接在一起。\n\n## 视频地址\n<div style=\"position: relative; padding: 30% 45%;\">\n<iframe style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\" \nsrc=\"https://player.bilibili.com/player.html?aid=247267596&bvid=BV17v41187GJ&cid=315455726&page=1\"\n frameborder=\"no\" scrolling=\"no\"></iframe>\n</div>\n\n\n","tags":["翻译作品"],"categories":["翻译作品"]},{"title":"C++管理系统","url":"/2021/03/19/C-管理系统/","content":"\n# 源代码\n```cpp\n#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n\ntypedef struct student          //学生信息\n{\n    char stu_num[15];           //学号\n    char name[15];              //姓名\n    char stu_id[20];            //身份证号\n    char institute[50];         //学院\n    char stu_type;              //学生类型\n    char major[50];             //专业\n    char route[100];            //返校路线\n    char TrafficTools[100];     //交通工具\n    char isCloseContact;        //近14天是否有密切接触确诊人员\n    char temperature[10];       //入校时温度\n    char isFever;               //是否发烧\n    char isCough;               //是否咳嗽\n    char time[20];              //进校时间\n \n}Student;\n\nvoid Print(Student stu)             //输出学生信息\n{\n    printf(\"\\n*****************学生信息*****************\\n\\n\");\n    printf(\"学号: %s\\n姓名: %s\\n身份证号: %s\\n学生类型: %c\\n\",stu.stu_num,stu.name,stu.stu_id,stu.stu_type);\n    printf(\"学院: %s\\n专业: %s\\n返校路线: %s\\n交通工具: %s\\n\",stu.institute,stu.major,stu.route,stu.TrafficTools);\n    printf(\"过去14天是否密切接触确诊人员（是：1/否：0）： %c\\n返校温度: %s\\n\",stu.isCloseContact,stu.temperature);\n    printf(\"是否发烧（是：1/否：0）: %c\\n是否咳嗽（是：1/否：0）: %c\\n返校时间: %s\\n\",stu.isFever,stu.isCough,stu.time);\n }\n\nvoid Instruction()                  //帮助\n{\n    printf(\"====================学生返校信息管理系统====================\\n\");\n    printf(\"=                                                          =\\n\");\n    printf(\"=                   ***功能介绍***                         =\\n\");\n    printf(\"=                                                          =\\n\");\n    printf(\"=                   1.录入学生信息                         =\\n\");\n    printf(\"=                   2.查找学生信息                         =\\n\");\n    printf(\"=                   3.修改学生信息                         =\\n\");\n    printf(\"=                   4.按顺序输出某学院学生信息             =\\n\");\n    printf(\"=                   5.请求帮助                             =\\n\");\n    printf(\"=                   6.退出系统                             =\\n\");\n    printf(\"=                                                          =\\n\");\n    printf(\"=                                                          =\\n\");\n    printf(\"============================================================\\n\");\n    return ;\n}\n\nvoid WriteStuInfo(){\n\tFILE *fp;\n\tchar c = 'y';\n\tchar file[50] = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\\";\n\t\n\twhile(c == 'y'){\n\t\tStudent stu = {0}; //初始化\n\t\tcout << \"请按照以下内容初始化：\\n\";\n\t\t\n\t\tcout << \"请输入学号\\n\";\n\t\tcin >> stu.stu_num;\n\n\t\tcout << \"请输入姓名\\n\";\n\t\tcin >> stu.name;\n\n\t\tcout << \"请输入身份证\\n\";\n\t\tcin >> stu.stu_id;\n\t\t\n\t\tcout << \"学生类型：（1本 2研 3博）\\n\";\n\t\tcin >> stu.stu_type;\n\t\t\n\t\tcout << \"所在学院\\n\";\n\t\tcin >> stu.institute;\n\t\t\n\t\tcout << \"所在专业\\n\";\n\t\tcin >> stu.major;\n\t\t\n\t\tcout << \"返校所经城市\\n\";\n\t\tcin >> stu.route;\n\t\t\n\t\tcout << \"交通工具\\n\";\n\t\tcin >> stu.TrafficTools;\n\t\t\n\t\tcout << \"是否接触确诊：1是 0否\";\n\t\tcin >> stu.isCloseContact;\n\t\t\n\t\tcout << \"入校时的温度\\n\";\n\t\tcin >> stu.temperature;\n\t\t\n\t\tcout << \"是否发烧: 1是 0否\\n\";\n\t\tcin >> stu.isFever;\n\t\t\n\t\tcout << \"是否咳嗽: 1是 0否\\n\";\n\t\tcin >> stu.isCough;\n\t\t\n\t\tcout << \"入校时间\\n\";\n\t\tcin >> stu.time;\n\t\t\n\t\tstrcat(file, stu.institute);\n\t\tstrcat(file, \".txt\");\n\t\t\n\t\tcout << file;\n\t\tfp = fopen(file, \"a\");\n\t\tif(fp == NULL){\n\t\t\tcout << \"文件无法打开\\n\";\n\t\t\texit(0); \n\t\t}\n\t\t\n\t\tif(fwrite(&stu, sizeof(Student), 1, fp) != 1){\n\t\t\tcout <<\"数据无法录入\\n\";\n\t\t}\n\t\t\n\t\t//在定义的数组长度不够的情况下 \n\t\t//每次读入一组数据 可以在文件中打印一个换行符\n\t\t//fprintf(fp, \"\\n\"); \n\t\t\n\t\tfclose(fp);\n\t\tcout << \"是否继续录入？(y/n)\\n\";\n\t\tcin >> c;\n\t}\n}\n\nvoid Search(){\n\tchar c = 'y';\n\tint flag = 0;\n\tFILE* fp;\n\tint isSearch;\n\tStudent stu = {0};\n\twhile(c == 'y'){\n\t\tchar stu_info[50], ins[50] = {0};\n\t\tchar file[50] = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\\";\n\t\tcout << \"输入学生所在学院\\n\";\n\t\tcin >> ins;\n\t\t\n\t\tstrcat(file ,ins);\n\t\tstrcat(file, \".txt\");\n\t\t\n\t\tfp = fopen(file, \"r\");\n\t\tcout << \"请输入查找方式：1/学号,2/姓名\\n\";\n\t\tcin >> flag;\n\t\t\n\t\tcout << \"待查找的信息：\" <<endl;\n\t\tcin >> stu_info;\n\t\t\n\t\tisSearch = 0;\n\t\twhile(fread(&stu, sizeof(Student), 1, fp) == 1 ){\n\t\t\t//当读到数据时\n\t\t\tif(flag == 1){\n\t\t\t\tif(!strcmp(stu.stu_num, stu_info)){\n\t\t\t\t\tcout << \"找到了，数据为：\\n\";\n\t\t\t\t\tPrint(stu);\n\t\t\t\t\tisSearch = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!strcmp(stu.name, stu_info)){\n\t\t\t\t\tcout << \"找到了，数据为：\\n\";\n\t\t\t\t\tPrint(stu);\n\t\t\t\t\tisSearch = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} \n\t\t\tif(isSearch == 0){\n\t\t\t\tcout << \"查无此人！\" <<endl;\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\t\n\t\t\tcout << \"是否继续查找(y/n)\\n\";\n\t\t\tcin >> c;\n\t\t}\n\t}\n} \n\nvoid Alter(){\n\tFILE* fp;\n\tint isSearch;\n\tint pos, num;\n\tint i;\n\t\n\tchar c = 'y';\n\twhile(c == 'y'){\n\t\tchar newfile[10000] = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\\";\n\t\tchar stu_info[50], ins[50], file[50] = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\\";\n\t\tStudent all_stu[50], goal_stu, stu={0};\n\t\t\n\t\tcout << \"请输入学生所在学院\\n\";\n\t\tcin >> ins;\n\t\tstrcat(file, ins);\n\t\tstrcat(file, \".txt\");\n\t\t\n\t\tfp = fopen(file, \"r\");\n\t\tcout <<\"输入学生学号:\\n\";\n\t\tcin >> stu_info;\n\t\t\n\t\tisSearch = 0;\n\t\tpos = 0;\n\t\tnum = 0;\n\t\tfor(pos=0; fread(&stu, sizeof(Student), 1, fp)==1; pos++){\n\t\t\tif(!strcmp(stu.stu_num, stu_info)){\n\t\t\t\tgoal_stu = stu;\n\t\t\t\tisSearch = 1;\n\t\t\t}else{\n\t\t\t\tall_stu[num++] = stu;\n\t\t\t}\t\t\n\t\t}\n\t\t\n\t\tif(isSearch){\n\t\t\tfclose(fp);\n\t\t\tfp = fopen(file, \"w\");\n\t\t\tfor(i =0; i<num; i++){\n\t\t\t\tfwrite(&all_stu[i], sizeof(Student), 1, fp);\n\t\t\t}\n\t\t\t\n\t\tfclose(fp);\n\t\t\n\t\tcout << \"请输入信息：\\n\\n\";\n\t\tcout << \"请输入学号：\\n\";\n\t\tcin >> stu.stu_num;\n\t\t\n\t\tcout << \"请输入姓名:\\n\";\n\t\tcin >> stu.name;\n\t\t\n\t\tcout << \"请输入身份证号：\\n\";\n\t\tcin >> stu.stu_id;\n\t\t\n\t\tcout << \"请输入学生类型:1/本, 2/硕, 3/博\\n\";\n\t\tcin >> stu.stu_type;\n\t\t\n\t\tcout << \"请输入所在学院：\\n\";\n\t\tcin >> stu.institute;\n\t\t\n\t\tcout << \"请输入所在专业：\\n\";\n\t\tcin >> stu.major;\n\t\t\n\t\tstrcat(newfile, stu.institute);\n\t\tstrcat(newfile, \".txt\");\n\t\tfp = fopen(newfile, \"a\");\n\t\tfwrite(&stu, sizeof(Student), 1, fp); \n\t\t}else{\n\t\tcout << \"查无此人\\n\";\n\t\t}\n\tfclose(fp);\n\tcout << file <<endl;\n\tfp = fopen(file, \"r\");\n\twhile(fread(&stu, sizeof(Student), 1, fp)==1){\n\t\tPrint(stu);\n\t}\n\tfclose(fp);\n\tcout << \"是否继续修改y/n \\n\";\n\tcin >> c;\n\t} \n} \n\nvoid print_Sort(){\n\tFILE* fp;\n\tint j, Min;\n\tint num = 0;\n\tint i;\n\tStudent all_stu[50]={0}, stu={0};\n\tchar newfile[10000] = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\sort_\";\n\tchar ins[20], file[50] = \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\\";\n\t\n\tcout << \"请输入学院:\\n\";\n\tcin >> ins;\n\t\n\tstrcat(file, ins);\n\tstrcat(file, \".txt\");\n\t\n\tfp = fopen(file, \"r\");\n\t\n\twhile(fread(&all_stu[num++], sizeof(Student), 1, fp) == 1){\n\t\t;\t\t\n\t}\n\tfclose;\n\t\n\tfor(i=0; i<num-1; i++){\n\t\tMin = i;\n\t\tfor(j=i+1; j<num; j++){\n\t\t\tif(strcmp(all_stu[Min].stu_num, all_stu[j].stu_num) >0){\n\t\t\t\tMin = j;\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(Min != i){\n\t\t\tStudent temp = all_stu[i];\n\t\t\tall_stu[i] = all_stu[Min];\n\t\t\tall_stu[Min] = temp;\n\t\t}\n\t}\n\t\n\tstrcat(newfile, ins);\n\tstrcat(newfile, \".txt\"); \n\tfp = fopen(newfile, \"w\");\n\tfor(i=0; i<num; i++){\n\t\tfwrite(&all_stu[i], sizeof(Student), 1, fp);\n\t}\n\tfclose(fp);\n\t\n\tfp = fopen(newfile, \"r\");\n\twhile(fread(&stu, sizeof(Student), 1, fp)==1){\n\t\tPrint(stu);\n\t}\n\t\n\tfclose(fp); \n}\n\nvoid passwordVerify()\n{\n\tchar password[20]={0};\n\t    int i=5;\n\t    printf(\"\\n\\n\");\n\t    printf(\"====================欢迎使用学生返校信息管理系统====================\\n\\n\");\n\t  \n\t    while(i>0){\n\t    printf(\"请输入登录密码：\");\n\t    scanf(\"%s\",&password);\n\t        if(strcmp(password,\"123456\")!=0){\n\t            --i;\n\t            printf(\"密码输入错误，请重新输入，您还有%d次机会\\n\",i);\n\t        }\n\t        else{\n\t            printf(\"密码输入正确！\");\n\t            break;}\n\t    if(i==0){\n\t        exit(0);}\n\t    }\n}\nvoid chooseMenu(){\n\tint flag;\n\tchar c='y';\n\twhile(c=='y'){\n\t    printf(\"请输入您需要的操作（按5请求帮助）： \\n\");\n\t    flag=0;\n\t    scanf(\"%d\",&flag);\n\t    getchar();\n\t    if(flag==1){                    //录入\n\t        WriteStuInfo();\n\t    }\n\t    else if(flag==2){               //查找\n\t        Search();\n\t    }\n\t    else if(flag==3){               //修改\n\t        Alter();\n\t    }\n\t    else if(flag==4){               //排序\n\t       print_Sort();\n\t    }\n\t    else if(flag==5){               //导航\n\t        Instruction();\n\t    }\n\t    else if(flag==6){               //退出系统\n\t        exit(0);\n\t    }\n\t    else {\n\t        printf(\"输入有误！请重新输入！\\n \");\n\t        continue;\n\t    }\n\t    printf(\"是否继续使用该系统（y/n）：\");\n\t    scanf(\"%c\",&c);\n\t}\n}\n\nint main()\n{   passwordVerify();\n    Instruction();\n    system(\"pause\");\n    return 0;\n}\n```","tags":["编程语言"],"categories":["编程语言"]},{"title":"C++面向对象基础","url":"/2021/03/17/C-面向对象基础/","content":"\n# 职员类\n## 构造函数\n## set get 方法\n```cpp\n#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\nusing namespace std;\n\n//定义一个职员类\nclass Employee{\n\t//属性与方法\n\t\n\tpublic: //公共方法\n\n\t\t//构造函数 有多个构造函数后 \n\t\t//默认的空构造函数 会被覆盖 建议加上 \n\t\tEmployee(){}\t \n\t\tEmployee(string name, string company, int age);\n\t\t\n\t\t//Set方法\n\t\tvoid setName(string name);\n\t\tvoid setCompany(string company);\n\t\tvoid setAge(int age);\n\n\t\t//Get方法\n\t\tstring getName();\n\t\tstring getCompany();\n\t\tint getAge();\n\n\t\tvoid introduce();\n\tprivate:\n\t\t//私有属性 在类的外部不可直接调用\n\t\t//注意！不管是接口还是属性 还是方法\n\t\t//C++中 不明确指出public还是protected的 \n\t\t//默认是“private”！！！！\n\t\t\n\t\tstring Name; //姓名\n\t\tstring Company; //所就职的公司\n\t\tint Age; //年龄\t\t\n}; \n\n//利用域名符:: 实现相应的方法 \n//注意：实现相应方法的形参 必须对应相应的函数声明\n//注意：使用this指针时 内部使用-> 在主函数中的对象 使用.\nEmployee::Employee(string name, string company, int age){\n\t//this指针 代表当前任意被调用的这个对象\t\n\tthis->Name = name;\n\tthis->Company = company;\n\tthis->Age = age;\n}\n\nvoid Employee::setName(string name){\n\tthis->Name = name;\n}\n\nstring Employee::getName(){\n\treturn this->Name;\n}\n\nvoid Employee::setCompany(string company){\n\tthis->Company = company;\n}\n\nstring Employee::getCompany(){\n\treturn this->Company;\n}\n\nvoid Employee::setAge(int age){\n\tthis->Age = age;\n}\n\nint Employee::getAge(){\n\treturn this->Age;\n}\n\n\nvoid Employee::introduce(){\n\tcout << \"Name->\" << Name << \",\" << \"Company->\" \n\t<< Company << \",Age->\" <<Age<<endl; \n}\n\nint main()\n{\t\n\tstring name = \"Vincent\";\n\tstring company = \"Tecent\";\n\tint age = 21;\n\t\n\t//利用构造函数 new一个新的职员对象\n\tEmployee e1 = Employee(name, company, age);\n\te1.introduce();\n\t\n\treturn 0;\n}\n```\n\n# 实现虚拟接口\n## 职员具有实现接口的功能\n### 1.定义一个接口（Virtual 虚拟方法）\n```cpp\nclass AbstractEmployee{\n\tpublic:\n\t\tvirtual void AskForPromotion()=0;\n};\n```\n\n### 2.声明某个类实现 :这个AbstractClass\n```cpp\nclass Employee:AbstractEmployee{\n\tpublic:\n\t\t//.....公共方法\n\t\t//将接口中的方法 作为实现这个方法的类的成员函数\n\t\tvoid AskForPromotion();\n\tprivate:\n\t\t//.....私有属性\n};\n```\n\n### 3.具体实现函数\n```cpp\nvoid Employee::AskForPromotion(){\n\t//具体方法\n}\n```\n\n# 程序员（Employee类的子类 继承Employee）\n### 1.程序员类具有自己特有的构造函数&成员函数\n```cpp\nclass Developer: Employee{\n\tpublic:\n\t\t//别忘了默认的构造函数 以及声明程序员类特有的构造函数\n\t\tDeveloper(){}\n\t\tDeveloper(string name, string company, int age, string fav);\n\t\t//继承Employee的同时 Developer类具有Employee的公共方法\n\t\t\n\t\t//Set函数与Get函数 是Developer独有的方法\n\t\tvoid setFavProgLang(string language);\n\t\tstring getFavProgLang(); \n\tprivate:\n\t\tstring FavProgLang; //最喜欢的编程语言 \n};\n```\n\n### 2.实现这个构造函数以及成员函数(:Empl... 表示由其父类来实现前三个参数)\n```cpp\nDeveloper::Developer(string name, string company, int age, string fav)\n\t:Employee(name, company, age)\n{\n\tthis->FavProgLang = fav;\n}\n```\n\n**注意：父类中的Name，Company，Age 在其子类Developer中都是不可获取的（Inaccessible）**\n**因为，这些属性都是private 私有的，在类外任何地方都不能获取！**\n**除非我们修改这些属性的修饰符 修改成protected**","tags":["编程语言"],"categories":["编程语言"]},{"title":"SpringMVC学习笔记(所有代码FROM SIKI学院)","url":"/2021/03/17/SpringMVC/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# SpringMVC是什么？\n\tSpring MVC又叫SpringWebMVC是一个轻量级的基于请求响应的表现层框架。它是Spring框架的一部分。SpringMVC与Struts2都可以替代原始Servlet技术。\n\n## 为什么要使用SpringMVC？\nSpring Web MVC框架提供了MVC(模型 - 视图 - 控制器)架构和用于开发灵活和松散耦合的Web应用程序的组件。 MVC模式导致应用程序的不同方面(输入逻辑，业务逻辑和UI逻辑)分离，同时提供这些元素之间的松散耦合。\n\n1、SpringMVC是极具代表性的MVC框架对初学者学习很有帮助； \n\ta)模型(Model)封装了应用程序数据，通常它们将由Bean对象组成；\n\tb)视图(View)负责渲染模型数据，一般来说它生成客户端浏览器可以解释HTML输出；\n\tc)控制器(Controller)负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染；\n\n2、与Spring框架无缝集成；\n3、对Servlet轻度封装，框架小巧轻便性能好；\n4、可使用注解式开发，编码简洁；\n5、便于测试；\n6、具有本地化、国际化、类型转换、数据验证等功能；\n7、使用人群十分广泛，在现在的企业招聘中属于java程序员必备技能之一；\n\n## 我能从这门课中学到什么？\n1、SpringMVC框架学习： \na)了解SpringMVC框架处理流程；\nb)掌握SpringMVC搭建、配置与使用；\nc)Spring + SpringMVC + MyBatis 三大框架整合；\nd)掌握SpringMVC基本参数与复杂参数绑定；\ne)掌握SpringMVC自定义异常处理类、拦截器、图片上传等操作；\nf)掌握SpringMVC处理Json格式字符串；\n\n2、SSM框架练习项目：\na)使用整合后的SSM框架完成Steam后台游戏管理和前台游戏列表的Demo；\n\nSpringMVC从哪获取？\n以下网址可以获取Spring框架的所有版本，SpringMVC是Spring框架中的一个子包SpringWebMvc\nhttp://repo.spring.io/release/org/springframework/spring/\n\n# Part.1 SpringMVC入门：\n## 1、SpringMVC简要处理流程：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210317142755778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 2、HelloSpringMVC：搭建SpringMVC HelloWorld项目\na)导包 –> 02_jar -> spring_jar整理 -> spring_mvc；\nb)DispatcherServlet配置和拦截规则 (前端控制器、任务派发器、前端调度器)；\nc)使用SpringMVC显示页面；\nd)使用SpringMVC向前台传递数据；\n\n## 3、SpringMVC详细处理流程：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210317142805622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n## 4、DispatcherServlet.properties内Bean对象：\na)HandlerMapping：处理器映射 ：将请求映射到Handler上并返回处理器执行链\ni.通过HandlerMapping（处理器映射），可以将Web 请求映射到正确的Handler（处理器）也就是Controller上；\nii.DispactherServlet（前端控制器） 将请求交给HandlerMapping，让他检查请求并找到一个合适的HandlerExecutionChain（处理器执行链），这个HandlerExecutionChain 包含一个能处理该请求的Handler；\n\nb)HandlerAdapter：处理器适配器 ：执行具体的逻辑业务\ni.负责执行DispactherServlet中HandlerExecutionChain的Handler；\nii.从Handler中获取ModelAndView（模型与视图）对象，返回给DispactherServlet；\n\nc)ViewResolver：视图解析器 ：解析视图\ni.通过视图名称解析视图；\nii.返回视图对象；\n\nd)HandlerExceptionResolver：处理器异常解析，将异常映射到统一错误页面，常见的404页面，不让用户看到具体的错误，友好提示；\ne)LocaleResolver：本地化解析，解析客户端信息进行本地化；\nf)ThemeResolver：主题解析，实现多风格，类似皮肤效果；\ng)RequestToViewNameTranslator：请求到视图名转换器，当view为空时，从request中获取viewName；FlashMapManager：FlashMap管理器，通常应用在重定向场景；\n\n5、SpringMVC Controller简要说明\na)RequestMapping注解使用：\ni.多请求；\nii.限定请求方法；\niii.窄化(简化)请求路径;\n\nb)Controller方法返回值：\ni.ModelAndView：返回模型和视图\nii.void：使用原生request，response\niii.String：\n1.返回视图名 viewName；比较推荐使用\n2.转发 forword；\n3.重定向 redirect；\n\niv.自定义类型(JSON) – 需要@ResponseBody注解 - \n\n# Part.2 SpringMVC & Spring & MyBatis整合：\n## 1、整合ssm 3大框架 \na)导包 -> spring_Jar整理 -> ssm框架整合包\nb)配置 -> web.xml\ni.读取spring配置文件；\nii.配置springmvc前端控制器；\n\nc)配置 -> applicationContext.xml\ni.读取数据库配置文件；\nii.配置数据源连接池；\niii.开启注解扫描；\niv.配置事务核心管理器；\nv.开启注解事务；\nvi.配置视图解析器；\n\nvii.配置Mybatis：\n1.配置sqlSessionFactory；\n2.配置别名；\n3.配置mapper工厂；\n\n## 2、准备测试用例\na)准备 – 测试数据：\ni.Bean -> 根据个人喜好；\nii.数据库表 -> 根据个人喜好；\nb)导入 – 测试数据 -> 学习项目 -> 后台页面\n使用整合后的ssm框架，查询数据库测试表，将数据显示到前台\n\n# Part.3 SpringMVC参数绑定与数据交互：\n## 1、默认参数绑定：通过id查询游戏信息，并将结果显示在页面上； \na)HttpServletRequest request；\nb)HttpServletResponse response；\nc)HttpSession session；\nd)Model model：将数据存储在request域，前台可以获取；\n\n## 2、基本参数绑定：通过id删除游戏信息；\na)Integer、int；\nb)Float、float；\nc)Double、double；\nd)Boolean、boolean；\ne)String；\n\n## 3、Bean对象参数绑定：添加游戏；\n4、包装类参数绑定：多条件查询，并将结果显示在页面上；\n5、解决表单post提交乱码：在web.xml中配置过滤器；\n\n## 复杂类型参数绑定：\n1、Array数组类型的参数绑定：为页面增加多选框，获取选定游戏信息的id，后续逻辑自行选择；\n2、List类型的参数绑定：获取所有游戏价格，并且计算总价；\n\n## Json数据交互：\n Json介绍：http://www.bejson.com/knownjson/aboutjson/\na)导包，配置注解驱动；\nb)创建自己的Json对象；\nc)发送和接收Json字符串；\nd)修改游戏信息，在弹出层内回显数据；\ne)使用@RequestBody完成List和数组参数绑定，获取所有游戏的名称，在后台打印；\n\n# Part.4 异常处理器与拦截器\n## 1、通过实现HandlerExceptionResolver接口完成异常处理；\na)异常处理器原理；\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210317142829243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\nb)使用异常处理器捕获运行时异常；\nc)使用异常处理器捕获自定义异常；\n\n## 2、通过注解完成全局异常处理；\na)通过@ControllerAdvice注解使@ExceptionHandler异常处理注解应用到所有使用@RequestMapping的方法上；\nb)处理运行时异常：直接打印错误信息；\nc)处理自定义异常：将错误信息输出到error页面上； \n\n## 拦截器Interceptor\n### 1、SpringMvc中的拦截器：\na)SpringMvc拦截器帮我们按照一定规则拦截请求，后根据开发人员自定义的拦截逻辑进行处理；\nb)自定义拦截器需要实现HandlerInterceptor接口；\nc)自定义的拦截器实现类需要在SpringMvc配置文件中配置；\nd)可以配置多个拦截器，配置的顺序会影响到拦截器的执行顺序，配置在前的先执行；\ne)HandlerInterceptor有3个接口：\ni.preHandle 预处理：在拦截方法前执行；\nii.postHandle 后处理：在拦截方法后执行；\niii.afterCompletion 渲染后处理：在页面渲染后执行；\nf)拦截器也体现了AOP思想；\ng)拦截器的应用：权限检查，日志记录，性能检测等；\n\n### 2、拦截器的执行流程图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/202103171428468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n### 3、拦截器的执行规则； \na)自定义2个拦截器，并在主配置文件中配置好；\nb)运行服务进入拦截器，观察执行流程；\n\n### 4、总结的五条拦截器规则；\na)preHandle预处理：--------------根据拦截器定义的顺序，正向执行；\nb)postHandle后处理：-------------根据拦截器定义的顺序，逆向执行；\nc)afterCompletion渲染后处理：---根据拦截器定义的顺序，逆向执行；\nd)postHandle预处理：-------------所有拦截器都返回成功调用；\ne)atterCompletion渲染后处理：---preHandle返回true调用；\n\n### 5、使用拦截器开发用户登录校验；\na)需要登录才可以访问列表页；\nb)如果未登录重定向到登录页面；\n\n### 6、使用拦截器搭配异常处理器完成用户登录时的异常处理；\na)使用自定义异常处理器捕获登录时异常；\nb)如果出现异常，将异常信息发送到登录页面提示；\n\n### 7、静态资源放行；\na)在web.xml配置DispatcherServlet的url-pattern以扩展名结尾，例如*.do，*.html 等；\nb)在web.xml配置default servlet-mapping的url-pattern，以目录形式和扩展名形式；\nc)在springmvc.xml中配置<mvc:resources/>，该方法需要注意以下几点：\ni.需要开启mvc:annotation-driven注解驱动；\nii.如果配置了拦截器，需要在拦截器中进行过滤，否则会被拦截；\niii.路径名不要打错 ;\n\n### 8、RESTful风格开发：一种以URL定位资源的开发风格。使用RESTful开发URL会变得一目了然，更有层次，它不是标准或者协议；\n\n更多关于RESTful风格的介绍网上查查；\n\n使用RESTful前：\nhttp://127.0.0.1/item/save\t\t\tPOST \t新增物品\nhttp://127.0.0.1/item/delete \t\t\tGET/POST \t删除物品\nhttp://127.0.0.1/item/update \t\tPOST \t修改物品\nhttp://127.0.0.1/item/query.do?id=1\tGET  \t\t根据id查询物品\n\n\n使用RESTful后：\nhttp://127.0.0.1/item\t\t\t\tPOST \t新增物品\nhttp://127.0.0.1/item/1 \t\t\tDELETE \t根据id删除物品\nhttp://127.0.0.1/item \t\t\t\tPUT \t\t修改物品\nhttp://127.0.0.1/item/1 \t\t\tGET  \t\t根据id查询物品\n\t\t\nRESTful风格开发对Http协议中的基本方法的使用\nPOST\tINSERT\t增\t邮寄一个新的\nDELETE\tDELETE\t删\t仍了，不要了\nGET \tSELECT\t查\t获取一个\nPUT\t\tUPDATE\t改\t往这个里边放点东西\n\t\t\n使用Springmvc实现RESTful风格开发；\na)使用物品id当作请求路径，点击按钮，跳转到具体的页面；\nb)当使用ajax时，页面不会跳转，需要到ajax回调中处理；\n\n\n# SPRINGMVC-PROJECT-1\n## 前端请求页面form.jsp\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<title>Insert title here</title>\n</head>\n<body>\n\t<form action=\"${pageContext.request.contextPath}/mylist.do\" method=\"get\">\n\t\t<input type=\"submit\" value=\"提交\">\n\t</form>\n</body>\n</html>\n```\n\n## WEB配置文件 web.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" id=\"WebApp_ID\" version=\"3.1\">\n  <display-name>ssm_spring_mvc</display-name>\n  \n  <servlet>\n  \t<servlet-name>springmvc</servlet-name>\n  \t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n  \t<init-param>\n  \t\t<!-- 读取springmvc配置文件 -->\n  \t\t<param-name>contextConfigLocation</param-name>\n  \t\t<param-value>classpath:springmvc.xml</param-value>\n  \t</init-param>\n  </servlet>\n  \n  <servlet-mapping>\n  \t<servlet-name>springmvc</servlet-name>\n  \t<!-- 拦截规则 -->\n  \t<!--1 *.htm *.do *.action   以扩展名方式进行拦截，不拦截静态资源  .jpg .css .js .png   什么情况下都可以使用\n  \t\t2 / 不拦截 jsp 拦截静态资源 .jpg .css .js .png  \n  \t\t/* 全都拦截 包括jsp 以及所有静态资源 不推荐使用的-->\n  \t<url-pattern>*.do</url-pattern>\n  </servlet-mapping>\n  \n  <welcome-file-list>\n    <welcome-file>index.html</welcome-file>\n    <welcome-file>index.htm</welcome-file>\n    <welcome-file>index.jsp</welcome-file>\n    <welcome-file>default.html</welcome-file>\n    <welcome-file>default.htm</welcome-file>\n    <welcome-file>default.jsp</welcome-file>\n  </welcome-file-list>\n</web-app>\n```\n\n## SPRINGMVC配置文件 springmvc.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txmlns:aop=\"http://www.springframework.org/schema/aop\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd\n\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\n\t\thttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\">\n\t\t\n\t\t<!-- 开启注解扫描 基本包下有 bean,controller层.. -->\n\t\t<context:component-scan base-package=\"com.sikiedu\"></context:component-scan>\n\t\t\n\t\t<!-- 配置视图解析器  配置viewName 前缀与后缀 -->\n\t\t<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t\t<property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\n\t\t\t<property name=\"suffix\" value=\".jsp\"/>\n\t\t</bean>\n\t\t\n</beans>\n\n```\n## BEAN对象 ItemInfo.java\n```java \npublic class ItemInfo {\n\t//id\n\tprivate String item_id;\n\t//name\n\tprivate String item_name;\n\t//type\n\tprivate String item_type;\n\t//price\n\tprivate String item_price;\n}\n```\n\n## Controller层 ItemController.java\n```java\n\n<!-- 注解表示是控制层 通过springmvc注解扫描 -->\n<!-- RequestMapping对应前端页面的请求路径 -->\n@Controller \n@RequestMapping(value=\"/item/\")\npublic class ItemController  {\n\n\t//显示页面\t\n\t@RequestMapping(value= {\"list.do\", \"mylist.do\"}, method= {RequestMethod.GET, RequestMethod.POST})\n\t<!-- 指定返回类型是ModelAndView 表示最后会跳转页面 -->\n\tpublic ModelAndView list() {\n\t\tModelAndView mav = new ModelAndView();\n\t\t\n\t\t//传递数据\n\t\t//准备一些测试数据\n\t\tItemInfo info1 = new ItemInfo(\"1\", \"王者荣耀\", \"MOBA\", \"0\") ;\n\t\tItemInfo info2 = new ItemInfo(\"2\", \"守望先锋\", \"射击\", \"198\") ;\n\t\tItemInfo info3 = new ItemInfo(\"3\", \"吃鸡\", \"射击\", \"98\") ;\n\t\tItemInfo info4 = new ItemInfo(\"4\", \"魔兽世界\", \"MMORPG\", \"0\") ;\n\t\tItemInfo info5 = new ItemInfo(\"5\", \"保卫萝卜\", \"休闲\", \"0\") ;\n\t\t\n\t\tList<ItemInfo> itemList = new ArrayList<ItemInfo>();\n\t\titemList.add(info1);\n\t\titemList.add(info2);\n\t\titemList.add(info3);\n\t\titemList.add(info4);\n\t\titemList.add(info5);\n\t\t\n\t\t//将游戏列表返回给前台\n\t\tmav.addObject(\"itemList\", itemList);\n\t\t\n\t\tmav.setViewName(\"item_list\");\n\t\t\n\t\treturn mav;\n\t}\n\t\n\t@RequestMapping(value= {\"mylist1.do\"}, method= {RequestMethod.GET, RequestMethod.POST})\n\tpublic ModelAndView list1() {\n\t\tModelAndView mav = new ModelAndView();\n\t\t\n\t\t//传递数据\n\t\t//准备一些测试数据\n\t\tItemInfo info1 = new ItemInfo(\"1\", \"王者荣耀\", \"MOBA\", \"0\") ;\n\t\tItemInfo info2 = new ItemInfo(\"2\", \"守望先锋\", \"射击\", \"198\") ;\n\t\tItemInfo info3 = new ItemInfo(\"3\", \"吃鸡\", \"射击\", \"98\") ;\n\t\tItemInfo info4 = new ItemInfo(\"4\", \"魔兽世界\", \"MMORPG\", \"0\") ;\n\t\tItemInfo info5 = new ItemInfo(\"5\", \"保卫萝卜\", \"休闲\", \"0\") ;\n\t\t\n\t\tList<ItemInfo> itemList = new ArrayList<ItemInfo>();\n\t\titemList.add(info1);\n\t\titemList.add(info2);\n\t\titemList.add(info3);\n\t\titemList.add(info4);\n\t\titemList.add(info5);\n\t\t\n\t\t//将游戏列表返回给前台 指定Viewname即显示的页面是哪一个？\n\t\t\n\t\tmav.addObject(\"itemList\", itemList);\t\t\n\t\tmav.setViewName(\"item_list\");\n\t\t\n\t\treturn mav;\n\t}\n\t\n\t\n\t//void\n\t@RequestMapping(value=\"\")\n\tpublic void voidTest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t//获取参数\n\t\trequest.getParameter(\"\");\n\t\t\n\t\t//转发\n\t\trequest.getRequestDispatcher(\"\").forward(request, response);\n\t\t\n\t\t//重定向\n\t\tresponse.sendRedirect(request.getContextPath() + \"/xx.jsp\");\n\t}\n\t\n\t//String 转发\n\t@RequestMapping(\"forwardString.do\")\n\tpublic String forwardString() {\n\t\treturn \"forward:mylist1.do\";\n\t}\n\t\n\t//String 重定向\n\t@RequestMapping(\"redirectString.do\")\n\tpublic String redirectString() {\n\t\treturn \"redirect:/form.jsp\";\n\t}\n\t\n\t\n\t//String \n\t@RequestMapping(\"testList.do\")\n\tpublic String testList(Model model) {\n\t\t//传递数据\n\t\t//准备一些测试数据\n\t\tItemInfo info1 = new ItemInfo(\"1\", \"王者荣耀\", \"MOBA\", \"0\") ;\n\t\tItemInfo info2 = new ItemInfo(\"2\", \"守望先锋\", \"射击\", \"198\") ;\n\t\tItemInfo info3 = new ItemInfo(\"3\", \"吃鸡\", \"射击\", \"98\") ;\n\t\tItemInfo info4 = new ItemInfo(\"4\", \"魔兽世界\", \"MMORPG\", \"0\") ;\n\t\tItemInfo info5 = new ItemInfo(\"5\", \"保卫萝卜\", \"休闲\", \"0\") ;\n\t\t\n\t\tList<ItemInfo> itemList = new ArrayList<ItemInfo>();\n\t\titemList.add(info1);\n\t\titemList.add(info2);\n\t\titemList.add(info3);\n\t\titemList.add(info4);\n\t\titemList.add(info5);\n\t\t\n\t\t//将游戏列表返回给前台\n\t\tmodel.addAttribute(\"itemList\", itemList);\n\t\t\n\t\treturn \"item_list\";\n\t}\n\t\n}\n```\n## 数据显示页面 item_list.jsp\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%>\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n    <head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>游戏管理后台</title>\n        <meta name=\"viewport\" content=\"initial-scale=1.0,maximum-scale=1.0,user-scalable=no\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    </head>\n    <body class=\"side_menu_active side_menu_expanded\">\n        <div id=\"page_wrapper\">\n\n            <!-- header -->\n            <header id=\"main_header\">\n                <div class=\"container-fluid\">\n                \t<!--logo-->\n                    <div class=\"brand_section\">\n                        <a href=\"#\"><img src=\"${pageContext.request.contextPath }/picture/logo01.png\" alt=\"site_logo\" width=\"108\" height=\"40\" style=\"margin-top: 5px\"></a>\n                    </div>\n                    <div class=\"header_user_actions dropdown\">\n                        <div data-toggle=\"dropdown\" class=\"dropdown-toggle user_dropdown\">\n                            <div class=\"user_avatar\">\n                                <img src=\"${pageContext.request.contextPath }/picture/head01.png\" width=\"38\" height=\"38\">\n                            </div>\n                            <span class=\"caret\"></span>\n                        </div>\n                        <ul class=\"dropdown-menu dropdown-menu-right\">\n                            <li><a href=\"#\">个人中心</a></li>\n                            <li><a href=\"#\">注销</a></li>\n                        </ul>\n                    </div>\n                </div>\n            </header>\n\n            <!-- main content -->\n            <div id=\"main_wrapper\">\n                <div class=\"container-fluid\">\n                    <div class=\"row\">\n                        <div class=\"col-md-12\">\n                            <div class=\"row\">\n                                <div class=\"col-md-10\">\n                                    <table class=\"table table-yuk2 toggle-arrow-tiny\" id=\"footable_demo\" data-filter=\"#textFilter\" data-page-size=\"5\">\n                                        <thead>\n                                            <tr>\n                                            \t<!--描述：商品数据标签-->\n                                                <th>ID</th>\n                                                <th>游戏名称</th>\n                                                <th>类型</th>\n                                                <th>原价</th>\n                                            </tr>\n                                        </thead>\n                                        <tbody>\n                                       \t\t<c:forEach items=\"${itemList }\" var=\"item\">\n\t                                        \t<tr>\n\t                                                <td>${item.item_id }</td>\n\t                                                <td>${item.item_name }</td>\n\t                                                <td>${item.item_type }</td>\n\t                                                <td>${item.item_price }</td>\n\t                                                \n\t                                                <td data-value=\"1\">\n\t                                                \t<a herf=\"#\" id=\"edit_btn\" class=\"btn btn-xs btn-info\" data-toggle=\"modal\" data-target=\"#editLayer\" onclick=\"editGoods('${item.item_id}')\">修改</a>\n\t                                                \t<a herf=\"#\"  id=\"del_btn\" class=\"btn btn-xs btn-danger\" onclick=\"deleteGoods('${item.item_id}')\">删除</a>\n\t                                                </td>\n\t                                           \t</tr>\n                                        \t</c:forEach>\n                                        </tbody>\n                                        <tfoot class=\"hide-if-no-paging\">\n                                            <tr>\n                                                <td colspan=\"5\">\n                                                    <ul class=\"pagination pagination-sm\"></ul>\n                                                </td>\n                                            </tr>\n                                        </tfoot>\n                                    </table>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            \n            <!-- edit layer -->\n            <div class=\"modal fade\" id=\"editLayer\">\n                <div class=\"modal-dialog modal-content\">\n                    <div class=\"modal-content\">\n                        <div class=\"modal-header\">\n                            <button type=\"button\" class=\"close\" data-dismiss=\"modal\"><span aria-hidden=\"true\">&times;</span><span class=\"sr-only\">Close</span></button>\n                            <h4 class=\"modal-title\">修改游戏信息</h4>\n                        </div>\n                   \t<div class=\"modal-body\">\n                        <!--游戏修改详情弹出层表单-->\n\t                    <form class=\"form-horizontal\" id=\"edit_item_form\">\n\t                    \t<!-- 游戏id隐藏域 -->\n\t\t\t\t\t\t\t<input type=\"hidden\" id=\"edit_item_id\" name=\"item_id\"/>\n\t\t\t\t\t\t\t<!-- 游戏名称 -->\n\t\t\t\t\t\t\t<div class=\"form-group\">\n\t\t\t\t\t\t\t\t<label for=\"edit_item_name\" class=\"col-sm-2 control-label\">游戏名称</label>\n\t\t\t\t\t\t\t\t<div class=\"col-sm-10\">\n\t\t\t\t\t\t\t\t\t<input type=\"text\" class=\"form-control\" id=\"edit_item_name\" placeholder=\"游戏名称\" name=\"item_name\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<!-- 游戏类型 -->\n\t\t\t\t\t\t\t<div class=\"form-group\">\n\t\t\t\t\t\t\t\t<label for=\"edit_item_price\" class=\"col-sm-2 control-label\">类型</label>\n\t\t\t\t\t\t\t\t<div class=\"col-sm-10\">\n\t\t\t\t\t\t\t\t\t<input type=\"text\" class=\"form-control\" id=\"edit_item_price\" placeholder=\"类型\" name=\"item_price\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<!-- 游戏原价 -->\n\t\t\t\t\t\t\t<div class=\"form-group\">\n\t\t\t\t\t\t\t\t<label for=\"edit_item_price\" class=\"col-sm-2 control-label\">原价</label>\n\t\t\t\t\t\t\t\t<div class=\"col-sm-10\">\n\t\t\t\t\t\t\t\t\t<input type=\"text\" class=\"form-control\" id=\"edit_item_price\" placeholder=\"原价\" name=\"item_price\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</form>  \n                    </div>\n                        <div class=\"modal-footer\">\n                            <button type=\"button\" class=\"btn btn-default btn-sm\" data-dismiss=\"modal\">取消</button>\n                            <button type=\"button\" class=\"btn btn-primary btn-sm\" onclick=\"updateItem()\">确认修改</button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            \n             <!-- add layer -->\n            <div class=\"modal fade\" id=\"addLayer\">\n                <div class=\"modal-dialog modal-content\">\n                    <div class=\"modal-content\">\n                        <div class=\"modal-header\">\n                            <button type=\"button\" class=\"close\" data-dismiss=\"modal\"><span aria-hidden=\"true\">&times;</span><span class=\"sr-only\">Close</span></button>\n                            <h4 class=\"modal-title\">新增游戏</h4>\n                        </div>\n                   \t<div class=\"modal-body\">\n                        <!--添加游戏弹出层表单-->\n\t                    <form class=\"form-horizontal\" id=\"add_item_form\">\n\t                    \t<!-- 游戏id隐藏域 -->\n\t\t\t\t\t\t\t<input type=\"hidden\" id=\"add_item_id\" name=\"item_id\"/>\n\t\t\t\t\t\t\t<!-- 游戏名称 -->\n\t\t\t\t\t\t\t<div class=\"form-group\">\n\t\t\t\t\t\t\t\t<label for=\"add_item_name\" class=\"col-sm-2 control-label\">游戏名称</label>\n\t\t\t\t\t\t\t\t<div class=\"col-sm-10\">\n\t\t\t\t\t\t\t\t\t<input type=\"text\" class=\"form-control\" id=\"add_item_name\" placeholder=\"游戏名称\" name=\"item_name\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<!-- 游戏类型 -->\n\t\t\t\t\t\t\t<div class=\"form-group\">\n\t\t\t\t\t\t\t\t<label for=\"add_item_price\" class=\"col-sm-2 control-label\">类型</label>\n\t\t\t\t\t\t\t\t<div class=\"col-sm-10\">\n\t\t\t\t\t\t\t\t\t<input type=\"text\" class=\"form-control\" id=\"add_item_price\" placeholder=\"类型\" name=\"item_price\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<!-- 游戏原价 -->\n\t\t\t\t\t\t\t<div class=\"form-group\">\n\t\t\t\t\t\t\t\t<label for=\"add_item_price\" class=\"col-sm-2 control-label\">原价</label>\n\t\t\t\t\t\t\t\t<div class=\"col-sm-10\">\n\t\t\t\t\t\t\t\t\t<input type=\"text\" class=\"form-control\" id=\"add_item_price\" placeholder=\"原价\" name=\"item_price\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</form>  \n                    </div>\n                        <div class=\"modal-footer\">\n                            <button type=\"button\" class=\"btn btn-default btn-sm\" data-dismiss=\"modal\">取消</button>\n                            <button type=\"button\" class=\"btn btn-primary btn-sm\" onclick=\"addItem()\">确认修改</button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            \n            <!-- main menu -->\n            <nav id=\"main_menu\">\n                <div class=\"menu_wrapper\">\n                    <ul>\n                        <li class=\"first_level\">\n                            <a href=\"javascript:void(0)\">\n                                <span class=\"icon_document_alt first_level_icon\"></span>\n                                <span class=\"menu-title\">游戏管理</span>\n                            </a>\n                            <ul>\n                                <li class=\"submenu-title\">游戏管理</li>\n                                <!-- <li><a href=\"#\" data-toggle=\"modal\" data-target=\"#addLayer\">商品添加</a></li> -->\n                                <li><a href=\"${pageContext.request.contextPath }/item/list.do\">游戏列表</a></li>\n                            </ul>\n                        </li>\n                    </ul>\n                </div>\n                <div class=\"menu_toggle\">\n                    <span class=\"icon_menu_toggle\">\n                        <i class=\"arrow_carrot-2left toggle_left\"></i>\n                        <i class=\"arrow_carrot-2right toggle_right\" style=\"display:none\"></i>\n                    </span>\n                </div>\n            </nav>\n        </div>\n\n        <script type=\"text/javascript\">\n\t        $(function() {\n\t            //footable\n\t            yukon_footable.goodslist();\n\t            //datepicker\n\t            yukon_datepicker.p_forms_extended();\n\t        })\n\t        \n\t        //修改弹框回显\n\t       \tfunction toEdit(id) {\n\t   \t\t\t$.ajax({\n\t   \t\t\t\ttype:\"post\",\n\t   \t\t\t\turl:\"${pageContext.request.contextPath }/item/toEdit\",\n\t   \t\t\t\tdata:{\"id\":id},\n\t   \t\t\t\tsuccess:function(data) {\n\t   \t\t\t\t\t$(\"#edit_item_name\").val(data.item_name);\n\t   \t\t\t\t\t$(\"#edit_item_type\").val(data.item_type);\n\t   \t\t\t\t\t$(\"#edit_item_price\").val(data.item_price);\n\t   \t\t\t\t},\n\t   \t\t\t\tdataType:\"json\"\n\t   \t\t\t});\n\t   \t\t}\n\t        //确认修改\n\t\t\tfunction updateItem() {\n\t\t\t\t$.post(\n\t\t\t\t\t\"${pageContext.request.contextPath }/item/update.do\",\n\t\t\t\t\t$(\"#edit_item_form\").serialize(),\n\t\t\t\t\tfunction(data){\n\t\t\t\t\t\talert(\"游戏信息更新成功!\");\n\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t        //确认删除\n\t\t\tfunction deleteItem(id) {\n\t\t\t\tif(confirm('确实要删除该游戏吗?')) {\n\t\t\t\t\t$.post(\n\t\t\t\t\t\t\"${pageContext.request.contextPath }/item/delete.do\",\n\t\t\t\t\t\t{\"id\":id},\n\t\t\t\t\t\tfunction(data){\n\t\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t        //添加游戏\n\t\t\tfunction addItem() {\n\t\t\t\t$.post(\n\t\t\t\t\t\"${pageContext.request.contextPath }/item/save.do\",\n\t\t\t\t\t$(\"#add_item_form\").serialize(),\n\t\t\t\t\tfunction(data){\n\t\t\t\t\t\talert(\"游戏添加成功!\");\n\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t});\n\t\t\t}\n\t\t</script>\n    </body>\n</html>\n```\n\n\n\n# SPRINGMVC-PROJECT-2\n## 新增登录拦截器与集成配置文件\n### 登录拦截器LoginIntercaptor.java\n```java\npublic class LoginInterceptor implements HandlerInterceptor {\n\n\t@Override\n\tpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\t\t\n\t\t//获取请求\n\t\tString URI = request.getRequestURI();\n\t\t\n\t\tif(!URI.contains(\"login\")) {\n\t\t\t//不是登录请求 拦截\n\t\t\tObject user = request.getSession().getAttribute(\"user\");\n\t\t\t\n\t\t\tif(user == null) {\n\t\t\t\t//没有登录 重定向到登录页面 / 请求\n\t\t\t\tresponse.sendRedirect(request.getContextPath()+\"/login/login.do\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n```\n\n### 集成配置文件 applicationContext.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:aop=\"http://www.springframework.org/schema/aop\"\n\txmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n\txmlns:tx=\"http://www.springframework.org/schema/tx\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd\n\t\thttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\n\t\thttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\n\t\thttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd\">\n\t\t\n\t\t<!-- 读取配置文件 数据库 -->\n\t\t<context:property-placeholder location=\"classpath:db.properties\"/>\n\t\t\n\t\t<!-- 配置数据源 -->\n\t\t<bean name=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n\t\t\t<property name=\"driverClass\" value=\"${jdbc.driverClass}\"/>\n\t\t\t<property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/>\n\t\t\t<property name=\"user\" value=\"${jdbc.user}\"/>\n\t\t\t<property name=\"password\" value=\"${jdbc.password}\"/>\n\t\t</bean>\n\t\n\t\t<!-- 开启注解扫描 -->\n\t\t<context:component-scan base-package=\"com.sikiedu\"></context:component-scan>\n\t\t\n\t\t<!-- 静态资源放行 -->\n\t\t<mvc:resources location=\"/css/\" mapping=\"/css/**\"/>\n\t\t<mvc:resources location=\"/fonts/\" mapping=\"/fonts/**\"/>\n\t\t<mvc:resources location=\"/js/\" mapping=\"/js/**\"/>\n\t\t<mvc:resources location=\"/picture/\" mapping=\"/picture/**\"/>\n\t\t\n\t\t<!-- 开启注解驱动 -->\n\t\t<mvc:annotation-driven/>\n\t\t\n\t\t<!-- 事务核心管理器 -->\n\t\t<bean name=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t\t\t<property name=\"dataSource\" ref=\"dataSource\"/>\n\t\t</bean>\n\t\t\n\t\t<!-- 开启注解事务 -->\t\t\n\t\t<tx:annotation-driven/>\n\t\t\n\t\t<!-- 配置视图解析器 -->\n\t\t<bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t\t<property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\n\t\t\t<property name=\"suffix\" value=\".jsp\"/>\n\t\t</bean>\n\t\t\n\t\t<!-- 配置mybatis -->\n\t\t<bean name=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n\t\t\t<property name=\"dataSource\" ref=\"dataSource\"/>\n\t\t\t<property name=\"typeAliasesPackage\" value=\"com.sikiedu.bean\"/>\n\t\t</bean>\n\t\t\n\t\t<!-- mapper工厂 -->\n\t\t<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n\t\t\t<property name=\"basePackage\" value=\"com.sikiedu.mapper\"/>\n\t\t</bean>\n\t\t\n\t\t<mvc:interceptors>\n\t\t\t<!-- 登录验证拦截器 -->\n\t\t\t<mvc:interceptor>\n\t\t\t\t<mvc:mapping path=\"/**\"/>\n\t\t\t\t<mvc:exclude-mapping path=\"/**/*.css\"/>\n\t\t\t\t<mvc:exclude-mapping path=\"/**/*.js\"/>\n\t\t\t\t<mvc:exclude-mapping path=\"/**/*.png\"/>\n\t\t\t\t<mvc:exclude-mapping path=\"/**/*.tff\"/>\n\t\t\t\t<mvc:exclude-mapping path=\"/**/*.woff\"/>\n\t\t\t\t<bean class=\"com.sikiedu.interceptor.LoginInterceptor\"/>\n\t\t\t</mvc:interceptor>\n\t\t</mvc:interceptors>\n</beans>\n```","tags":["SSM学习笔记"],"categories":["SSM学习笔记"]},{"title":"翻译作品-大数据","url":"/2021/03/16/翻译作品-大数据/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n\n## Big Data In 5 Minutes | What Is Big Data?| 5分钟大数据|什么是大数据\n## Introduction To Big Data |Big Data Explained |Simplilearn 大数据入门\nThis video will help you understand what Big Data is, the 5V's of Big Data, why Hadoop came into existence, and what Hadoop is. You will also learn about the storage unit and processing unit of Hadoop, and the implementation of Big Data through use cases. In the end, we will have a quiz on Hadoop. A massive amount of data that cannot be stored, processed, and analyzed using the traditional ways is known as Big Data. Hadoop is a framework that manages Big Data storage in a distributed way and processes it parallelly. Now, let's deep dive into this video and understand Big Data and Hadoop. \n\n本视频将帮助您理解什么是大数据，大数据的5V, Hadoop为什么会出现，以及Hadoop是什么。通过用例了解Hadoop的存储单元和处理单元，以及大数据的实现。最后，我们会有一个关于Hadoop的测试。大量的数据无法通过传统的方式进行存储、处理和分析，这就是所谓的大数据。Hadoop是一个以分布式方式管理大数据存储并并行处理的框架。现在，让我们深入研究这个视频，了解大数据和Hadoop。\n\n<div style=\"position: relative; padding: 30% 45%;\">\n<iframe style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\" \nsrc=\"https://player.bilibili.com/player.html?aid=756891724&bvid=BV1Wr4y1A7MX&cid=305097153&page=1\"\n frameborder=\"no\" scrolling=\"no\"></iframe>\n</div>","tags":["翻译作品"],"categories":["翻译作品"]},{"title":"Spring学习笔记(所有代码FROM SIKI学院)","url":"/2021/03/16/Spring/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# SSM框架系列之二 大管家Spring\n## Spring是什么？\n\nSpring是于2003 年兴起的一个轻量级的Java 开源框架，它由Rod Johnson创建。传统J2EE应用的开发效率低，Spring作为开源的中间件，提供J2EE应用的各层的解决方案，Spring贯穿了表现层、业务层及持久层，而不是仅仅专注于某一层的方案。可以说Spring是企业应用开发的“一站式（full-stack）”选择。然而，Spring并不想取代那些已有的框架，而是与它们无缝地整合。\n简单来说，Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。\n\n为什么要使用Spring？\n1. 方便解耦，简化开发\n通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。\n\n2. AOP编程的支持\n通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。\n\n3. 声明式事务的支持\n在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。\n\n4. 方便程序的测试\n可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。\n\n5. 方便集成各种优秀框架\nSpring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts、Hibernate、MyBatis 、Hessian、Quartz）等的直接支持。\n\n6. 降低Java EE API的使用难度\nSpring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。\n\n## 我能从这门课中学到什么？\n1. 了解Spring框架、IOC、DI的概念；\n2. 掌握Spring框架搭建、配置与使用；\n3. 掌握Spring容器创建与对象管理；\n4. 掌握Spring xml配置式开发与注解开发；\n5. 掌握Spring AOP相关知识；\n6. 掌握SpringJDBC相关知识；\n7. 将Spring集成项目中进行测试；\n\n\n# 开始学习Spring框架\n\n## Part.1 Spring框架介绍与入门案例：\n1、搭建Spring HelloWorld项目\n\ta)Spring下载：http://repo.spring.io/release/org/springframework/spring/\n\tb)导包：（以下5个包称为基本包，根据你使用的版本可能还需导入log4j包，咱们学习的版本暂时无需导入）\n\t\ti.核心包：bean、context、core、expression；\n\t\tii.日志包：apache.commons.logging\n\tc)引入约束：bean约束和引入主配置文件头；\n\td)测试：将自定义对象由自己创建交由Spring管理；\n\t\n2、SpringIDE - sts插件安装；\n\ta)下载地址：http://spring.io/tools/sts/all/\n\tb)安装springIDE；\n\t\tSpring-IoC | DI概念介绍：（要实现IOC依赖DI的支持）\n\t\tIoC（Inversion of Control）：反转控制：将我们自己创建对象的工作交给Spring容器帮我们完成； \n\t\tDI（Dependency Injection）：依赖注入：将值通过配置的方式为变量初始化/赋值(注入)；\n\tc)注入方式：set方法注入、构造注入、字段注入(不推荐)； \n\td)注入类型： \n\t\ti.值类型(value) – 八大基本数据类型；\n\t\tii.引用类型(ref) – String、自定义对象；\n\n## Part.2 Spring配置：\n1、Xml配置\t\na)Bean元素：交由Spring管理的对象都要配置在bean标签中；\ni.Bean标签介绍和创建方式：空参构造、静态工厂、动态工厂；\nii.Scope属性介绍：singleton、protoptype、request、session；\niii.初始化方法Init-method和 销毁方法destroy-method介绍；\nb)属性注入：\ni.Set方法注入；\nii.构造函数注入；\niii.复杂类型注入：Array、List、Set、Map、Properties\n\n2、Spring注解配置；\na)导包和约束：基本包、aop包+context约束；\nb)将对象注册到容器内；\nc)用注解配置Scope属性； \nd)注解配置init-method与destroy-method； \ne)注解配置属性注入，值类型与引用类型； \n\n3、Spring & JUnit进行测试：\na)导包： test包（依赖 aop包）；\nb)使用@RunWith注解创建spring容器；\nc)使用@ContextConfiguration读取spring配置文件；\n4、主配置文件的分包配置；\n\n## Part.3 小结与练习：将Spring应用到servlet项目中 \n1、使用servlet技术开发用户登陆功能；\n2、在项目中加入Spring框架\ni.将service、dao、dateSource交给Spring管理；\nii.在web.xml中配置Spring监听器和读取配置文件；\n\n\n## Part.4 Spring-aop：\n1、aop思想介绍（面向切面编程）：将纵向重复代码，横向抽取解决，简称：横切\n2、Spring中的aop：无需我们自己写动态代理的代码，spring可以将容器中管理对象生成动态代理对象，前提是我们对他进行一些设置；\n3、Spring-aop是基于动态代理的 – 优先选用JDKProxy动态代理；\na)Proxy动态代理：被代理的对象必须要实现接口；\nb)Cglib动态代理：被代理的对象不能被final修饰，基于继承；\n4、Spring aop相关名词说明 – 详见 表-[Spring术语解释]；\n5、Spring aop配置：\na)导包：\ni.基本包；\nii.spring-aspects和spring-aop ；\niii.aop联盟包 – aopalliance；\niv.aop织入包 - aspectj.weaver；\nb)自定义通知，五种自定义通知类型：\ni.before 前置通知\nii.after 最终通知（后置通知）\niii.afterReturning 成功通知（后置通知）\niv.afterThrowing 异常通知（后置通知）\nv.around 环绕通知\nc)配置applicationContext.xml：\n\n## Part.5 Spring与Jdbc \n1、使用JdbcTemplate操作数据库；\na)导包：新增jdbc、tx\n2、JdbcTemplate的增删改查操作；\n3、让Spring容器管理JdbcTemplate；\n4、继承JdbcDaoSupport甩开JdbcTemplate；\n5、在Spring中读取配置文件；\n\n## Part.6 Spring中的aop事务\n1、事务相关知识：\na)什么是事务：把多条数据库操作捆绑到一起执行，要么都成功，要么都失败；\nb)事务的原则ACID：\ni.原子性：事务包含的所有操作，要么全部成功，要么全部失败回滚，成功全部应用到数据库，失败不能对数据库有任何影响；\nii.一致性：事务在执行前和执行后必须一致；例如A和B一共有100块钱，无论A、B之间如何转账，他们的钱始终相加都是100；\niii.隔离性：多用户并发访问同一张表时，数据库为每一个用户开启新的事务，该事务不能被其他事务所影响，相互有隔离；\niv.持久性：一个事务一旦提交，则对数据库中数据的改变是永久的，即便系统故障也不会丢失；\nc)并发可能引起的问题：\ni.脏读：一个事务读取到另一个事务未提交的数据；\nii.不可重复读：一个事务读取到另一个事务已提交(Update操作)的数据，导致前后读取不一致； \niii.幻读（虚读）：一个事务中读取到别的事务插入(Insert操作)的数据，导致前后读取不一致；\nd)事务的隔离级别：根据实际情况选择；\ni.Serializable串行化：可避免脏读、不可重复读和幻读；\nii.Repeatable read可重复读：可避免脏读、不可重复读；（MySql默认值）\niii.Read committed读已提交：可避免脏读；\niv.Read uncommitted读未提交：任何情况都无法保证；\n2、Spring-aop事务-搭建环境； \na)事务基本操作：打开事务、提交事务、回滚事务；\nb)Spring中利用接口来管理不同框架的事务操作；\ni.通过实现PlatformTransactionManager接口支持不同的框架完成各自的事务处理；\nii.为不同平台提供对应的事务管理器的实现：\nJDBC&Mybatis：DataSourceTransactionManager；\n…\nc)Spring-aop事务通过配置事务的隔离级别、事务传播行为、是否只读来操作；\ni.隔离级别：串行化、可重复读、读已提交、读未提交；\nii.是否只读：\n1.true：不可改变数据库中的数据，查询操作推荐，\n2.false：可以改变数据库数据；\niii.事务传播行为：事务方法嵌套调用的规则：\nxService.x();\t->\tyService.y();\n1.REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置；\n2.REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务；\n3.SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行；\n4.NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起（暂停）；\n5.MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常；\n6.NEVER：以非事务方式执行，如果当前存在事务，则抛出异常；\n7.NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与REQUIRED类似的操作。\n\n3、Spring-aop事务 – 从麻烦的事务代码中走出之xml配置版aop事务；\na)使用经典的转账案例进行测试，准备数据：bean、service、dao；\nb)使用事务需要额外导入tx包和tx约束；\nc)配置事务核心管理器: DataSourceTransactionManager；\nd)配置事务通知 tx:Advice；\ne)配置aop；\n4、Spring-aop事务 – 从麻烦的事务代码中走出之注解版aop事务。\n\n# Part.7 Spring整合Mybatis加入事务操作数据库\n1、整合Mybatis\na)导包：\ni.Spring：基本包、aop、aspects、jdbc、tx、test；\nii.Mybatis：mybatis-3.4.6\niii.整合包：mybatis-spring-1.3.2\niv.三方包：\n1.aopalliance\n2.aspectj.weaver\n3.c3p0-0.9.5.2\n4.mchange-commons-java-0.2.11\n5.mysql-connector-java-5.1.46-bin\n6.ojdbc7\nb)创建项目结构(package)：bean、service、mapper、test；\nc)创建配置文件：sqlMapperConfig、applicaitonContext\n2、创建测试用例：使用Mapper扫描开发，转账；\n3、在service中加入事务：利用Spring-aop事务解决转账异常问题；\n\n# Spring实例一 纯Spring\n## applicationContext.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \nxmlns=\"http://www.springframework.org/schema/beans\" \nxsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd \">\n\n<!-- name 是起一个名字，我们可以通过这个name来利用容器获取对象 \n\tname 可以使用特殊字符\n\tname 可以重复 \n\t我们在实际开发中不推荐将多个对象名字命名为重复的-->\n\t\n<!-- id与name作用基本相同，单不推荐使用 不支持特殊字符，不能重复 -->\n<!-- class：是被管理对象的全包名，spring会通过这个包名来创建对象 -->\n<!-- request 在web环境下，如果scope属性为request 那么这个对象被创建出来 他的生命周期会与request请求一致-->\n<!-- session 同理 ，生命周期与session一致 -->\n\n<bean name=\"user\" class=\"com.sikiedu.bean.User\" lazy-init=\"default\" scope=\"prototype\" init-method=\"userInit\" destroy-method=\"userDestroy\">\n\t<property name=\"u_id\" value=\"2\"></property>\n</bean>\n\n<!-- 导入其他Spring的配置文件 -->\n<import resource=\"/applicationContext_Injection.xml\"/>\n\n</beans>\n```\n\n## User Bean对象\n```java\npublic class User {\n\n\tprivate Integer u_id;\n\tprivate String u_username;\n\tprivate String u_password;\n\n\t\n\tpublic User(String u_username, Pet u_pet) {\n\t\tSystem.out.println(\"方法1 String, Pet\");\n\t\tthis.u_username = u_username;\n\t\tthis.u_pet = u_pet;\n\t}\n\t\n\tpublic User(Integer u_username, Pet u_pet) {\n\t\tSystem.out.println(\"方法2 Integer, Pet\");\n\t\tthis.u_username = u_username.toString();\n\t\tthis.u_pet = u_pet;\n\t}\n\t\n\tpublic User(Pet u_pet, Integer u_username) {\n\t\tSystem.out.println(\"方法3 Pet, Integer \");\n\t\tthis.u_username = u_username.toString();\n\t\tthis.u_pet = u_pet;\n\t}\n\t\n\t//加入宠物字段\n\tprivate Pet u_pet;\n\t\n\tpublic Pet getU_pet() {\n\t\treturn u_pet;\n\t}\n\tpublic void setU_pet(Pet u_pet) {\n\t\tthis.u_pet = u_pet;\n\t}\n\tpublic User() {\n\t\tSystem.out.println(\"User 对象空参构造方法\");\n\t}\n\tpublic Integer getU_id() {\n\t\treturn u_id;\n\t}\n\tpublic void setU_id(Integer u_id) {\n\t\tthis.u_id = u_id;\n\t}\n\tpublic String getU_username() {\n\t\treturn u_username;\n\t}\n\tpublic void setU_username(String u_username) {\n\t\tthis.u_username = u_username;\n\t}\n\tpublic String getU_password() {\n\t\treturn u_password;\n\t}\n\tpublic void setU_password(String u_password) {\n\t\tthis.u_password = u_password;\n\t}\n\t\n\tpublic void userInit() {\n\t\tSystem.out.println(\"user init \");\n\t}\n\t\n\tpublic void userDestroy() {\n\t\tSystem.out.println(\"user destroy\");\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn \"User [u_id=\" + u_id + \", u_username=\" + u_username + \", u_password=\" + u_password + \", u_pet=\" + u_pet\n\t\t\t\t+ \"]\";\n\t}\n}\n```\n\n## Test 测试方法主函数\n```java\npackage com.sikiedu.test;\n\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport com.sikiedu.bean.User;\n\npublic class HelloSpring {\n\t\n\t//在之前项目中 new 对象是我们自己做的\n\t@Test\n\tpublic void Test1() {\n\t\t//User u = new User();\n\t\t//u.setU_id(1);\n\t\t//System.out.println(u);\n\t}\n\t\n\t\n\t//IOC的反转：创建对象这份工作由我们自己执行反转给spring帮我们执行；\n\t//IOC的控制：就是由spring帮我们负责创建销毁对象，掌控对象的生命周期等，我们在需要使用对象的时候跟Spring申请即可；\n\t//IOC是一种编程思想，也是一种新的设计模式，它需要DI（依赖注入）技术的支持；\n\t\n\t//spring是一个容器，它将帮我们管理对象\n\t@Test\n\tpublic void Test2() {\n\t\t\n\t\t//根据spring配置文件获取容器对象\n\t\t//ApplicationContext 配置的所有bean都会在容器创建的时候被创建出来\n\t\t//如果配置的bean较多，那么在创建容的时候，会产生内存过大的问题；这种情况在机器硬件性能较为落后的时候体现的比较明显；\n\t\t//延迟加载 true就是创建容器时不加载配置的bean对象，在获取的时候才创建；\n\t\tApplicationContext ac = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\t\t\n\t\t//通过getBean获取配置好的user对象（程序员向spring容器要对象）\n\t\t//User u = (User) ac.getBean(\"user\");\n\t\tUser u = ac.getBean(User.class);\n\t\t//System.out.println(u);\n\t\t\n\t\t\n\t}\n}\n```\n\n\n# Spring实例二 Spring+Mybatis\n## Bean对象 Account.java\n```java\npublic class Account {\n\tprivate Integer id;\n\tprivate String name;\n\tprivate Double money;\n\t\n\t...忽略set，get，toString方法\n}\n```\n## Mapper.java文件以及Mapper.xml文件\n### AcountMapper.java\n\n```java\n\npublic interface AccountMapper {\n\t//操作数据库扣款和加款\n\t\n\t//扣款\n\tvoid subMoney(Account pay);\n\t\n\t\n\t//加款\n\tvoid addMoney(Account collect);\n}\n\n```\n\n### AcountMapper.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.sikiedu.mapper.AccountMapper\">\n\t<update id=\"subMoney\" parameterType=\"Account\">\n\t\tupdate account set money = money - #{tranferMoney} where id = #{id}\n\t</update>\n\t\n\t<update id=\"addMoney\" parameterType=\"Account\">\n\t\tupdate account set money = money + #{tranferMoney} where id = #{id}\n\t</update>\n</mapper>\n```\n## Service层以及实现Impl类\n### AccountService.java\n```java\n\npublic interface AccountService {\n\t\n\t//转账方法\n\tvoid updateTranferAccount();\n}\n\n```\n\n### AccountServiceImpl.java\n```java\npackage com.sikiedu.service;\n\nimport javax.annotation.Resource;\n\nimport com.sikiedu.bean.Account;\nimport com.sikiedu.mapper.AccountMapper;\n\npublic class AccountServiceImpl implements AccountService {\n\t\n\t@Resource(type=AccountMapper.class)\n\tprivate AccountMapper mapper;\n\t\n\t@Override\n\tpublic void updateTranferAccount() {\n\t\t\n\t\tDouble tranferMoney = 1000d;\n\t\tAccount pay = new Account();\n\t\t\n\t\tpay.setId(1);\n\t\tpay.setTranferMoney(tranferMoney);\n\t\t\n\t\t//先扣款\n\t\tmapper.subMoney(pay);\n\t\t\n\t\tint a = 1/0;\n\t\tAccount collect = new Account();\n\t\tcollect.setId(2);\n\t\tcollect.setTranferMoney(tranferMoney);\n\t\t//加款\n\t\tmapper.addMoney(collect);\n\n\t}\n}\n```\n\n## 主函数调用\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class MapperTest {\n\t\n\t@Resource(name=\"accountService\")\n\tprivate AccountService as;\n\t\n\t@Test\n\tpublic void Test1() {\n\t\tas.updateTranferAccount();\n\t}\n\t\n}\n```\n\n## Spring配置文件\n### applicationContext.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:context=\"http://www.springframework.org/schema/context\"\n\txmlns:aop=\"http://www.springframework.org/schema/aop\"\n\txmlns:tx=\"http://www.springframework.org/schema/tx\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n\t\thttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\n\t\thttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\n\t\thttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd\">\n\t\t\n\t<!-- 读取配置文件 -->\n\t<context:property-placeholder location=\"db.properties\"/>\n\t\n\t<!-- 配置 dataSource -->\n\t<!-- db.properties文件中分别有-->\n\t<!-- jdbc.driverClass=com.mysql.jdbc.Driver -->\n\t<!-- jdbc.jdbcUrl=jdbc:mysql://localhost:3306/ssm_spring -->\n\t<!-- jdbc.user=root -->\n\t<!-- jdbc.password=123 -->\n\t<bean name=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n\t\t<property name=\"driverClass\" value=\"${jdbc.driverClass}\"/>\n\t\t<property name=\"jdbcUrl\" value=\"${jdbc.jdbcUrl}\"/>\n\t\t<property name=\"user\" value=\"${jdbc.user}\"/>\n\t\t<property name=\"password\" value=\"${jdbc.password}\"/>\n\t</bean>\n\t\n\t<!-- mybatis -->\n\t<bean name=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n\t\t<property name=\"dataSource\" ref=\"dataSource\"/>\n\t\t<property name=\"configLocation\" value=\"classpath:sqlMapConfig.xml\"/>\n\t</bean>\n\t\n\t<!-- mapper工厂 -->\n\t<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n\t\t<property name=\"basePackage\" value=\"com.sikiedu.mapper\"/>\n\t</bean>\n\t\n\t<!-- service -->\n\t<bean name=\"accountService\" class=\"com.sikiedu.service.AccountServiceImpl\"></bean>\n\t\n\t<!-- 需要事务核心管理器 -->\n\t<bean name=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t\t<property name=\"dataSource\" ref=\"dataSource\"/>\n\t</bean>\n\t\n\t<!-- 配置事务通知 -->\n\t<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n\t\t<tx:attributes>\n\t\t\t<tx:method name=\"update*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" read-only=\"false\"/>\n\t\t</tx:attributes>\n\t</tx:advice>\n\t\n\t<!-- 配置aop -->\n\t<aop:config>\n\t\t<aop:pointcut expression=\"execution(* com.sikiedu.service.*ServiceImpl.*(..))\" id=\"txPc\"/>\n\t\t<aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPc\"/>\n\t</aop:config>\n\t\n</beans>mapper工厂 -->\n\t<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n\t\t<property name=\"basePackage\" value=\"com.sikiedu.mapper\"/>\n\t</bean>\n\t\n\t<!-- service -->\n\t<bean name=\"accountService\" class=\"com.sikiedu.service.AccountServiceImpl\"></bean>\n\t\n\t<!-- 需要事务核心管理器 -->\n\t<bean name=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t\t<property name=\"dataSource\" ref=\"dataSource\"/>\n\t</bean>\n\t\n\t<!-- 配置事务通知 -->\n\t<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n\t\t<tx:attributes>\n\t\t\t<tx:method name=\"update*\" isolation=\"DEFAULT\" propagation=\"REQUIRED\" read-only=\"false\"/>\n\t\t</tx:attributes>\n\t</tx:advice>\n\t\n\t<!-- 配置aop -->\n\t<aop:config>\n\t\t<aop:pointcut expression=\"execution(* com.sikiedu.service.*ServiceImpl.*(..))\" id=\"txPc\"/>\n\t\t<aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPc\"/>\n\t</aop:config>\n\t\n</beans>\n\n```\n\n## Mybatis配置文件\n### sqlMapConfig.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n  \n  <configuration>\n  \t<typeAliases>\n  \t\t<package name=\"com.sikiedu.bean\"/>\n  \t</typeAliases>\n  </configuration>\n```\n\n# Spring实例三 Spring+AOP\n## 自定义通知类 MyAdvice.java\n```java\npublic class MyAdvice {\n\n\t//before 前置通知 在目标方法前调用\n\tpublic void before() {\n\t\tSystem.out.println(\"before\");\n\t}\n\t\n\t//after 最终通知（后置通知）在目标方法后调用，无论是否出现异常都会执行 finally\n\tpublic void after() {\n\t\tSystem.out.println(\"after\");\n\t}\n\t\n\t//afterReturning 成功通知（后置通知）在目标方法执行后，并且执行成功，如果方法出现异常则不调用\n\tpublic void afterReturning() {\n\t\tSystem.out.println(\"afterReturning\");\n\t}\n\t\n\t//afterThrowing 异常通知（后置通知）在目标方法执行出现异常的时候才会调用\n\tpublic void afterThrowing() {\n\t\tSystem.out.println(\"afterThrowing\");\n\t}\n\t\n\t//around 环绕通知 需要我们手动调用目标方法，并且可以设置通知\n\tpublic Object around(ProceedingJoinPoint pjp) throws Throwable {\n\t\tSystem.out.println(\"around before\");\n\t\tObject proceed = pjp.proceed();\n\t\tSystem.out.println(\"around after\");\n\t\treturn proceed;\n\t}\n}\n```\n\n## Service以及实现类impl\n### UserService.java\n```java\npublic interface UserService {\n\t//增\n\tvoid save();\n\t//删\n\tvoid delete();\n\t//改\n\tvoid update();\n\t//查\n\tvoid find();\n}\n```\n\n### UserServiceImpl.java\n```java\npublic class UserServiceImpl implements UserService {\n\t@Override\n\tpublic void save() {\n\t\tSystem.out.println(\"save\");\n\t}\n\t@Override\n\tpublic void delete() {\n\t\tSystem.out.println(\"delete\");\n\t\t//int a = 1/0;\n\t}\n\t@Override\n\tpublic void update() {\n\t\tSystem.out.println(\"update\");\n\t}\n\t@Override\n\tpublic void find() {\n\t\tSystem.out.println(\"find\");\n\t}\n}\n```\n\n## Spring配置文件 applicationContext.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns:aop=\"http://www.springframework.org/schema/aop\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n\t\thttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\">\n\t\t\n\t\t<!-- 目标对象 -->\n\t\t<bean name=\"userService\" class=\"com.sikiedu.service.UserServiceImpl\"></bean>\n\t\t\n\t\t<!-- 通知对象 -->\n\t\t<bean name=\"myAdvice\" class=\"com.sikiedu.aop.MyAdvice\"></bean>\n\t\t\n\t\t<aop:config>\n\t\t\t<!-- 切入点  expression 切入点表达式 可以配置要增强的方法\n\t\t\t\t\t\t\t\tpublic void com.sikiedu.service.UserServiceImpl.save()\n\t\t\t\t\t\t\t\t* com.sikiedu.service.*ServiceImpl.*(..)\n\t\t\t\t\t\t\t   id 就是唯一标识\n\t\t\t-->\n\t\t\t<aop:pointcut expression=\"execution(* com.sikiedu.service.*ServiceImplabc.*(..))\" id=\"servicePc\"/>\n\t\t\t\n\t\t\t<!-- 切面 通知+切入点 -->\n\t\t\t<aop:aspect ref=\"myAdvice\">\n\t\t\t\t<!-- 通知类型 -->\n\t\t\t\t<aop:before method=\"before\" pointcut-ref=\"servicePc\"/>\n\t\t\t\t<!-- 最终通知 后置通知 -->\n\t\t\t\t<aop:after method=\"after\" pointcut-ref=\"servicePc\"/>\n\t\t\t\t<!-- 成功通知 后置通知 -->\n\t\t\t\t<aop:after-returning method=\"afterReturning\" pointcut-ref=\"servicePc\"/>\n\t\t\t\t<!-- 异常通知 后置通知 -->\n\t\t\t\t<aop:after-throwing method=\"afterThrowing\" pointcut-ref=\"servicePc\"/>\n\t\t\t\t<!-- 环绕通知 -->\n\t\t\t\t<aop:around method=\"around\" pointcut-ref=\"servicePc\"/>\n\t\t\t</aop:aspect>\n\t\t</aop:config>\n\t\t\n</beans>\n```\n\n## 主函数测试方法\n### AopTest.java\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class AopTest {\n\t\n\t@Resource(name=\"userService\")\n\tUserService us;\n\t\n\t@Test\n\tpublic void Test1() {\n\t\tUserServiceProxy usProxy = new UserServiceProxy();\n\t\tUserService us = new UserServiceImpl();\n\t\tUserService us_PowerUp = usProxy.getUserServiceProxy(us);\n\t\tus_PowerUp.find();\n\t}\n\t\n\t@Test\n\tpublic void Test2() {\n\t\tus.delete();\n\t}\n}\n```\n\n### UserServiceProxy.java\n```java\n\npackage com.sikiedu.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\nimport com.sikiedu.service.UserService;\nimport com.sikiedu.service.UserServiceImpl;\n\n/**\n * UserService代理类\n * @author Joey\n *\n */\npublic class UserServiceProxy {\n\t//UserServiceProxy\n\t//UserService\n\tpublic UserService getUserServiceProxy(UserService us) {\n\t\t\n\treturn (UserService) Proxy.newProxyInstance(UserServiceProxy.class.getClassLoader(), \n\t\tUserServiceImpl.class.getInterfaces(), \n\t\tnew InvocationHandler() {\n\t\t@Override\n\t\tpublic Object invoke(Object proxy, \n\t\t\t\tMethod method, \n\t\t\t\tObject[] args) throws Throwable {\n\t\t\t//增强代码\n\t\t\tSystem.out.println(\"开启事务\");\n\t\t\t//调用原始方法\n\t\t\tObject invoke = method.invoke(us, args);\n\t\t\tSystem.out.println(\"提交/回滚\");\n\t\t\treturn invoke;\n\t\t}\n\t\t});\n\t}\n\n}\n\n\n```","tags":["SSM学习笔记"],"categories":["SSM学习笔记"]},{"title":"JavaScript学习笔记","url":"/2021/03/15/JavaScript/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# 介绍\n## 前言\nJavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。—— 百度百科\n\n学习了HTML和CSS3后，我们可以对网页简单的静态“整容”，但是很难通过后期的需求来对网页动态的增删改查；因此，学习动态的脚本语言JavaScript（JS）是非常有必要的。\n\n# 正文\n## Java与JavaScript的关系\n<p>\n第一次学JS的时候，看到单词是JavaScript，总觉得是Java加上脚本script，\n\n因此心中一直有误解；<mark>其实，虽然JS是脚本语言不错，但是编程上是与Java没有任何关系的</mark>。\n</p>\n\n\n<table class=\"table table-bordered table-hover table-striped\">\n<tr>\n\t<td>JavaScript的特点</td>\n\t<td>Java的特点</td>\n</tr>\n<tr>\n\t<td>解释性语言，无需事先编译</td>\n\t<td>编译性语言，会检查语法，不正确无法通过运行</td>\n</tr>\n<tr>\n\t<td>基于对象，拥有封装的特性，但是没有继承与多态</td>\n\t<td>面向对象，拥有封装、继承、多态等特性</td>\n</tr>\n<tr>\n\t<td>事件源触发事件驱动</td>\n\t<td>主函数入口驱动</td>\n</tr>\n<tr>\n\t<td>依赖于浏览器，不同的浏览器可能导致效果不同</td>\n\t<td>跨平台使用，依赖于JVM（Java Virtual Machine)</td>\n</tr>\n<tr>\n\t<td>安全，依赖于浏览器但不访问硬盘</td>\n\t<td>安全与否取决于通过字节码检验</td>\n</tr>\n<tr>\n\t<td>弱变量，解释器自动通过变量值来判断类型</td>\n\t<td>强变量，变量声明时需要通过变量检查</td>\n</tr>\n<tr>\n\t<td>厂家是Netscape公司</td>\n\t<td>厂家是sum公司</td>\n</tr>\n</table>\n\n## JavaScript 基础\n\n### JavaScript 引用语法\n\n引用JavaScript的方法有三种，与CSS相似，可以在网页的头部引用，可以用script标签，也可以作为外部JS文件来引用。\n\n值得注意的是： 使用script标签时，我们最好放在元素后方 ，否则无法获取该DOM对象（将使用实例说明）。\n\n1. 使用 window.alert(\"内容\"); 弹出警告框\n\n2. 使用 document.write(\"内容\"); 写入网页文档中\n\n3. 改变DOM对象的 innerHTML 属性\n\n4. 使用控制台 console.log(\"内容\") 写入内容\n\n### JavaScript 语句与变量\n\n在JS中，我们用分号;隔开语句，<mark>但这也是可选的，只是建议为了编程规范用分号隔开每条语句</mark>；\n\n浏览器将依次按顺序执行每条语句。\n\n在JS中，我们用花括号{}隔开代码块，在代码块中区别不同的语句。\n\nJavaScript中的变量都是弱变量，即我们不需要像Java那样声明 int a = 1; String str = \"hello\"; 只需要全部统一使用 var v = 1; var str = \"hello\"; 进行声明与赋值，甚至连 var 都可以省去。\n\nJavaScript对大小写敏感，因此变量名为a和A是属于不同的两个变量；变量不能以数字开头，也可以 美元字符$ 和下划线_ 开头。\n\n```js\nvar a = 1;\n\nvar b = 2;\n\nvar c = a + b;\n\nwindows.alert(\"c的结果为:\" + c);\n```\n\n### JavaScript 注释\n\n在JS中，注释可分为单行与多行注释两种。\n\n单行注释使用双斜线 // 开始注释，并在后紧跟注释内容。多行注释使用 /** 注释内容 ***/  ，中间可以跨度若干行。\n\n### JavaScript 数据类型\nJavaScript中的基本类型有五种：\n\nString字符串、Number数字、Boolean布尔、NULL空值 和 Undefined未定义的值；\n\n而 引用数据类型 有:Object对象、 Array数组和Function函数。\n\n#### JavaScript 字符串 String\n\n存储字符的变量，我们称之为字符串变量，我们可以用单引号‘’或者双引号“”将任意文本包裹起来，\n\n但要求如果文本中需要引号，不与外部引号相同即可。即内单外双，内双外单。例如：\n\n```js\nvar pc = \"ASUS\";\n\nvar words = \"is the famous brand\";\n\nwindows.alert(pc + words);\n```\n\n我们可以使用 索引 来访问字符串中任何字符，使用数组的下标[x]，其中[x]从0开始（第一个字符）到n-1（最后一个字符）结束，n为字符串中字符的个数。\n\n使用定位索引 indexOf() 来从头定位某一个指定的字符首次出现的位置，出现的位置亦是从0开始；\n\n使用 lastIndexOf() 从末尾开始寻找第一次出现的位置。\n\n使用 replace() 方法在字符串中替换字符，例如：\n\n```js\nvar str1 = \"Apple is pretty good!\";\n\nvar str2 = str1.replace(\"Apple\", \"HuaWei\"); \n\nwindows.alert(str2);\n```\n\n使用 toUpperCase()和toLowerCase() 分别将字符小写转换成大写和大写转换为小写；\n\n使用 split(\"x\") 方法将字符串转换为数组，其中引号中的内容为分隔成数组的要求。\n\n**JavaScript中String字符串的常用方法及说明：**\n```js\ncharAt(x) //返回位于x处的字符（0~length()-1)\n\t\ncompareTo(str2) //str1使用该方法，与str2按字典序进行比较，结果为0，小于0，大于0的数，分别代表字符相等，str1小于str2与str1大于str2\n\t\nmatches(reg) //reg是给定的正则表达式，使用该方法匹配是否字符串能满足该表达式\n\ntrim() //返回字符串忽略前部空白与尾部空白后的结果\n```\n\n#### JavaScript 数字 Number\n我们可以用两种方法来表示数字，一是直接书写数字值，二是利用科学计数法来表示：\n\n```js\nvar x = 1.222;\n\nvar y = 2e3;  //代表2000 2*10^3 \n```\n\n**八进制与十六进制**\n\n默认情况下，JavaScript中的数字是使用十进制显示；\n\n如果前缀是0，那么代表是八进制数，如果是0x则为十六进制数。\n\n**无穷大 Infinity**\n\n当数字运算的结果超出了JS的数字表示结果时，则会出现一个无穷大值，以infinity表示，负无穷大以-infinity表示：<br>\n \n```js\nvar a = 2 / 0; // a为正无穷大\n\nvar b = -2 / 0; //b为负无穷大 \n```\n**非数字 NaN(not a number)**\n\n**NaN代表某值不是数字，同时我们可以使用isNaN(x)方法来判断x是不是NaN。**\n\n#### JavaScript 布尔 Boolean\n\n布尔只能有两个值，即true或false。\n\n#### JavaScript 数组 Array\n\n使用Array来存储一系列的值，值可以是不同的类型。\n\n创建数组\n\n1. 先new声明后赋值\n```js\nvar array_name = new Array();\n\narray_name[0] = value1;\n\narray_name[1] = value2;\n\narray_name[2] = value1;\t\n```\n\n2. 边声明边赋值\n```js\nvar array_name = new Array(value1, value2, value3);\n```\n\n3. 直接赋值\n\n```js\nvar people = [value1, value2, value3];\n```\n\n**常用数组方法及说明：**\n\n```js\narray1.concat(array2) //合并数组\n\njoin() //将数组的元素组成字符串\n\npop() //删除数组的最后一个元素\n\npush() //数组的末尾添加新的元素\n\nshift() //删除数组的第一个元素\n\nunshift() //数组的开头添加新的元素\n```\n\n#### JavaScript 对象 Object\n\n由于JavaScript是基于对象的，因此所有一切皆为对象。对象拥有自己的方法和属性。\n\n**自定义对象**\n\n```js\nvar person = new Object();\n\nperson.firstname = \"jack\";\n\nperson.age = 9;\n```\n\n**使用构造方法**\n\n```js\nfunction person(firstname, age){ \n\tthis.firstname = firstname;\n\t\n\tthis.age = age;\n} \n\nvar brother = new person(\"jack\", 9);\n```\n\n### JavaScript 函数\n\n函数就是包裹在花括号中的代码块：\n\n```js\nfunction funName(){\n\n}\n```\n\n**Javascript 对大小写敏感**\n\n可以传入参数，在调用函数时，写的个数与声明的参数个数顺序要一致：\n\n```js\nfunction funName(par1, par2){\n\t\n}\n```\n\n`<div onclick=\"funName(par1, par2)\"></div>`\n\n**当你想从当前位置，使JavaScript停止往下执行代码时，可以使该函数在某个地方提前返回值**\n\n**使用 return**\n\n```js\nfunction funName(para1, para2){\n\treturn para1 + para2\n}\n```\n\n### 局部JavaScript变量与全局JavaScript变量\n\n**在函数内部定义的变量，我们一般称为局部变量，它的作用域只限于整个函数体**\n\n相反，**在函数外部定义的变量是全局的**\n\n<mark>全局的JS文件或者函数都可以访问这个变量</mark>\n\n```js\nvar globalVar = 12;\n\nfunction fun1(){\n\tvar partialVar1 = 2;\n}\n\nfunction fun2(){\n\tvar partialVar2 = 3;\n}\n```\n\n**可以看出，fun1与fun2都可以在任意处引用globalVar**\n\n**值得注意的是，在VUE中的var变量一般会提升变量的作用域、而let变量不会（更推荐使用let变量）**\n\n**JavaScript中的变量一定要先声明后赋值，不同于Python编程语言**\n\n若某个变量没有x属性，强行使用或者调用该属性时，会报错**No such property等错误**\n\n# 常见的HTML事件\n1. 点击事件：onclick\n2. 某个键盘按键被松开: onkeyup\n3. 页面完成加载 onload\n4. 元素失去焦点 onblur\n5. 表单元素中的内容发生改变时：onchange （多用于input、select、textarea)\n6. 元素获得焦点时 onfocus\n7. 表单重置时 onsubmit\n\n### 运算符\n\n**+运算符用于将两个或者多个字符串变量，文本值连接起来**\n\n```js\n  function funName(var1, var2){\n   return var1 + var2\n  }\n```\n\n值得注意的是，\n\n1. 字符串与数字相加时，结果是字符串\n\n2. 当数字与数字相加 结果是数字\n\n### 比较运算符\n\n1. == 值等于\n\n2. === 值以及类型都相等\n\n3. ！= 不等于\n\n**当某些变量赋值时，也可以用到条件运算符**\n\n```js\nvarName = (age>18)? \"没有成年\" : \"已经成年\";\n\n```\n\n\n### 条件语句\n\n1. if 条件 真语句：假语句\n\n2. if-else\n\n3. if-else if- else  \n\n\n4. switch-case\n```js\nswitch(n){\n     case 1:\n        //代码块1\n     case 2:\n        //代码块2\n     default：\n      // 默认case都不执行时 执行deault\n}\n```\n\n\n### 循环\n\n#### for循环\n  \n```js\nfor(var i=0; i<5; i++){\n   document.write(i); //输出0 1 2 3 4\n}\n```\n  \n```js\nvar person = {fname:\"Bill\",lname=\"Gates\", age=56}; \n\nfor(var key in person){\n   txt += person[key] key是属性 person[key]是对应的属性值\n}\n\n#### while循环\n\n```js\n  \nvar i = 0;\nvar end = 10;\n\nwhile(i < end){\n   document.write('i满足一直比0小！');\n   i++;\n}\n```\n\n#### break与continue语句\n\n**break语句指的是，后面的都不判断了，跳出整个循环体（不管是for还是while）**\n\n而continue是指，跳出当前循环，进入下一个条件值继续执行。\n\n比如：\n```js\nvar i;\nfor(i=0; i<20; i++){\n  if(i % 3 == 0){\n      continue; //在这里注意到 如果是3的倍数 那么不会输出内容\n  }\n   document.write('正在执行！')\n}\n```\n\n### typeof 操作符\n\n**在不知道对应实例是属于什么类型的变量时** \n\n我们使用**typeof instance** 来查看对应的变量类型：\n\n```js\n\ntypeof \"john\" //string\n    \ntypeof 3.14 //number\n    \ntypeof false //boolean\n    \ntypeof [1,2,3] //object\n    \ntypeof {name:'John', age:34}//object\n    \n```\n\n### null对象\n\n**在Javascript中，null表示空对象引用**\n\nvar person = null //即表示该对象是空对象\n\n\n\n### undefined（赋这个值以清空某个变量）\n\n**在JavaScript中 undefined是一个没有设置值的变量**\n\n\n### JavaScript 类型转换\n\n#### 将数字转换为字符串\n\n```js \nString(number + number2)\n\n(number1 + number2).toString()\n```\n\n\n#### 字符串转换为数字\n```js\nNumber(str)\n```\n\n### JavaScript 正则表达式\n\n**正则表达式(Regular Expression) 使用若干个字符来描述：满足特定句法规则的字符串模式**\n\n#### 使用test（）方法\n\n**对于特定的正则表达式，我们可以使用test（）方法来验证某字符串变量是否满足这个特定正则表达式**\n\n```js\nvar reg = /xxx/;\n\nconsole.log(reg.test(strValue))\n```\n\n**若满足这个特定的正则表达式 则输出true 否则输出false**\n\n### 变量提升\n\n**所谓变量提升，是指函数以及变量的生命都将被提升到函数的最顶部**\n\n也就是说，变量可以先使用再声明\n\n但是！**变量的初始化，并不会提升**\n\n```js\nvar x = 5;\nelem = document.getElementById(\"demo\");\nelem.innerHTML = x + \",\" + y;\n\nvar y = 7;\n```\n\n**在以上例子中，y的值会输出undefined，而这是因为** \n\n*变量y的初始化在下方，而初始化是不会提升的* \n\n**因此，我们在敲代码时，要记住，最好是直接在头部声明我们的变量**\n\n### 块级作用域 let 与常量符 const\n\n**ES6 可以使用let来使用块级变量符，也就是说 let变量在当前所在的代码块中有效**\n\n而在{}外，是无法访问的！\n\n*对比var 变量符*\n\n```js\n{\n\tfunction funName(){\n\t\tvar test  = 1;\n\t}\n\t\n\tconsole.log(test) //值仍为1  可以访问（此时不具备块级变量的概念）\n}\n```\n\n```js\n{\n\tfunction funName(){\n\t\tlet test = 2;\n\t}\n\tconsole.log(test) //错误，此时具有块级变量的概念，是不能访问到的\n}\n```\n\nCONST 常量名称\n\n**const 定义常量的值必须初始化 因为后期是不能改变的**\n\n**一旦初始化了 后期是绝对不能改变的**\n\n**CONST 定义的数组或者对象 里面的属性是可以修改的 但是**\n\n我们是不能对这个对象 或者数组重新赋值的。\n\n```js\nconst car = {type=\"fia\", model:\"500\", color:\"white\"}\n\ncar.color = \"red\"; //不会报错的\n```\n\n### JavaScript JSON\n\n**JSON的全称是 JavaScript Object Notation**\n\n是一种轻量级的数据交换格式，通常用于服务端向网页传递数据\n\n例如：\n\n```js\n{\n\t\"sites\":\n\t[\n\t\t{\n\t\t\t\"name\": \"Google\", \n\t\t\t\"url\" : \"www.google.com\"\n\t\t},\n\t\t{\n\t\t\t\"name\": \"Baidu\",\n\t\t\t\"url\": \"www.baidu.com\"\n\t\t}\n\t]\n}\n```\n\n1. 数据为键:值对的集合：\"key\":\"value\"\n\n2. 数据与数据之间 用逗号隔开\n\n3. 花括号保存对象，方括号保存数组\n\n\n#### 使用内置函数将JSON 字符串转换为JavaScript对象\n\n```js\nvar text = '{ \"sites\" : [' +\n    '{ \"name\":\"Runoob\" , \"url\":\"www.runoob.com\" },' +\n    '{ \"name\":\"Google\" , \"url\":\"www.google.com\" },' +\n    '{ \"name\":\"Taobao\" , \"url\":\"www.taobao.com\" } ]}';\n\t\nvar obj = JSON.parse(text);\n\n```\n\n**JSON.stringify(obj)**是一个相反的过程\n\n### Promise 类解决前端异步调用后台数据\n\n1. 小例子\n```js\n//Promise 的构造函数的参数只有一个\n\n//就是一个函数 在这个函数中，我们编写要执行的《异步函数代码块》\nnew Promise(function (resolve, reject){\n\tconsole.log('异步代码块！')\n});\n```\n\n**其中resolve代表一切正常(译为解决)，reject代表出现异常时调用（译为拒绝）**\n\n比如出现零除异常。\n\n```js\nnew Promise(function (resolve, reject) {\n\tvar a = 0;\n\tvar b = 1;\n\tif (b == 0) reject(\"Divide zero\");\n\telse resolve(a / b);\n}).then(function (value) {\n\tconsole.log(\"a / b = \" + value);\n}).catch(function (err) {\n\tconsole.log(err);\n}).finally(function () {\n\tconsole.log(\"End\");\n});\n```\n\n**我们这样子执行的原因。 虽然执行这些代码块是异步的，但是我们利用then的先后顺序，让它看起来是相对“同步”的**\n\n","tags":["前端学习笔记"],"categories":["前端学习笔记"]},{"title":"CSS学习笔记","url":"/2021/03/15/CSS/","content":"\n# CSS教程\n\n## 什么是CSS？\n\n1. CSS 指的是层叠样式表**Cascading Style Sheets**\n\n2. 样式通常存储在.css文件中 解决内容与样式定义的问题\n\n## CSS 标准语法\n\n**通常，CSS规则由 选择器，若干条声明组成**\n\n比如：\n```css\nh1{ color:blur; font-size:12px; }\n```\nh1 是选择器，选择对应的标签。\n\n花括号中是若干条声明，其中每个样式由**属性：值**构成。\n\n## CSS 注释\n\n```css\n/*这是一个注释内容*/\n```\n\n## CSS ID选择器与CLASS选择器\n\n**ID选择器具有唯一性，CLASS类选择器将样式应用在同一类名的标签上**\n\n### ID选择器\n\n```css\n#id{\n\tattr: value;\n}\n```\n\n### Class选择器\n```css\n.class{\n\tattr: value;\n}\n```\n\n## CSS 引入\n\n1. 外部样式表\n\n**我们一般在网页的头部`<head>`标签插入外部样式表**\n\n```css\n<link rel=\"stylesheet\" type=\"text/css\" href=\"cssName.css\">\n```\n\n2. 内部样式表\n\n**在网页的最底部区域，若文档需要特定的样式，则使用`<style>`标签定义样式**\n\n```css\n<style>\n\tp{\n\t\tmargin-left: 20px;\n\t}\n</style>\n```\n\n3. 内联样式\n\n**对某个元素使用style属性，即可使用内联样式。**\n\n```css\n<p style=\" color:blue; background-color:red; \">\n\t这是段落内容...\n  \n```\n\n* 多重样式优先级：内联样式 > 内部样式 > 外部样式\n\n## CSS 背景\n1. background-color 背景颜色\n2. background-image 背景图片\n3. background-repeat 背景图片是否、如何重复\n4. background-attachment 背景图像是否固定或者随着页面滚动\n5. background-position 背景图像的初始位置\n\n## CSS 文本\n\n1. 文本颜色 color\n\n**文本颜色一般指定为：十六进制值#FF0000 RGB值 RGB(255, 0, 0) 或者名称 red**\n\n2. 文本对齐方式 text-align\n\n**center代表居中显示，justify像报纸一样，左右边距对齐，每一行宽度相等，right右对齐。**\n\n3. 文本修饰 text-decoration\n\n**none代表不需要装饰，overline上划线，line-through删除线，underline下划线。**\n\n4. 文本转换属性 text-transform\n\n**uppercase全部大写，lowercase全部小写，capitalize首字母大写。**\n\n5. 文本缩进 text-indent\n\n**px像素点为基本单位**\n\n6. 文本阴影 text-shadow\n\n**上右下左为基本方向，px像素点为基本单位。**\n\n```css\np{\n\t/* 表示上下为2px 左右为2px 颜色是#FF0000 */\n\ttext-shadow: 2px 2px #FF0000\n}\n```\n\n## CSS 字体\n\n1. 多种字体设置 font-family\n```css\n/*如果前面的字体 不起作用 往后替换*/\n\tfont-family:\"Times New Roman\", Times, serif;\n```\n\n2. 字体样式 font-style\n\n**normal代表正常，italic代表倾斜。**\n\n**p.s. 在font-weight:bold;中设置字体为粗体效果**\n\n3. 字体大小 font-size\n\n```css\np{\n\tfont-size: 12px;\n}\n```\n\n## CSS 链接\n```css\na:link {color:#000000;}      /* 未访问链接*/\na:visited {color:#00FF00;}  /* 已访问链接 */\na:hover {color:#FF00FF;}  /* 鼠标移动到链接上 */\na:active {color:#0000FF;}  /* 鼠标点击时 */\n```\n* a:hover必须跟在a:link与a:visited后面\n* a:active必须跟在a:hover后面\n\n## CSS 列表\n\n**在HTML中，有两种类型的列表：**\n\n* 无序列表 ul 小黑点或正方块\n* 有序列表 ol 数字或字母\n\n```css\nul.a{\n\tlist-style-type: circle;\n}\nul.b{\n\tlist-style-type:square;\n}\nol.c{\n\tlist-style-type:upper-roman;\n}\nol.d{\n\tlist-style-type:lower-alpha;\n}\n```\n\n**如果要去掉列表的样式，可以使用**\n```css\n\tul.demo:{\n\t\tlist-style-type:none;\n\t\tmargin:0px;\n\t\tpadding:0px;\n\t}\n```\n\n## CSS 表格\n\n1. 表格边框 border: 1px solid black; \n\n2. 表格边框折叠成单一边框 border-collapse:collapse;\n\n3. 表格文字对齐 td{text-align:center}\n\n## CSS 盒子模型\n\n**所有HTML元素都可以看作是一个盒子，在CSS中，这些元素包括：**\n\n**边距，边框，填充，实际内容**\n\n![盒子模型](https://img-blog.csdnimg.cn/20210430155052815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n其中：\n1. Margin 外边距\n\n2. Border 边框\n\n3. Padding 内边距\n\n4. Content 内容\n\n## CSS 边框\n\n1. 边框宽度 border-width\n\n2. 边框样式 border-style\n\n**dotted 点线边框， dashed 虚线边框， solid实线边框。**\n\n3. 边框颜色 border-color\n\n还是那三种方法，RGB，name，十六进制\n\n4. 边框圆角 border-radius:50px;\n\n## CSS 外边距 Margin\n\nCSS中的外边距指的是元素周围的空间\n\n![外边距与内边距](https://img-blog.csdnimg.cn/20210430155755277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n可单独调整元素的各种方向的外边距：\n\n```css\nmargin-top: 20px;\nmargin-right: 20px;\nmargin-bottom: 20px;\nmargin-left: 20px;\n```\n## CSS 填充边距（内边距）\n\n**与外边距一样，内边距也遵循：上右下左的样式顺序**\n\n## 分组与嵌套选择器\n\n**有可能，我们想对多个元素或者区域使用同样的样式。**\n\n```css\np{\n\t\n}\n\n.className{\n\t\n}\n```\n\n1. 用逗号将同样样式的元素写上\n```css\np,.className{\n\n}\n```\n\n2. 空格选择包裹在内的元素样式\n**为所有class=\"className\"元素内的p元素指定一个样式**\n```css\n.className p{\n\t\n}\n```\n\n3. 不用空格隔开，选择符合多种条件的元素\n**为所有class=\"className\"的p元素指定一个样式**\n```css\np.className{\n\t\n}\n```\n### 组合选择符\n1. 后代选择器 空格隔开\n2. 子元素选择器 > 符号\n3. 相邻兄弟选择器 + \n4. 普通兄弟 ～\n\n## CSS 尺寸\n```css\np{\n\tline-height: 50px; /*设置行高*/\n\tmin-height: 50px;\n\tmax-height: 50px;\n\tmin-width: 50px;\n\tmin-height: 50px;\n}\n```\n\n## Display与visibility\n\n**隐藏一个元素可以通过两种方式：1. display:none; 2. visibility:hidden;**\n\n* visibility:hidden; 可以隐藏某个元素，但是这个隐藏的元素不会从DOM中脱离，仍会影响布局。\n* 而display:none; 使得该元素不但被隐藏了，而且这个元素原本占用的空间也会从页面布局中消失。\n\n## CSS 块级元素与内联元素\n\n**像 h1, p, div 这些都是块元素，占用了全部宽度，在前后都是换行符**\n\n**而像span a 这种都是内联元素，不会占用全部宽度，不强制换行。**\n\n## CSS 定位\n\n1. static 默认定位 遵循正常的文档流对象\n\n2. fixed 固定位置 即使窗口是滚动的它也不会移动\n\n3. relative 相对位置 相对其DOM中正常的位置\n\n4. absolute 绝对定位 相对于最近的已定位父元素 如果没有 就是相对于HTML\n\n5. cursor:pointer; 光标呈现手的形式\n\n## CSS 布局\n\n**我们使用overflow来控制内容溢出元素框时，对应元素的显示情况。**\n\n1. overflow: visible; 内容不会修剪，会呈现在元素框之外。\n\n2. hidden; 内容会被修剪，并且其余内容是不可见的。\n\n3. scroll; 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。\n\n4. auto; 如果被修剪，会显示滚动条查看其余的内容。\n\n## CSS 浮动\n\n**浮动会使得元素，向左或向右移动，剩下的元素也会重新排列；**\n\n**这对布局图片时尤为重要。**  \n\n**水平浮动使得元素只能左右移动，如果图像是向右浮动，那么其余的文本流则会左环绕这张图像，浮动取值如下：**\n\n1. left 元素向左浮动  \n\n2. right 元素向右浮动  \n \n3. none 元素不进行浮动  \n \nCSS浮动具有**破坏性与包裹性**的特点；  \n\n1. 破坏性： 首先浮动破坏了行高，被浮动的元素不算行高；同时，浮动也引起了父元素坍塌 问题，即当父级元素全部浮动，并且未设置宽度和高度，那么它的高度将会缩减至零。  \n  \n2. 包裹性：浮动的元素将会以  **inline-block**  的方式显示，也就是说**这些元素会与其他的元素共用一行。**\n  \n* 如何通过添加属性来取消某一方向或所有方向的浮动呢？\n  \n**清除浮动： (clear: left|right|both) 清除左/右/两者浮动**  \n  \n1. 不允许左、右或者两者方向上的浮动  \n\n2. 优先向上浮动  \n\n3. 在position:absolute;前提下，z-index（z坐标）值越大 会越高覆盖在上面  \n  \n## CSS 变形\n**CSS中的常用2D变换translate rotate scale**\n\n### 平面移位 translate\n  \n平面移位是根据元素的坐标进行移动，从该位置进行移动，（x，y）表示 \n\n从该元素的位置起，**水平移动x个像素点，垂直移动y个像素点**\n\n值得注意的是，由于坐标点在网页的左上角，**因此可以通过负值往反方向平移。**\n  \n实例：（平面移动元素） \n```css\ndiv{  \n\ttransform: translate(50px,100px);  \n\t-webkit-transform: translate(50px,100px); /*针对于Safari和google浏览器*/   \n}\n```\n\n### 旋转 rotate\n  \n**rotate(x)通过给定的度数x，让元素进行顺时针旋转，x可取负值以看做是逆时针旋转。**\n  \n  \n* 实例：（旋转元素）  \n```css\ndiv{  \n\ttransform: rotate(50px,100px);  \n\t-webkit-transform: rotate(50px,100px); /*针对于Safari和google浏览器*/   \n}\n```\n\n### 缩放 scale\n  \n**scale（x,y) 使得变形后的宽度是之前的x倍，同时高度是之前的y倍。**\n  \n* 实例：（缩放元素）  \n```css\ndiv{  \n\ttransform: scale(2,3);   \n\t-webkit-transform: scale(2,3);  /*针对于Safari和google浏览器*/   \n}\n```\n## CSS 动画\n\n### @keyframes 规则\n\n**@keyframes 是动画规则，该规则内指定从现有的状态到指定的状态，这个状态间的改变过程就成为动画。**\n\n* 实例：制作div元素背景色，从红到黄持续4s（如何自定义动画规则，并将该规则绑定在元素身上）\n\n```css\n@keyframes test   \n{   \n\tfrom {background: red;}   \n\tto {background: yellow;}   \n}   \n\n@-webkit-keyframes test  /*safari浏览器与google浏览器的版本号*/    \n{   \n\tfrom {background: red;}   \n\tto {background: yellow;}   \n} \n\ndiv{\n\tanimation: test 4s;\n\t-webkit-animation: myfirst 5s; safari浏览器与google浏览器的版本号\n}\n```\n\n**动画常用属性及说明**\n\n属性名 | 值&属性说明\n--- | ---\nanimation-name |  属性名字 \nanimation-duration | 动画持续时间，单位为秒  \nanimation-delay | 动画延迟时间，单位为秒  \nanimation-iteration-count | 动画循环次数，infine表示无限循环\n\n \n \n ","tags":["前端学习笔记"],"categories":["前端学习笔记"]},{"title":"MongoDB学习笔记","url":"/2021/03/15/MongoDB/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n<!-- 以下是MongoDB的笔记 -->\n<div id=\"mongodb\">\n<h2>MongoDB<small>非关系数据库中的佼佼者</small></h2>\n\n<blockquote>         \n<p>\n<i class=\"fa fa-quote-left\"></i>  MongoDB，源自英语“Humongous”巨大的，当今也被广泛应用于大数据；Not only SQL也具体说出了非关系型数据库的心声，为什么呢？\nSQL是结构化，关系型的数据库，是数据库的当之无愧的老大：MySQL&SQL Server。这两家数据库在这几年的发展一直高居不下。同时，由\n于大数据的蓬勃发展，大量的信息开始趋于非关系化，非结构化，冗杂繁多的信息量使得数据库本身越来越复杂，因此“关系型数据库”的规范\n化也越来越明显，同时也需要建立越来越多的表，关联，数据库。\n作为NoSQL领军者的Redis和mongoDB后来者居上，MongoDB是一个跨平台，面向文档的数据库，提供高性能，高可用性和易于扩展；同时是工作在集合\n和文档上的一种概念。在处理大数据的冗杂性与结构繁多性，非关系型数据库MongoDB将成为数据库中的“秀儿”。\n<i class=\"fa fa-quote-right\"></i>\n</p>\n</blockquote>\n\n<div class=\"reference clearfix\"> \n<div class=\"title_content\" style=\"margin-bottom:5px\">\n<div  class=\"text_content\">笔记前言</div>\n<div class=\"clear\"></div>\n</div>\n</div>\t\t\n\n<br>\n<!-- 笔记重要概念 -->\n\n<em>一：数据库</em>\nMongoDB中的Database是Collection的物理容器，也就是存储所有文件与集合的文件系统，通常在一个MongoDB Server中存在有至少一个的Database。\n\n<em>二：集合</em>\n\n集合（Collection）可以说是数据库紧接着的下一个重要的概念，同时也是MongoDB的重要的特点之一，可以和RDBMS（Relational Database Management System）中的table等效；也就是说它是许多文件数据的存储点。一个集合存在于数据库中。集合不强制执行模式。集合中的文档可以有不同的字段。通常情况下，在一个集合中的所有文件都是类似或相关目的。因此这也是NoSQL数据库的众多特点与优点之一。\n\n<p class=\"im_concept\">\n<em>三：文件</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;文档是一组键值对（Key-Value)。文档具有动态模式。动态模式是指，在同一个集合的文件不必具有相同一组集合的文档字段或结构，并且相同的字段可以保持不同类型的数据。\n</p>\t\t\t \t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n<!-- 笔记正文 -->\n<div class=\"reference clearfix\"> \n\n<div class=\"bottom-p\">\n<!-- 数据库部分 -->\n<div class=\"panel-group\" id=\"accordion\">\n<div class=\"panel panel-default\">\n\n<div id=\"mongo_db\" class=\"panel-collapse collapse in\">\n<div class=\"panel-body\">\n<h3>创建数据库</h3>\n<h5>相应命令与语法</h5>\n<p>\nMongoDB建立一个新的数据库会使用到<code>use database_name</code>命令，\n如果不存在该database的名字，将会重新创建一个。否则会返回use的这个数据库：使用use命令创建数据库->\n<br>\n<br>\t\n<code>db</code>命令查看当前所使用的数据库<br>\n<code>\n> db;<br>\ndatabasetest <br>\n</code>\n<br>\n\nMongoDB查看当前所有数据库会使用到<code>show</code>命令:\n\n> show dbs;\nadmin 0.00GB \nlocal 0.00GB \ntest  0.00GB \n\n\n<br>\n在MongoDB中默认的数据库是<code>test</code>，若没有创建过任何数据库则会默认将数据保存在这个数据库中。\n<br>\n</p>\n\n<h3>删除数据库</h3>\n<h5>相应命令与语法</h5>\n<p>\nMongoDB数据库删除一个当前已有的数据库，将会用到<code>db.dropDatabase()</code>命令，\n前面已提到，如果未曾创建过任何数据库，那么将会删除默认的<code>test</code>的数据库；<br>\n\n> db.dropDatabase();\n{\"dropped\" : \"test\", \"ok\" : 1}\n\n\n</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n\n<div class=\"bottom-p\">\n<!-- 集合部分 -->\n<div class=\"panel-group\" id=\"accordion\">\n<div class=\"panel panel-default\">\n<div id=\"mongo_col\" class=\"panel-collapse collapse in\">\n<div class=\"panel-body\">\n<h3>创建集合</h3>\n<h5>相应命令与语法</h5>\n\n<p>\nMongoDB建立一个新的集合会使用到<code>db.createCollection(collection_name,collection_options)</code>命令，\n该命令中，collection_name是集合的名字，而collection_options是指定可选的配置属性：\n</p>\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210317153238734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n<p>\n<h5><strong>如何在test数据库中创建集合</strong></h5>\n\n> use test \nswitched to db test\n> db.createCollection(\"runoob\")\n{ \"ok\" : 1 }\n\n在你插入了一些文档数据后，MongoDB会自动帮你创建集合。\n\n> db.mongo.insert({\"name:\" \"vincent\"});\n> show collections;\nmongo\n\n<h3>删除集合</h3>\n<h5>相关命令与语法</h5>\n<p>\nMongoDB中删除一个新的集合会使用到<code>db.collection_name.drop()</code>方法<br>\n<em>返回值</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;\n如果成功删除选定的集合，该方法将会返回true，否则会返回false.<br>\n</p>\n\n<p>\n<strong>实例</strong> <br>\n首先可以使用<code>show collections;</code>查看当前所有已经存在的集合。\n\n> use test;\nswitched to db test \n> show collections; \ntest \nlocal \n\n\n接着删除该集合\n> db.test.drop(); \ntrue \n\n通过<code>show collections</code>再次查看数据库test中的所有集合. \n\n> show collections;\nlocal \n\t\n我们可以看出<mark>test</mark>集合已被我们删除。\n</p>\n</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n\n<div class=\"bottom-p\">\n<!-- 集合部分 -->\n<div class=\"panel-group\" id=\"accordion\">\n<div class=\"panel panel-default\">\n\n<div id=\"mongo_doc\" class=\"panel-collapse collapse in\">\n<div class=\"panel-body\">\n<h3>MongoDB 插入文档<small>相关命令与语法</small></h3>\n<p>\nMongoDB使用<code>insert()</code>或者<code>save()</code>方法向集合中插入文档，\n<mark>就像关系型数据库中，向表中插入数据一样。</mark><br>\n\n<strong>实例</strong>\n将数据插入到test集合中\n\n\tdb.test.insert({\n\tname: 'mongodb',\n\twriter: 'vincent'\n\t});\n\n当然，也可以使用db.test.save()命令，如果不指定_id字段，方法类似insert()方法。如果指定，则会更新该_id的数据。\n<br>\n在3.2版本后，还有一下几种语法可用于插入文档：\n\n\tdb.collection_name.inertOne();//插入一条数据\n\tdb.collection_name.insertMany();//插入多条数据\n\n</p>\n<h3>MongoDB 更新文档<small>相关命令与语法</small></h3>\n<p>\nMongoDB使用<code>update()</code>与<code>save()</code>更新文档，分别来看看这两个方法：<br>\n<h4>update()方法</h4>\n<mark>update()方法用于更新已存在的的文档，语法如下：<br></mark>\n<br>\n\ndb.test.update(\n<strong>query 查找方式</strong>, \n<strong>update 如何操作</strong>, \n);\n\n\n\n<strong>实例<br></strong>\n\n首先已知在test集合中，插入了name为vincent的数据。现在需要修改为rebecca：\n\n\t>db.test.update({'name':'vincent'},{$set:{'name':'rebecca'}});\n\tWriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) \n\n<h4>save()方法</h4>\n<mark>save()方法通过传入的文档来替换已有文档。语法如下：<br></mark>\n\n\n\tdb.test.save(\n\tdocument\n\t)\n\n</p>\n\n<h3>MongoDB 删除文档<small>相关命令与语法</small></h3>\n<p>\nMongoDB中删除文档，将会使用到<code>remove()</code>方法，建议在删除之前，先查询一下想要删除的数据对象详情。<br><br>\n\n\tdb.test.remove(query,{justOne: boolean;});\n\n\n<ins>其中，justOne是可选的，它代表是否只删除，多个符合删除条件中的，一条数据。如果选择只删除一条，那么置为1（true）。</ins>\n<br>\n官方推荐使用<code>deleteOne()</code>和<code>deleteMany()</code>方法：<br>\t\n\n如删除集合下全部文档：\n\n\t删除全部文档：\n\tdb.test.deleteMany({})\n\n\t删除 status 等于 B 的一个文档：\n\tdb.test.deleteOne( { status: \"B\" } ) \n\n</p><br>\n\n<h3>MongoDB 查询文档<small>相关命令与语法</small></h3>\n<p>\nMongoDB查询文档并以<mark>非结构化形式</mark>显示的方法为find()命令。<br>\n而<code>pretty()</code>方法是以易读的形式显示。<br>\n<code>db.test.find().pretty();</code><br>\n\n<p>\n各种RDBMS（关系型数据库管理系统）中where条件的表达方式：\n\n\t等于：{key:value}\n\t小于：{key: {$lt:value}}\n\t大于：{key: {$gt:value}}\n\t小于或等于：{key: {$lte:value}}\n\t大于或等于：{key: {$gte:value}}\n\t不等于：{key: {$ne:value}}\n\n</p>\n\n<h4>MongoDB AND 和条件</h4>\n<p>\nMongoDB中的查询可以传入多个值，其中用<code>，</code>逗号隔开就行。\n<br>\n\n\t> db.test.find({\"name\":\"vincent\", \"age\":\"18\"}).pretty(); \n\n</p>\n\n<h4>MongoDB OR 或条件</h4>\n<p>\nMongoDB中的查询除了可以传入和条件，也可以传入OR条件\n<br>\n\n\t> db.test.find({$or: [{key1: value1}, {key2:value2}]}).pretty(); \n\n</p>\n</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n\n<div class=\"bottom-p\">\n<!-- 集合部分 -->\n<div class=\"panel-group\" id=\"accordion\">\n<div class=\"panel panel-default\">\n\n<div id=\"limit\" class=\"panel-collapse collapse in\">\n<div class=\"panel-body\">\n<h3>MongoDB $type 操作符<small>相关命令与语法</small></h3>\n<p>\n常见数据类型：<br>\n\n<table class=\"table-bordered table-hover table-condensed\">\n<tr>\n<td>Integer</td>\n<td>数值类型，在计算机中可以是32也可以是64位</td>\n</tr>\n<tr>\n<td>String</td>\n<td>字符串类型，UTF-8编码</td>\n</tr>\n<tr>\n<td>Double</td>\n<td>浮点类型</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>布尔类型，true或者false</td>\n</tr>\n<tr>\n<td>Arrays</td>\n<td>数组类型，可以存储多个相同类型的值</td>\n</tr>\n<tr>\n<td>NULL</td>\n<td>空值类型</td>\n</tr>\n<tr>\n<td>Timestamp</td>\n<td>时间戳</td>\n</tr>\n<tr>\n<td>Code</td>\n<td>存储JS代码于文档中</td>\n</tr>\n<tr>\n<td>Regular expression</td>\n<td>正则表达式</td>\n</tr>\n<tr>\n<td>Binary data</td>\n<td>存储二进制形式的数据</td>\n</tr>\n</table><br>\n<strong>实例</strong><br>\n假设已经插入数据名为Vincent的学生信息，其中name属性是以字符串形式存储的。<br>\n\n\tdb.test.insert({\n\tname: \"Vincent\"\n\t});\n\n<br>\n现在想要访问name属性为string类型的数据，可以这么查询：<br>\n\n\tdb.test.find({\"title\": {$type : 2}});\n\tdb.test.find({\"title\" : {$type : 'string'}});\n</p>\n\n<h3>MongoDB Limit() 分页<small>相关命令与语法</small></h3>\t\t\n<p>\n与RDB一样，MongoDB中查询也可以<mark>指定读取的数据记录数</mark>，\n往该方法中写入一个参数，即<strong>读取的数量</strong>。\n\n\tdb.test.find().limit(num);\n\n其中，如果不指定数量，那么将会显示所有符合条件的数据记录。<br>\n\n<br>\n\n<strong>实例</strong><br>\n<p>\n假设已经存在三条数据，name属性分别为jack，vincent，rebecca。现在想要查询前两条：\n\n\tdb.test.find({\"name\" : 1, _id : 0}).limit(2);\n\t{\"name\" : jack} \n\t{\"name\": vincent}\n\n</p>\n\n</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n\n<div class=\"bottom-p\">\n<!-- 集合部分 -->\n<div class=\"panel-group\" id=\"accordion\">\n<div class=\"panel panel-default\">\n\n<div id=\"sort\" class=\"panel-collapse collapse in\">\n<div class=\"panel-body\">\n<h3>MongoDB sort()<small>相关命令与语法</small></h3>\n<p>\n在MySQL中，排序是通过<code>ORDER BY</code>来实现的，而在 MongoDB 中，排序是通过<code>sort()</code>\n方法实现，并指定特定键的排序方式——升序或者降序（1或者-1）：\n\n\tdb.test.find().sort({key_name: 1});\n\n上述代码将会以key_name升序的结果排序展示。\n\nskip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。\n</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n\n<div class=\"bottom-p\">\n<!-- 索引与聚合 -->\n<div class=\"panel-group\" id=\"accordion\">\n<div class=\"panel panel-default\">\n\n<div id=\"index\" class=\"panel-collapse collapse in\">\n<div class=\"panel-body\">\n<h3>MongoDB 索引<small>相关命令与语法</small></h3>\n<p>\n在处理非常大的数据时，可以想象，如果没有<mark>索引</mark>这样特殊的数据结构，查询时间将会花费几倍甚至几十倍的时间，\n对网站的维护性能来说无疑是致命的。\n\n<h4>createIndex() 创建索引</h4>\n<p>\n在MongoDB中使用该方法创建索引，同时可以传入参数，具体语法如下：<br><br>\n\n\t>db.test.createIndex(keys_name, options)\n\nKey_name 值为你要创建的索引字段，<strong>可以以逗号隔开作为复合索引</strong>，<mark>1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1</mark>  即可。<br><br>\noptions 是可选的额外参数：<br><br>\n<table class=\"table-striped table-bordered table\">\n<tr>\n<td>参数</td>\n<td>类型</td>\n<td>介绍</td>\n</tr>\n<tr>\n<td>background</td>\n<td>boolean</td>\n<td>指定以“后台”方式建立索引，因为建立索引将会阻塞其他数据库操作，为了不影响多个操作的同时进行，指定为后台方式创建。</td>\n</tr>\n<tr>\n<td>unique</td>\n<td>boolean</td>\n<td>“唯一”索引，默认值为false，开启则置为true</td>\n</tr>\n<tr>\n<td>name</td>\n<td>string</td>\n<td>为索引指定一个名称，通过连接索引的字段名和排序顺序生成一个索引名称。</td>\n</tr>\n</table>\n</p>\n<strong>实例</strong><br><br>\n<p>\n创建一个以name和age属性并且升序的索引：<br>\n\n\tdb.test.createIndex({\"name\" : 1, \"age\" : 1});\n</p>\n\n常见关于索引的操作：\n1、查看集合索引\ndb.col.getIndexes()\n\n2、查看集合索引大小\ndb.col.totalIndexSize()\n\n3、删除集合所有索引\ndb.col.dropIndexes()\n\n4、删除集合指定索引\ndb.col.dropIndex(\"索引名称\")\n\n<h3>MongoDB 聚合<small>相关命令与语法</small></h3>\n<p>\n<h4>aggregate() 方法</h4>\n<p>\n聚合一般用于统计数据，例如求最大值、平均数求和等等；<br>\n\n\t> db.test.aggregate(operation);\n\n<p>\n假设集合中存在name为vincent、jack和rebecca的数据记录。<br>\n并且所学科目名subject相应为：<br>\nvincent所属分别为：《计算机1》、《计算机2》、《计算机3》，<br>\njack所属分别为：《文学1》、《文学2》，<br>\nrebecca所属分别为：《经济史1》、《经济史2》、《经济史3》、《经济史4》<br>\n</p>\n\n<p>\n现在需要得到每个人所阅读的科目总数，可以如下：\n\n\t> db.test.aggregate([{$group : {_id : \"$name\", subject : {$sum : 1}}}])\n\n\t\"result\" : [\n\t \"_id\" : \"runoob.com\",\n\t \"num_tutorial\" : 2\n\t},\n\t{\n\t \"_id\" : \"Neo4j\",\n\t \"num_tutorial\" : 1\n\t}\n\t],\n\t\"ok\" : 1\n\t}\n\n相当于SQL语句：\n\n\tselect name, count(*) from mycol group by name\n\n</p>\n<br><br>\n常见的聚合表达式：<br>\n<table class=\"table-bordered table-hover\">\n<tr>\n<td>$sum</td>\n<td>计算数据记录条数的总和</td>\n</tr>\n<tr>\n<td>$avg</td>\n<td>计算平均值</td>\n</tr>\n<tr>\n<td>$min</td>\n<td>计算对应组的最小值</td>\n</tr>\n<tr>\n<td>$max</td>\n<td>计算对应组的最大值</td>\n</tr>\n</table>\n</p>\n</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n","tags":["非关系型数据库学习笔记"],"categories":["非关系型数据库学习笔记"]},{"title":"HTML学习笔记","url":"/2021/03/15/HTML/","content":"\n\n<div id=\"html\">\n<h2>HTML<small>HyperText Markup Language</small></h2>\n<blockquote>         \n<p>\n<i class=\"fa fa-quote-left\"></i> \n&nbsp;&nbsp;&nbsp;&nbsp; \n前端开发是创建Web页面或app等前端界面呈现给用户的过程，\n通过HTML，CSS及JavaScript以及衍生出来的各种技术、框架、解决方案，来实现互联网产品的用户界面交互。\n它从网页制作演变而来，名称上有很明显的时代特征。在互联网的演化进程中，网页制作是Web1.0时代的产物，\n早期网站主要内容都是静态，以图片和文字为主，用户使用网站的行为也以浏览为主。随着互联网技术的发展和HTML5、CSS3的应用，\n现代网页更加美观，交互效果显著，功能更加强大。 移动互联网带来了大量高性能的移动终端设备以及快速的无线网络，HTML5，node.jS的广泛应用，各类框架类库层出不穷。 \n<i class=\"fa fa-quote-right\"></i>\n<br>\n<p>\n<small style=\"position: relative; left: 500px;\">——百度百科</small>\n</p>\n</p>\n</blockquote>\n\n<div class=\"reference clearfix\"> \n<div class=\"title_content\" style=\"margin-bottom:5px\">\n<div  class=\"text_content\">笔记前言</div>\n<div class=\"clear\"></div>\n</div>\n</div>\n<br>\n<!-- 笔记重要概念 -->\n<p class=\"im_concept\">\n<em>一：HTML</em>\n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;首先我们需要知道什么是HTML，所谓HTML，就是Hyper Text Markup Language（超文本标记语言），\n虽然它是一种语言，但是千万不要认为HTML是编程语言，它不过是一种标记语言罢了。而超文本，则指的是“超越”文本，比如图\n片、超链接、音乐甚至程序；其中包括“头部”与“主体”部分。分别提供了网页信息与具体内容。\n</p >\n<p class=\"im_concept\">\n<em>二：CSS</em>\n<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\nCSS的全称是：Cascading Style Sheets（层叠样式表），就如同英文表达的那样，它的工作主要是静态地修饰网页，做出你想要的freestyle；\n它有着这些特点：<br>\n1.丰富的样式定义<br>\n2.易于使用与修改<br>\n3.多页面应用<br>\n</p>\n<p class=\"im_concept\">\n<em>三：JavaScript</em><br>\n&nbsp;&nbsp;&nbsp;&nbsp;\n与HTML、CSS不同的是，JavaScript（后文将直呼JS）才是一门真正的编程语言，也是一门直译式语言。用于动态地对网页中的DOM对象进行修改（增删改查）。\n它的主要特点：<br>\n1.是一种解释性语言，不需要像C语言那种语言，需要预编译。<br>\n2.可以直接嵌入至HTML页面中，也可以将结构与功能进行分离（外部JS） <br>\n3.跨平台特性，因为由浏览器支持，所以一处运行，多处使用。<br>\n</p>\t\n<br>\n\n<!-- 笔记正文 -->\n<div class=\"reference clearfix\"> \n<div class=\"title_content\" style=\"margin-bottom:5px\">\n<div  class=\"text_content\">笔记正文</div>\n<div class=\"clear\"></div>\n</div>\n</div>\n<br>\n\n<div class=\"bottom-p\">\n<!-- HTML基础 -->\n<div class=\"panel-group\" id=\"accordion\">\n<div class=\"panel panel-default\">\n<div class=\"panel-heading\">\n<h4 class=\"panel-title\">\n<a data-toggle=\"collapse\" data-parent=\"#accordion\" href=\"#html_base\" class=\"collapse_tabs\">\nHTML 排版基础\n<i class=\"glyphicon glyphicon-chevron-up\" style=\"float: right;font-size: 13px;\"></i>\n</a>\n</h4>\n</div>\n<div id=\"html_base\" class=\"panel-collapse collapse in\">\n<div class=\"panel-body\">\n<h2>HTML <small>文档结构</small></h2>\n<p>\n在标准的html网页中，我们可以看到这些<mark>关键字</mark>（标签）<br><br>\n<code>\n&lt;!DOCTYPE&gt;    \t//代表文档类型<br>\n&lt;html&gt;            //html文档内容<br>\n&lt;head&gt;\t\t\t//网站的头部<br>\n&lt;body&gt;\t\t\t//网站的主体部分<br>\n</code>\n</p>\n<br>\n\n<h2>HTML 标题<small>h1 - h6</small></h2>\n<p>\nhtml中的标题通过标签<em>&lt;h1&gt;&lt;/h1&gt;</em>到<em>&lt;h6&gt;&lt;/h6&gt;</em>，字体大小\n逐渐变小而实现的。h6标题是最小的，继续添加h7将无效。\n</p>\n<p>\n<code>\n&lt;h1&gt; h1标题  &lt;/h1&gt;<br>\n&lt;h2&gt; h2标题  &lt;/h2&gt;<br>\n&lt;h3&gt; h3标题  &lt;/h3&gt;<br>\n...<br>\n&lt;h6&gt; h6标题  &lt;/h6&gt;<br>\n</code>\n</p>\n<br>\n\n<h2>HTML 段落<small>p</small></h2>\n<p>\nhtml中的段落通过标签<em>&lt;p&gt;&lt;/p&gt;</em>实现的。值得注意的是，在<code>p</code>的尾标签结束后，将会自动换行。\n这一般也用于段落与段落之间的美化与排版。\n</p>\n\n<br>\n\n<h2>HTML 超链接<small>a</small></h2>\n<p>\n有时我们需要网页与网页之间的跳转，可以用到其中一个方法：通过标签<em>&lt;a&gt;&lt;/a&gt;</em>实现。<br>\n可以增加属性<strong>href</strong>指定链接的地址\n<p>\n<code>\n&lt;a href=\"http://www.baidu.com\"&gt; 点我进入百度  &lt;/a&gt;<br>\n</code>\n\n</p><br>\n\n</p>\n\n<h2>HTML 图像<small>img</small></h2>\n<p>\n有时我们需要在网页中增加图片美化文档，通过标签<em>&lt;img/&gt;</em>实现。<br>\n可以增加属性<code>src</code>指定图像的来源，可以使用绝对路径或者相对路径：<br>\n\n<blockquote>\n<p>\n相对路径：<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\n<mark>相对路径是指目标相对于当前文件的路径</mark>，内部网站设计中多采用这样的结构，以便于寻找资源。\n其常用方法如下：<br>\n./ : 代表文件所在的目录，通常可以省略不写。<br>\n../ : 代表文件所在的父级目录。<br>\n/ :代表文件所在的根目录<br>\n<br>\n<mark>绝对路径是指完整的网址</mark>，比如超链接中的“https://www.baidu.com”这个网址，多用于外部资源url的\n引入。开发中应避免在内部网站中使用绝对路径，除了不易维护，也会出现因改变目录地址而无法找到的错误。\n</p>\n</blockquote>\n\n<p>\n<code>\n&lt;a href=\"http://www.baidu.com\"&gt; 点我进入百度  &lt;/a&gt;<br>\n</code>\n</p><br>\t\n</p>\n\n<h2>字符实体</h2>\n<p>\n&nbsp;&nbsp;&nbsp;&nbsp;\n当你在编译器或者文本中敲写html代码时，也许你会发现这样一个有趣的问题：敲下<kbd><kbd>enter</kbd></kbd>键换到下一行继续写后，\n网页中的内容，除非超出容器外，否则不会换行；当你想要打出\"&lt;\" 或者\"&gt;\"时，也许会影响到整个HTML文档的格式等等情况。<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\n这时你需要到一些常见的<code>字符实体或者转义字符</code>，或者相关的标签：<br><br>\n<table class=\"table table-bordered table-hover\">\n<tr>\n<td>字符</td>\n<td>具体含义</td>\n</tr>\n\n<tr>\n<td>br单标签</td>\n<td>换行</td>\n</tr>\n\n<tr>\n<td>&+nbsp;(去掉中间的+号)</td>\n<td>空格</td>\n</tr>\n\n<tr>\n<td>&+lt;</td>\n<td>小于</td>\n</tr>\n\n<tr>\n<td>&+gt;</td>\n<td>大于</td>\n</tr>\n</table>\t\n</p>\n<br>\n\n<br>\n\n</div>\n</div>\n</div>\n</div>\n</div>\n\n<div class=\"bottom-p\">\n<!-- HTML表格 -->\n<div class=\"panel-group\" id=\"accordion\">\n<div class=\"panel panel-default\">\n<div class=\"panel-heading\">\n<h4 class=\"panel-title\">\n<a data-toggle=\"collapse\" data-parent=\"#accordion\" href=\"#html_table\" class=\"collapse_tabs\">\nHTML 表格\n<i class=\"glyphicon glyphicon-chevron-up\" style=\"float: right;font-size: 13px;\"></i>\n</a>\n</h4>\n</div>\n<div id=\"html_table\" class=\"panel-collapse collapse in\">\n<div class=\"panel-body\">\n<h2>HTML <small>表格结构</small></h2>\n<p>\n通常我们看到的HTML中的表格与excel中的表格，结构上没有太大的区别：<br>\n表格由<code>table</code>标签来定义。而每个表格中由行与列构成，即\n<code>tr</code>与<code>td</code>构成，<mark>且td标签需要内嵌于tr标签中，即若干个列属于同一行</mark>\n每个td：table data（表格数据）中，可以放入图片、段落、表单甚至表格。\t\n<br><br>\n注意：<ins>我们在td中写数据，请勿写在tr中td外！</ins>\n<br><br>\n</p>\n<strong>实例</strong>\n<br>\n<p>\n创建一个一行两列的默认表格：<br>\n<code>\n&lt;table&gt;<br>\n&lt;tr&gt;<br>\n&lt;td&gt;第一行第一列 &lt;/td&gt;<br>\n&lt;td&gt;第一行第二列 &lt;/td&gt;<br>\n&lt;/tr&gt; <br>\n\n&lt;/table&gt;\n</code>\n</p><br>\n\n<h2>HTML <small>表格重要属性与其他标签</small></h2>\n<p>\n<strong>边框</strong><br>\n<p>\n由于默认的表格是不带有边框的，可能在排版上不那么正规。\n因此，引入<code>border</code>属性，其值从<code>1</code>开始递增。<br>\n&nbsp;&nbsp;&nbsp;&nbsp;\n带有边框的表格：\n<br>\n<code>\n&lt;table border = \"1\" &gt;<br>\n&lt;tr&gt;<br>\n&lt;td&gt;第一行第一列 &lt;/td&gt;<br>\n&lt;td&gt;第一行第二列 &lt;/td&gt;<br>\n&lt;/tr&gt; <br>\n&lt;/table&gt;\n</code>\n</p>\n<br>\n</p>\n<p>\n<strong>表格的表头标签</strong><small>th</small><br>\n<p>\n通常我们需要提示<code>表头</code>来提示用户，该表格的内容或者信息概要，\n此时可能会需要表头，类似网站的<code>head</code>头部信息，大多数浏览器会显示为粗体并且居中的文本。\n</p>\n<br>\n\n<strong>表格的标题标签</strong>caption<br>\n<p>\n表格的标题会被显示在，表格的正上方，且不会被边框环绕。<br>\n<code>\n&lt;caption&gt;标题&lt;/caption&gt;<br>\n&lt;table border = \"1\" &gt;<br>\n&lt;tr&gt;<br>\n&lt;td&gt;第一行第一列 &lt;/td&gt;<br>\n&lt;td&gt;第一行第二列 &lt;/td&gt;<br>\n&lt;/tr&gt; <br>\n&lt;/table&gt;\n</code>\n</p>\n</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n\n<div class=\"bottom-p\">\n<!-- HTML表格 -->\n<div class=\"panel-group\" id=\"accordion\">\n<div class=\"panel panel-default\">\n<div class=\"panel-heading\">\n<h4 class=\"panel-title\">\n<a data-toggle=\"collapse\" data-parent=\"#accordion\" href=\"#html_list\" class=\"collapse_tabs\">\nHTML 列表\n<i class=\"glyphicon glyphicon-chevron-up\" style=\"float: right;font-size: 13px;\"></i>\n</a>\n</h4>\n</div>\n<div id=\"html_list\" class=\"panel-collapse collapse in\">\n<div class=\"panel-body\">\n<h2>无序列表<small>ul>li</small></h2>\n<p>\n对于列表，我们可以联想到家里的购物清单。也许是有序，也许是无序。因此我们引入，列表的概念：<br>\n<br><br>\n无序列表<code>unordered list</code>的语法如下：<br>\n<p>\n<code>\n&lt;ul&gt;\t<br>\n&lt;li&gt; 数据 &lt;/li&gt;<br>\n&lt;/ul&gt;<br>\n</code>\n</p>\n<mark>默认情况下，此列表的数据前会有典型的小黑圆圈标记。</mark>\n<br>\n</p>\n\n<h2>有序列表<small>ol>li</small></h2>\n<p>\n\n有序列表<code>ordered list</code>的语法如下：<br>\n<p>\n<code>\n&lt;ol&gt;\t<br>\n&lt;li&gt; 数据 &lt;/li&gt;<br>\n&lt;/ol&gt;<br>\n</code>\n</p>\n<mark>默认情况下，此列表的数据前会有数字标记。</mark><br>\n<b>我们可以通过更改属性<code>type</code>来更改有序列表数据展示的样式：<br></b>\n<br>\n<code>\n可以是\"A\" \"I\" \"i\" \"1\"分别代表不同的排列顺序！\n</code>\n<br>\n</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n\n<div class=\"bottom-p\">\n<!-- HTML表格 -->\n<div class=\"panel-group\" id=\"accordion\">\n<div class=\"panel panel-default\">\n<div class=\"panel-heading\">\n<h4 class=\"panel-title\">\n<a data-toggle=\"collapse\" data-parent=\"#accordion\" href=\"#html_area\" class=\"collapse_tabs\">\nHTML 区块\n<i class=\"glyphicon glyphicon-chevron-up\" style=\"float: right;font-size: 13px;\"></i>\n</a>\n</h4>\n</div>\n<div id=\"html_area\" class=\"panel-collapse collapse in\">\n<div class=\"panel-body\">\n<h2>块级元素<small>div</small></h2>\n<p>\n我们将div元素认定为块级元素，是因为它具有以下几个特点：<br>\n1.总是在新行开始内容<br>\n2.高度、行高、内外边距均可调整（具体内容将会在CSS中讲到）<br>\n3.宽度默认为它容器的100%<br>\n</p>\n<p>\n<h4>语法如下：</h4>\n<code>&lt;div&gt;\n<br>\n其他元素或者内容\n<br>\n&lt;/div&gt;\n</code>\n</p>\n\n<h2>行内元素<small>span</small></h2>\n<p>\n我们将span元素认定为内联元素（行内元素），是因为它具有以下几个特点：<br>\n1.不会在新行开始<br>\n2.高度等属性不可改变<br>\n3.宽度一般就为容器中的文字或者图片的高度<br>\n4.只能容纳文本等行内元素<br>\n</p>\n<p>\n<h4>语法如下：</h4>\n<code>&lt;span&gt;\n<br>\n容器中的内容\n<br>\n&lt;/span&gt;\n</code>\n</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n\n<div class=\"bottom-p\">\n<!-- HTML表单 -->\n<div class=\"panel-group\" id=\"accordion\">\n<div class=\"panel panel-default\">\n<div class=\"panel-heading\">\n<h4 class=\"panel-title\">\n<a data-toggle=\"collapse\" data-parent=\"#accordion\" href=\"#html_form\" class=\"collapse_tabs\">\nHTML 表单\n<i class=\"glyphicon glyphicon-chevron-up\" style=\"float: right;font-size: 13px;\"></i>\n</a>\n</h4>\n</div>\n<div id=\"html_form\" class=\"panel-collapse collapse in\">\n<div class=\"panel-body\">\n<h2>表单输入<small>form>input</small></h2>\n<h3>表单form</h3>\n<p>\n去应聘的时候，工作人员往往会给你一张表单让你填写你的个人信息，包括姓名，年龄，兴趣爱好，个人介绍等。\n</p>\n<p>\n表单的语法如下：<br>\n<code>\n&lt;form&gt;<br>\n填写input各类型的元素<br>\n&lt;/form&gt;<br>\t\n</code>\n</p>\n\n<p>\n<code>\n表单有如下重要属性：<br>\n一：处理程序属性action：URL（表单提交的地址）<br>\n二：表单名称name：不同的表单尽量使用不同的名字，避免混淆<br>\n三：提交方法，GET与POST：<br>\n<p>\n首先get是默认的提交方式，它会将表单中的输入元素等相关参数，附在网页的URL后；<br>\n因此我们可以看出，<mark>对于比较敏感的数据，它是不太安全的。</mark><br>\n但是，它是主动推送数据给服务器的，因此比起post，<mark>它更快速。</mark>\n</p>\n四：编码属性：（multipart/form-data）MIME多用途网络邮件<br>\n顶级媒体类型/子类型（后缀名）\ntext：文本<br>\napplication：应用<br>\nmultipart：多部分媒体<br>\naudio：音频文件<br>\nimage：图片<br>\nmessage：消息<br>\n</code>\n</p>\t\t\n\n\n<h3>输入input</h3>\n<p>\n输入元素的语法如下：<br>\n<code>\n&lt;input type = \"input_type\"&gt;<br>\t\n</code>\n</p>\n\n<p>\n输入元素被包含在<code>form</code>中，常见的元素类型<code>type</code>被列举如下：<br>\n<h4>文本域<small>text</small></h4>\n<p>\n语法如下：<br>\n<code>\n&lt;form&gt;<br>\n&lt;input type = \"text\"&gt;<br>\t\n&lt;/form&gt;<br>\t\n</code>\n</p>\n\n<p>\n我们通常在文本域中填写可见的文字或者数字，<mark>其默认长度为20字符</mark>，\n</p>\n\n<h4>密码域<small>password</small></h4>\n<p>\n密码字符不会明码显示（废话），将会以黑色星点或者圆点代替。语法如下：<br>\n<code>\n&lt;form&gt;<br>\n&lt;input type = \"password\"&gt;<br>\t\n&lt;/form&gt;<br>\t\n</code>\n</p>\n\n<h4>单选框<small>radio</small></h4>\n<p>\n如果限选一个选项，我们需要用单选框，<mark>注意，请给他们赋予\n相同的<code>name</code>属性；请\n将给用户看的选项与你input输入元素的value属性值相等。</mark>比如：<br>\n<code>吧、\n&lt;form&gt;<br>\n&lt;input type = \"radio\" name = \"sex\" value = \"男\"&gt;男<br>\t\n&lt;input type = \"radio\" name = \"sex\" value = \"女\"&gt;女<br>\t\n&lt;/form&gt;<br>\t\n</code>\n</p>\n\n<h4>多选框<small>checkbox</small></h4>\n<p>\n从若干个选项中选取一个或多个，我们需要用多选框，仍旧建议使用相同的name，并且value值与显示出来的值相同：<br>\n<code>\n&lt;form&gt;<br>\n&lt;input type = \"checkbox\" name = \"vehicle\" value = \"轿车\"&gt;轿车<br>\t\n&lt;input type = \"checkbox\" name = \"vehicle\" value = \"自行车\"&gt;自行车<br>\t\n&lt;/form&gt;<br>\t\n</code>\n</p>\n\n<h4>提交按钮<small>submit</small></h4>\n<p>\n填写完所有服务器需要的信息后，我们可以添加提交按钮，表示信息准备提交至服务器:<br>\n<code>\n&lt;form&gt;<br>\n&lt;input type = \"submit\" value = \"提交\"&gt;提交<br>\t\n&lt;/form&gt;<br>\t\n</code>\n</p>\n\n<p>\n<strong>请注意</strong>\n提交按钮<code>submit</code>与普通按钮<code>button</code>的区别：<br>\n<p>\n1.一般submit用于表单提交；而button仅仅是一个按钮，只要绑定不同的事件，就能实现不同的功能。\n<br>2.submit与button修改按钮上的文字的方式也不同，对于submit，有自己的属性<code>value</code>，\n我们用JS捕获到该DOM对象后，通过修改这个属性值来修改文字；button通过直接修改innerHTML值来修改其按钮上的文本值。\n</p>\n</p>\n\n</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n\n<div class=\"bottom-p\">\n<!-- HTML颜色 -->\n<div class=\"panel-group\" id=\"accordion\">\n<div class=\"panel panel-default\">\n<div class=\"panel-heading\">\n<h4 class=\"panel-title\">\n<a data-toggle=\"collapse\" data-parent=\"#accordion\" href=\"#html_color\" class=\"collapse_tabs\">\nHTML 颜色\n<i class=\"glyphicon glyphicon-chevron-up\" style=\"float: right;font-size: 13px;\"></i>\n</a>\n</h4>\n</div>\n<div id=\"html_color\" class=\"panel-collapse collapse in\">\n<div class=\"panel-body\">\n<h2>HTML中的颜色<small>十六进制或者RGB（Red，Green，Blue）</small></h2>\n<p>\nHTML中的颜色可以由十六进制来定义，这个符号由相应RGB的值来确定；<mark>每个值的区间是[0(#00),255(#FF)]</mark>\n下面列举常用颜色的RGB值：<br>\n<code>\n#000000 / rgb(0,0,0)：   黑色<br>\n#FF0000 / rgb(255,0,0)： 红色<br>\n#00FF00 / rgb(0,255,0)： 绿色<br>\n#0000FF / rgb(0,0,255)： 蓝色<br>\n#FFFFFF\t/ rgb(255,255,255): 白色<br>\t\t\t\t\t\t\t\t\n</code>\n</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>","tags":["前端学习笔记"],"categories":["前端学习笔记"]},{"title":"翻译作品-替换“我不知道”的八种更好的回答","url":"/2021/03/15/翻译作品-回答我不知道的八种方式/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n## Improve your Vocabulary: 8 better ways to say “I don’t know”\n## 提高你的词汇量:8种更好的表达“我不知道”的方法\n\n\nWhen someone asks you something and you don’t know the answer, it’s okay to admit that you don’t know. But you can respond with more than “I don’t know” – you can use richer vocabulary, you can be more polite, or you can offer to help. In this lesson, I’ll give you 8 ways you can respond in English when you don’t know the answer. You’ll learn expressions such as “I’d be happy to...”, “Before I can answer...”, “Honestly, I have no idea”, “If I knew, I would...”, and more. Start having better English conversations by learning and using these expressions. Take the quiz to make sure you understood the lesson! https://www.engvid.com/\n\n当别人问你什么而你不知道答案的时候，承认自己不知道没什么大不了的。但是你可以用比“我不知道”更多的回答——你可以使用更丰富的词汇，你可以更有礼貌，或者你可以主动提供帮助。这节课，我将告诉你不知道答案时8种用英语回答的方法。你会学到诸如“我很乐意……”，“在我能回答……之前”，“老实说，我不知道”，“如果我知道，我就会……”等等的表达。通过学习和使用这些表达来开始更好的英语对话。做个小测验，确保你理解了课文!https://www.engvid.com/\n\n<div style=\"position: relative; padding: 30% 45%;\">\n<iframe style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\" \nsrc=\"https://player.bilibili.com/player.html?aid=844619251&bvid=BV1B54y1a7xQ&cid=310374887&page=1\"\n frameborder=\"no\" scrolling=\"no\"></iframe>\n</div>","tags":["翻译作品"],"categories":["翻译作品"]},{"title":"翻译作品_在法国的美国小伙儿","url":"/2021/03/13/翻译作品-在法国的美国小伙儿/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n## 该视频由YouTube博主讲述如何作为一名美国人 融入法国的生活\n\n## 第一弹：\n<div style=\"position: relative; padding: 30% 45%;\">\n<iframe style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\" \nsrc=\"https://player.bilibili.com/player.html?aid=844141883&bvid=BV1P54y1Y741&cid=297738729&page=1\"\n frameborder=\"no\" scrolling=\"no\"></iframe>\n</div>\n\n## 第二弹：\n<div style=\"position: relative; padding: 30% 45%;\">\n<iframe style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\" \nsrc=\"https://player.bilibili.com/player.html?aid=416684897&bvid=BV1yV411i7dC&cid=297931818&page=1\"\n frameborder=\"no\" scrolling=\"no\"></iframe>\n</div>\n\n\n## 第三弹：\n<div style=\"position: relative; padding: 30% 45%;\">\n<iframe style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\" \nsrc=\"https://player.bilibili.com/player.html?aid=671645337&bvid=BV1cU4y1W7u1&cid=298333318&page=1\"\n frameborder=\"no\" scrolling=\"no\"></iframe>\n</div>\n","tags":["翻译作品"],"categories":["翻译作品"]},{"title":"PYTHON 从入门到精通-Get 与 Post 请求","url":"/2021/03/11/PYTHON 从入门到精通-利用BeautifulSoup Get 与 Post 请求/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# 实现Get请求 模拟百度搜索\n```py\nimport requests\nimport webbrowser\nif __name__ == '__main__':\n\n    # 参数用字典的方式 输入相应的key-value值\n    param = {'wd': input('请输入你要搜索的内容：')}\n\n    # 模拟实现百度搜索 其中地址栏只需要wd参数 后面跟的是 搜索的内容\n    req = requests.get('http://www.baidu.com/s', params=param)\n    # 最后利用内嵌的浏览器 打开\n    webbrowser.open(req.url)\n```\n\n# 利用Post 请求登录某页面\n\n```py\n\nimport requests\nimport webbrowser\nif __name__ == '__main__':\n\n\n    # 给到服务器要的参数\n    data = {'firstname': 'vincent', 'lastname': 'he'}\n\n    # 去目标action页面(注意 不总是登录填写账号密码的页面） Network中的FormData查看需要什么参数\n    response = requests.post('https://pythonscraping.com/pages/files/processing.php', data=data)\n    print(response.text)\n\n```\n\n# 利用Cookies来保持登录状态\n```py\n\nimport requests\nimport webbrowser\nif __name__ == '__main__':\n\n\n    # 给到服务器要的参数\n    data = {'username': 'vincent', 'password': 'password'}\n\n    # 去目标action页面(注意 不总是登录填写账号密码的页面） Network中的FormData查看需要什么参数\n    response = requests.post('http://pythonscraping.com/pages/cookies/welcome.php', data=data)\n\n    # 在登录成功后 拿到相应的cookies值 可以直接用get去到相应的其他页面（这个页面需要登录之后 才能查看的） 不用再次登录！！！\n    response = requests.get('http://pythonscraping.com/pages/cookies/profile.php', cookies=response.cookies)\n    print(response.text)\n\n\n\n```","tags":["PYTHON"],"categories":["网络爬虫"]},{"title":"PYTHON 从入门到精通-利用BeautifulSoup 如何爬取网站数据","url":"/2021/03/11/PYTHON 从入门到精通-利用BeautifulSoup 如何爬取网站数据/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n```py\n\n#-*- coding:UTF-8 -*-\n\n# 模拟定义一个完整的HTML源码\nfrom attr import attrs\n\nhtml = \"\"\"\n<html>\n<head>\n    <title>test</title>\n</head>\n\n<body>\n<p class='title' name='title_name'><b>once upon a time</b></p>\n<p class='title1' name='title_name1'><b>once upon a time1</b></p>\n<p class='title2' value='123' name='title_name2'><b>once upon a time2</b></p>\n\n</body>\n\"\"\"\n\n\nfrom bs4 import BeautifulSoup\n\n\nsoup = BeautifulSoup(html, 'lxml') # lxml是解析方式 html 是模拟的页面\n\n# 标准缩进方式\n# soup.prettify()\n\ntitle = soup.title\nprint(title.text)  # 选择标签为title的text内容（String属性也可以） 只选择第一个\nprint()\n\nhead = soup.find('head')\nprint(head.title.text)  # title是head的子节点，那么可以通过逗号 直接索引到title并打印该标签中的内容\nprint()\n\n\np_one = soup.find('p')  # find函数 一样的做法  p 标签内容 只选择第一个\nprint(p_one.text)\nprint()\n\np_one_class = soup.find(class_='title')  # find函数 类名寻找器 只选择第一个\nprint(p_one_class)\nprint()\n\np_s = soup.find_all('p')  # find_all 也是查找 不过返回的是列表！！！应用for循环迭代其中的元素\nfor i, item in enumerate(p_s):\n    print(i, item.text)\n\n\n\n```","tags":["PYTHON"],"categories":["网络爬虫"]},{"title":"PYTHON 从入门到精通-利用selenium 如何爬取网站数据","url":"/2021/03/11/PYTHON 从入门到精通-利用selenium 如何爬取网站数据/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# 一、爬取豆瓣电影td数据代码\n\n\n```py \n#-*- coding:UTF-8 -*-\n\n# selenium对豆瓣页面进行操作\n\nimport urllib.request\nfrom selenium import webdriver\ndef print_hi(name):\n    # Use a breakpoint in the code line below to debug your script.\n    print(f'Hi, {name}')  # Press Ctrl+F8 to toggle the breakpoint.\n\n\n# Press the green button in the gutter to run the script.\n\n#Main函数入口\nif __name__ == '__main__':\n    browser = webdriver.Chrome()\n    browser.get('https://movie.douban.com/')\n    tagname = browser.find_elements_by_tag_name('td') \n\n    for item in tagname:\n        try:\n            int(item.text) # 这一句出现异常时\n\n        except Exception:\n            print(item.text) # 将会走这一步\n\n```\n\n\n# 二、爬取豆瓣电影-轮播图中数据的href数据\n\n```py \n#找到相应的轮播图数据的href\n# This is a sample Python script.\n\n# Press Shift+F10 to execute it or replace it with your code.\n# Press Double Shift to search everywhere for classes, files, tool windows, actions, and settings.\n\nimport urllib.request\nfrom selenium import webdriver\ndef print_hi(name):\n    # Use a breakpoint in the code line below to debug your script.\n    print(f'Hi, {name}')  # Press Ctrl+F8 to toggle the breakpoint.\n\n\n# Press the green button in the gutter to run the script.\n#Main函数入口\nif __name__ == '__main__':\n    browser = webdriver.Chrome()\n    browser.get('https://movie.douban.com/')\n    tagnames = browser.find_elements_by_class_name('list-wp') # 找到class为cover-wp所在的标签\n    for container in tagnames:\n        items = container.find_elements_by_class_name('slide-page') # 所有的slide-page\n        for item in items:\n            tag = item.find_elements_by_tag_name('a') # 找到每一个slide-page的a标签\n            print(len(tag))\n            for Tag in tag:                             # 每一个a标签的 href属性\n                print(Tag.get_property('href'))\n\n# See PyCharm help at https://www.jetbrains.com/help/pycharm/\n```\n\n","tags":["PYTHON"],"categories":["网络爬虫"]},{"title":"PYTHON 从入门到精通-类Class","url":"/2021/03/11/PYTHON 从入门到精通-类Class/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# 类的定义：\n```py\nclass CLASS_NAME:\n\tattr1 = 0\n\t# 构造函数__init__\n\tdef __init__(self, param1, param2...): # self相当于C++中的this对象\n\t\tself.param1 = param1\n\t\t...\n\t\n\t# 成员函数 将变量attr1加一\n\tdef fun(self):\n\t\tattr1 += 1\n\t\n\t# 类方法 调用时直接用CLASSNAME.set_attr_for_all\n\t@classmethod\n\tdef set_attr_for_all(cls, attr1):\n\t\tcls.attr1 = attr1\n\t\n\t# 静态方法 一般写不涉及到某个对象 或者类的相关属性或者方法\n\t@staticmethod\n\tdef hello_class():\n\t\tprint('Hello World!')\n\n# 创建并初始化对象\nclass1 = CLASS_NAME()\n\n# class1.xxx 代表对象实例的变量 或者 方法\n\n# CLASS_NAME.xxx 代表类的变量或者方法\n\t\n```\n\n# 类的继承\n<p>\n\t比如有一个类：Human，另外有一个Student类\n\t现在用Student类继承于Human \n</p>\n\n```py\n# Human类的构造函数：\nclass Human:\n\tdef __init__(self, name):\n\t\tself.name = name\n```\n\n```py\n# Student比Human类多一个属性studentnum \n# 而从父类继承来的name属性 可以通过父类的构造方法进行构造\nclass Student(Human):\n\tdef __init__(self, name, studentnum):\n\t\n\t\t# 利用父类的构造方法 构造name属性\n\t\tsuper.class().__init__(name)\n\t\tself.studentnum = studentnum\n```","tags":["PYTHON"],"categories":["编程语言"]},{"title":"从零基础创建Springboot_Thymelear_layui项目","url":"/2021/03/11/从零基础创建Springboot + Thymelear + layui项目/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# 第一步：打开idea创建项目\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210109170230558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n直接点next下一步；\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210109170455100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\nnext点完，依赖后面再添加。\n\n<mark>依赖删除，重新添加</mark> \n\t①：spring-boot-starter-web\n\t②：spring-boot-starter-thymeleaf\n## 创建默认页面static和templates文件夹\n1、其中 static 放除pages以外的\n2、templates 放pages\n（数据来自ok-admin-master) 百度网盘有\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210109171428197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n存入之后，项目结构图为（记得加入index.html)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210109171502442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n### 首先测试主页，编写controller访问index（涉及SpringMVC）\n注意，启动时可能会报相应Test错误（由于改动了相应的依赖）\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210109172033900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n只需要删除相应Test文件即可\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210109172127323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n编写相应的Controller 写页面跳转即可\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20210109173707132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n## 前端若iframe嵌套页面为404\n则比如：iframe标签中，src属性为welcome\n那么写一个Controller RequestMapping参数为\"welcome\" 直接返回相应的前端页面即可 避免404\n看图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210109175845496.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210109175856423.png)\n\n\n##  一级菜单与二级菜单 在menu.json中\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210109174132507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n大致页面如下：\n\n**localhost:8080** 或者 **localhost:8080/index** （默认欢迎页面为Index）\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210109180025740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n","tags":["SpringBoot"],"categories":["编程语言"]},{"title":"目录测试","url":"/2021/03/11/目录测试/","content":"\n\n# 第一步：下载插件（HEXO-TOC）\n```cpp\ncnpm install hexo-toc --save\n```\n\n# 第二步：配置博客根目录下的_config.yml文件\n```cpp\ntoc:\n   maxdepth: 3\n```\n\n# 第三步：在文章相应位置引用目录\n```cpp\n<!-- toc -->\n```","tags":["目录测试"],"categories":["目录测试"]},{"title":"Mybatis学习笔记(所有代码FROM SIKI学院)","url":"/2021/03/11/Mybatis/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n\n### Mybatis是什么？\n<p>\nMyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，\n并且改名为MyBatis 。2013年11月迁移到Github。MyBatis是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。\nMyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。总而言之MyBatis是一个轻量级简化数据库操作的框架。\n</p>\n\n### Mybatis架构\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210313165831616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n\n### Mybatis的配置文件（包括数据库连接，MapperXML配置文件位置）\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n  \n<configuration>\n\t\n\t<!-- 读取数据库连接的配置文件 -->\n\t<properties resource=\"db.properties\"/>\n\t\n\t<!--    推荐使用package包的形式来配置别名\n\t\t\t包的形式会扫描主包及子包下的所有文件\n\t\t\t以对象类名为别名，大小写不限，推荐使用小写\n\t -->\n\t<typeAliases>\n\t\t<!-- \t<typeAlias type=\"com.sikiedu.bean.User\" alias=\"user\"/> -->\n\t\t<package name=\"com.sikiedu.bean\"/>\n\t</typeAliases>\n\t\n <!-- 在集成spring 不用environments这个property -->\n  <environments default=\"development\">\n\t  \n    <environment id=\"development\">\n\t\t\n    <!-- 使用jdbc的事务 -->\n      <transactionManager type=\"JDBC\"/>\n\t  \n      <!-- 使用连接池 连接数据库 -->\n      <dataSource type=\"POOLED\">\n\t\t<!-- 注意下面的jdbc.driver在文件db.properties中: -->\n\t\t<!-- 写法是：jdbc.driver=com.mysql.jdbc.Driver -->\n        <property name=\"driver\" value=\"${jdbc.driver}\"/>\n        <property name=\"url\" value=\"${jdbc.url}\"/>\n        <property name=\"username\" value=\"${jdbc.username}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n      </dataSource>\n    </environment>\n  </environments>\n  \n  <!-- 配置映射器配置文件 XXX.xml 的位置 -->\n  <mappers>\n   \t<!-- <mapper resource=\"mapper/UserMapper.xml\"/> -->\n   \t<!-- <mapper url=\"file:\\\\\\D:\\Work\\Siki_edu\\JavaEE\\Teach\\SSM框架\\ssm_project\\ssm_mybatis\\src\\mapper\\UserMapper.xml\"/> -->\n   \t<!-- <mapper class=\"com.sikiedu.mapper.UserMapper\"/> -->\n   \t<!-- 推荐使用包的形式配置 -->\n   \t<package name=\"com.sikiedu.mapper\"/>\n  </mappers>\n  \n</configuration>\n```\n**注意：**\n当使用```<package/>```标签时 **映射接口文件与映射配置文件共同应该在Mapper文件夹下**\n\n否则使用mapper标签 且用resource指定对应的配置文件所在目录\n\n### Mybatis某个映射接口文件以及对应的XML文件（比如UserMapper.java & UserMapper.xml)\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<!-- 注意域名namespace不要写错 相当于自己地址 -->\n<mapper namespace=\"com.sikiedu.mapper.UserMapper\">\n\t\n\t<sql id=\"myselect\">\n\t\tSELECT * \n\t\tFROM user\n\t</sql>\n\n\t<!-- 根据id查询用户 -->\n\t<!-- 注意! 标签中的id属性值,必须与对应Mapper接口文件中的方法名一致!!! -->\n\t<select id=\"selectUserById\" parameterType=\"Integer\" resultType=\"user\">\n\t\t select * from user where u_id = #{id}\n\t</select>\n\t\n\t<!-- 根据名字模糊查询用户 -->\n\t<!-- #{} 占位符 尽量选用#{}来解决问题 '1' '王'-->\n\t<!-- ${} 字符串拼接 or 1=1  王 -->\n\t<!-- order by ${} -->\n\t<select id=\"selectUserByName\" parameterType=\"String\" resultType=\"com.sikiedu.bean.User\">\n\t\t<!-- SELECT * FROM USER WHERE u_username LIKE '%${value}%' -->\n\t\tSELECT * FROM USER WHERE u_username LIKE \"%\"#{name}\"%\"\n\t</select>\n\t\n\t<!-- 添加用户 -->\n\t<insert id=\"insertUser\" parameterType=\"com.sikiedu.bean.User\">\n\t\tinsert into user values( null, #{u_username} , #{u_password}, #{u_sex}, #{u_createTime}, #{u_cid} )\n\t</insert>\n\t\n\t<!-- 修改用户 -->\n\t<update id=\"updateUser\" parameterType=\"com.sikiedu.bean.User\" >\n\t\tupdate user set u_username = #{u_username} where u_id = #{u_id}\n\t</update>\n\t\n\t<!-- 根据id删除用户 -->\n\t<delete id=\"deleteUserById\" parameterType=\"Integer\">\n\t\tdelete from user Where u_id = #{id}\n\t</delete>\n\t\n\t<select id=\"selectUserByUserVoId\" parameterType=\"UserVo\" resultType=\"user\">\n\t\t select * from user where u_id = #{user.u_id}\n\t</select>\n\t\n\t<!-- \tpublic Integer selectUserCount(); -->\n\t<select id=\"selectUserCount\" resultType=\"Integer\">\n\t\tSelect Count(*) from user\n\t</select>\n\t\n<!-- public List<UserVo> selectAllUserVo(); //查询所有用户包装类 -->\n\t<resultMap type=\"UserVo\" id=\"uservolist\">\n\t\t<id property=\"u_id\" column=\"u_id\"/>\n\t\t<result property=\"u_username\" column=\"u_username\"/>\n\t\t<result property=\"u_sex\" column=\"u_sex\"/>\n\t\t<association property=\"country\" javaType=\"Country\">\n\t\t\t<id property=\"id\" column=\"c_id\"/>\n\t\t\t<result property=\"c_countryname\" column=\"c_countryname\"/>\n\t\t</association>\n\t</resultMap>\n\t<select id=\"selectAllUserVo\" resultMap=\"uservolist\">\n\t\tSELECT \n\t\tu.`u_id`, \n\t\tu.`u_username`,\n\t\tu.`u_sex`, \n\t\tc.`c_id`, \n\t\tc.`c_countryname` \n\t\tFROM USER u \n\t\tLEFT JOIN \n\t\tcountry c \n\t\tON u.`u_cid`=c.`c_id`\n\t</select>\n\t\n\t<!-- \t//多条件查询 通过用户对象中的条件查询用户列表\n\tpublic List<User> selectUserListByUser(User u); -->\n\t\n\t<select id=\"selectUserListByUser\" parameterType=\"User\" resultType=\"User\">\n\t\t<!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍ID -->\n\t\tSELECT * \n\t\tFROM user\n\t\t<where>\n\t\t<!-- where标签可以去掉开头的AND -->\n\t\t<if test=\"u_sex != null and u_sex != ''\">\n\t\t\t AND u_sex = #{u_sex} \n\t\t</if>\n\t\t<if test=\"u_username != null and u_username != ''\">\n\t\t\tAND u_username like \"%\"#{u_username}\"%\" \n\t\t</if>\n\t\t<if test=\"u_cid != null\">\n\t\t\tAND u_cid = #{u_cid}\n\t\t</if>\n\t\t</where>\n\t</select>\n\t\n\t<select id=\"selectUserListByUserTrim\" parameterType=\"User\" resultType=\"User\">\n\t\t<!-- 查询用户性别 模糊查询用户名 查询用户cid 国籍ID -->\n\t\tSELECT * \n\t\tFROM user\n\t\t<trim prefix=\"where\" suffixOverrides=\"AND\">\n\t\t\t<!-- where标签可以去掉开头的AND -->\n\t\t\t<if test=\"u_sex != null and u_sex != ''\">\n\t\t\t\t u_sex = #{u_sex} AND \n\t\t\t</if>\n\t\t\t<if test=\"u_username != null and u_username != ''\">\n\t\t\t\tu_username like \"%\"#{u_username}\"%\" AND \n\t\t\t</if>\n\t\t\t<if test=\"u_cid != null\">\n\t\t\t\t u_cid = #{u_cid} AND\n\t\t\t</if>\n\t\t</trim>\n\t</select>\n\t\n\t<!-- public void updateSetUser(User u); -->\n\t<update id=\"updateSetUser\" parameterType=\"User\">\n\t<!-- 用户名 用户密码 性别 用id来限制 -->\n\t\tupdate user \n\t\t<set>\n\t\t\t<if test=\"u_username != null and u_username != ''\">\n\t\t\t\tu_username = #{u_username},\n\t\t\t</if>\n\t\t\t<if test=\"u_password != null and u_password != ''\">\n\t\t\t\tu_password = #{u_password},\n\t\t\t</if>\n\t\t\t<if test=\"u_sex != null and u_sex != ''\">\n\t\t\t\tu_sex = #{u_sex}\n\t\t\t</if>\n\t\t</set>\n\t\tWhere u_id = #{u_id}\n\t</update>\n\t\n\t<!-- \t//使用多个id获取用户列表\n\tpublic List<User> selectUserListByIds(); (1, 3, 5)-->\n\t<select id=\"selectUserListByIds\" resultType=\"User\">\n\t\tSELECT * \n\t\tFROM USER \n\t\tWHERE u_id \n\t\tIN \n\t\t<!-- (1,2,3) -->\n\t\t<foreach collection=\"array\" item=\"id\" open=\"(\" close=\")\" separator=\",\">\n\t\t\t#{id} \n\t\t</foreach>\n\t</select>\n\t\n\t\t<!-- \t//使用多个id获取用户列表\n\tpublic List<User> selectUserListByIds(); (1, 3, 5)-->\n\t<select id=\"selectUserListByList\" resultType=\"User\">\n\t\tSELECT * \n\t\tFROM USER \n\t\tWHERE u_id \n\t\tIN \n\t\t<!-- (1,2,3) -->\n\t\t<foreach collection=\"list\" item=\"id\" open=\"(\" close=\")\" separator=\",\">\n\t\t\t#{id} \n\t\t</foreach>\n\t</select>\n\t\n\t<!-- \tList<User> selectUserByVo(CountryVo vo); -->\n\t<select id=\"selectUserByVo\" parameterType=\"CountryVo\" resultType=\"User\">\n\t\t<include refid=\"myselect\"/>\n\t\tWHERE u_id \n\t\tIN \n\t\t<!-- (1,2,3) -->\n\t\t<foreach collection=\"list\" item=\"id\" open=\"(\" close=\")\" separator=\",\">\n\t\t\t#{id} \n\t\t</foreach>\n\t</select>\n\t\n\t<!-- \t//使用多个id获取用户列表 by userVO\n\tpublic List<User> selectUserListByUserVo(UserVo vo); -->\n\t<select id=\"selectUserListByUserVo\" parameterType=\"UserVo\" resultType=\"User\">\n\t\t<include refid=\"myselect\"/>\n\t\tWHERE u_id \n\t\tIN \n\t\t<!-- (1,2,3) -->\n\t\t<foreach collection=\"idList\" item=\"id\" open=\"(\" close=\")\" separator=\",\">\n\t\t\t#{id} \n\t\t</foreach>\n\t</select>\n\t\n\t\n</mapper>\n\n```\n\n### 在Mybatis中的（XXXMapper.xml）映射文件中需要注意的事项 \n\n1. namespace 代表该映射文件的域名地址 不要填错\n2. select标签中的id **必须与对应Mapper.java文件中的方法名一致！！！**\n3. parameterType 代表接口中方法的形参类型 要一致\n4. resultType代表返回类型，以下两者均可 要一致\n（com.sikiedu.bean.User是全称）\n（user是Mybatis配置文件中配置好的 TypeAlias起的别名）\n5. 具体的SQL语句中 #{x} 的x代表UserMapper接口文件中形参名 要一致\n\n### UserMapper.java文件（映射接口文件）\n\n```java\npackage com.sikiedu.mapper;\n\nimport java.util.List;\n\nimport com.sikiedu.bean.User;\nimport com.sikiedu.bean.UserVo;\n\npublic interface UserMapper {\n\n\t//mapper动态代理开发四大原则 + 一个注意\n\t//1、接口方法名需要与mapper.xml的要调用的sql语句的id一致\n\t//2、接口的形参类型需要与mapper.xml parameterType 一致\n\t//3、接口的返回值需要与mapper.xml resultType一致\n\t//4、mapper.xml 中namespace要与接口的全包名一致\n\t//5、注意mapper动态代理开发中，根据返回值类型来自动选择\n\t\n\t//通过id查询一个用户\n\tpublic User selectUserById(Integer id);\n\t\n\t//通过用户名模糊查询 获取用户列表\n\tpublic List<User> selectUserByName(String name);\n\t\n\t//通过UserVo id查询一个用户\n\tpublic User selectUserByUserVoId(UserVo vo);\n\t\n\t//查询用户总条数\n\tpublic Integer selectUserCount();\n\t\n\t//查询所有用户包装类\n\tpublic List<UserVo> selectAllUserVo();\n\t\n\t//多条件查询 通过用户对象中的条件查询用户列表\n\tpublic List<User> selectUserListByUser(User u);\n\n\t//多条件查询 通过用户对象中的条件查询用户列表Trim\n\tpublic List<User> selectUserListByUserTrim(User u);\n\n\t//更新用户表\n\tpublic void updateSetUser(User u);\n\t\n\t//使用多个id获取用户列表 by array\n\tpublic List<User> selectUserListByIds(Integer[] ids);\n\t\n\t//使用多个id获取用户列表 by list\n\tpublic List<User> selectUserListByList(List<Integer> idList);\n\t\n\t//使用多个id获取用户列表 by userVO\n\tpublic List<User> selectUserListByUserVo(UserVo vo);\n}\n\n```\n\n### 与数据库中相对应的实体类文件（XXX.java)\n\n```java\npackage com.sikiedu.bean;\n\nimport java.util.Date;\n\npublic class User {\n\n\t/**\n\t * CREATE TABLE `user` (\n\t  `u_id` INT(11) NOT NULL AUTO_INCREMENT COMMENT '用户id',\n\t  `u_username` VARCHAR(64) NOT NULL COMMENT '用户名',\n\t  `u_password` VARCHAR(64) NOT NULL COMMENT '用户密码',\n\t  `u_sex` VARCHAR(16) DEFAULT NULL COMMENT '用户性别',\n\t  `u_createTime` DATETIME DEFAULT NULL COMMENT '用户创建时间',\n\t  `u_cid` INT(11) NOT NULL COMMENT '用户国家id',\n\t */\n\t\n\tprivate Integer u_id;\n\tprivate String u_username;\n\tprivate String u_password;\n\tprivate String u_sex;\n\tprivate Date u_createTime;\n\tprivate Integer u_cid;\n\t\n\tpublic Integer getU_id() {\n\t\treturn u_id;\n\t}\n\tpublic void setU_id(Integer u_id) {\n\t\tthis.u_id = u_id;\n\t}\n\tpublic String getU_username() {\n\t\treturn u_username;\n\t}\n\tpublic void setU_username(String u_username) {\n\t\tthis.u_username = u_username;\n\t}\n\tpublic String getU_password() {\n\t\treturn u_password;\n\t}\n\tpublic void setU_password(String u_password) {\n\t\tthis.u_password = u_password;\n\t}\n\tpublic String getU_sex() {\n\t\treturn u_sex;\n\t}\n\tpublic void setU_sex(String u_sex) {\n\t\tthis.u_sex = u_sex;\n\t}\n\tpublic Date getU_createTime() {\n\t\treturn u_createTime;\n\t}\n\tpublic void setU_createTime(Date u_createTime) {\n\t\tthis.u_createTime = u_createTime;\n\t}\n\tpublic Integer getU_cid() {\n\t\treturn u_cid;\n\t}\n\tpublic void setU_cid(Integer u_cid) {\n\t\tthis.u_cid = u_cid;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"User [u_id=\" + u_id + \", u_username=\" + u_username + \", u_password=\" + u_password + \", u_sex=\" + u_sex\n\t\t\t\t+ \", u_createTime=\" + u_createTime + \", u_cid=\" + u_cid + \"]\";\n\t}\n}\n\n```\n\n1. **推荐类名的私有变量的名字完全与数据库中字段名相同**\n2. 给相应**Set、Get方法**即可\n3. **toString方法**\n\n### 函数如何调用完整的Mybatis过程(增删改查)\n#### 一、selectOne 函数（查询）\n```java\n@Test\n\t//入门程序 通过ID 查询用户\n\tpublic void Test1() throws IOException {\n\t\tString resource = \"sqlMapConfig.xml\";\n\t\t\n\t\t//读取配置文件\n\t\tInputStream in = Resources.getResourceAsStream(resource);\n\t\t\n\t\t//需要sqlSessionFactoryBulider\n\t\tSqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();\n\t\t\n\t\t//创建sqlSessionfactory\n\t\tSqlSessionFactory ssf = ssfb.build(in);\n\t\t \n\t\t//生产一个sqlSession\n\t\tSqlSession session = ssf.openSession();\n\t\t\n\t\t//操作数据库\n\t\t//参数1：要操作的接口方法   参数2 sql语句的参数\n\t\tUser user = session.selectOne(\"UserMapper.selectUserById\", 1);\n\t\tSystem.out.println(user);\n\t}\n```\n\n#### 二、session的getMapper方法 找到Dao层接口类（查询）\n```java\n\t\tString resource = \"sqlMapConfig.xml\";\n\t\t\n\t\t//读取配置文件\n\t\tInputStream in = Resources.getResourceAsStream(resource);\n\t\t//需要sqlSessionFactoryBulider\n\t\tSqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();\n\t\t//创建sqlSessionfactory\n\t\tSqlSessionFactory ssf = ssfb.build(in);\n\t\t\n\t\t//将IUser加入工厂中 以getMapper找到\n\t\tsqlSessionFactory.getConfiguration().addMapper(IUser.class);\n\t\tSqlSession session = sqlSessionFactory.openSession();\n\t\t\n        try {\n\t\t\t//通过getMapper方法 找到IUser接口类\n            IUser iuser = session.getMapper(IUser.class);\n\t\t\t//调用相应方法（增删改查）\n            User user = iuser.getUserByID(1);\n            System.out.println(\"名字：\"+user.getName());\n        } finally {\n            session.close();\n        }\n```\n\n**Mybatis的调用过程中：**\n1. 首先需要输入流 读取配置文件sqlMapConfig.xml\n2. 需要一个工厂建造者Builder 来利用这个输入流建造\n3. 建造返回一个工厂 用这个工厂打开一次会话\n4. 在会话中Select...等等\n5. 对于更改操作（插入、更新、删除）记得**session.commit()**\n6. session的对应方法 **第一个参数是通过XXXMapper.对应方法 第二个是传入的实参**\n\n#### 三、session的getMapper方法 找到Dao层接口类（插入）\n```java\n\t....忽略配置文件加载、SQLSession建造者、工厂....\n\t\n\ttry {\n\t\t//通过getMapper方法 找到IUser接口类\n\t    IUser iuser = session.getMapper(IUser.class);\n\n\t\t//假设该接口类有 void方法insertUser(User user)\n\t    User user = new User();\n\t\tuser.setXXX(\"xxx\");\n\t\t...set方法\n\t\t\n\t\t//插入数据 记得提交会话（包括删除操作、更新操作）\n\t\tiuser.insertUser(user);\n\t\tsession.commit();\n\t\t\n\t} finally {\n\t    session.close();\n\t}\n```\n\n#### 四、session的getMapper方法 找到Dao层接口类（更新）\n```java\n\t....忽略配置文件加载、SQLSession建造者、工厂....\n\t\n\ttry {\n\t\t//通过getMapper方法 找到IUser接口类\n\t    IUser iuser = session.getMapper(IUser.class);\n\n\t\t//首先通过相应属性找到user\n\t\tUser user = iuser.getUserById(1);\n\t\t\n\t\t//假设该接口类有 void方法updateUser(User user)\n\t\t//将user的name更改为Vincent\n\t\tuser.setName(\"Vincent\");\n\t\t\n\t\t//更新数据 记得提交会话\n\t\tiuser.updateUser(user);\n\t\tsession.commit();\n\t\t\n\t} finally {\n\t    session.close();\n\t}\n```\n\n#### 五、session的getMapper方法 找到Dao层接口类（删除）\n```java\n\t....忽略配置文件加载、SQLSession建造者、工厂....\n\t\n\ttry {\n\t\t//通过getMapper方法 找到IUser接口类\n\t    IUser iuser = session.getMapper(IUser.class);\n\n\t\t//首先通过相应属性找到user\n\t\tUser user = iuser.getUserById(1);\n\t\t\n\t\t//假设该接口类有方法 deleteUser(User user)\n\t\t//记得提交会话\n\t\t\n\t\tiuser.deleteUser(user);\n\t\tsession.commit();\n\t\t\n\t} finally {\n\t    session.close();\n\t}\n```\n\n\n### ResultMap：解决数据库字段与Java实体类的属性不一致问题\n#### 1.Result实现JavaBean对象与数据库column名字不一样的映射\n```java\n<!-- type表示具体的Java类 id随便取-唯一标识即可 -->\n<resultMap type=\"CountryVo\" id=\"countryVo\">\n\t\t\n\t\t<!-- id标签是主键 property是Java类中的属性 column是对应Java类在数据库表中的字段 -->\n\t\t<id property=\"id\" column=\"c_id\"/>\n\n\t\t<!-- result可以是若干个其他 非主键属性的对应 -->\n\t\t<result property=\"c_countryname\" column=\"c_countryname\"/>\n\t\t<result property=\"c_capital\" column=\"c_capital\"/>\n</resultMap>\n```\n\n#### 2.Result实现一对多映射 Collection\n比如一个用户User 有多个帖子Post\n现在查询对应的User 查看这个User下的所有帖子（因此帖子是集合```java private List<Post> posts;```)\n\n1.User类\n```java\n\n//要实现序列化Serializable\npublic class User implements Serializable{\n\tprivate int id;\n\tprivate String username;\n\tprivate String mobile;\n\t\n\t//一个User 对应多个Post 因此用集合\n\tprivate List<Post> posts;\n\t\n\t...忽略set get方法以及toString方法\n}\n```\n\n2.Post类\n```java\npublic class Post implements Serializable{\n\t//查询的时候 post.id 应该等于 user.id\n\tprivate int id;\n\tprivate User user;\n\tprivate String title;\n\tprivate String content;\n\t...忽略set get方法以及toString方法\n}\n```\n\n3.ResultMap配置一个用户多个帖子的映射\n```xml\n\t<!-- 在一个User中配置 多个collection -->\n\t<resultMap type=\"User\" id=\"resultUserMap\">\n\t\t<result property=\"id\" column=\"user_id\" />\n\t\t<result property=\"username\" column=\"username\" />\n\t\t<result property=\"mobile\" column=\"mobile\" />\n\t\t<!-- collection代表多  -->\n\t\t<!-- posts代表User类中 集合的名字！column代表post表中的那个字段 与user联系 -->\n\t\t<collection property=\"posts\" ofType=\"com.yiibai.pojo.Post\" column=\"userid\">\n\t\t\t<id property=\"id\" column=\"post_id\" javaType=\"int\" jdbcType=\"INTEGER\"/>    \n            <result property=\"title\" column=\"title\" javaType=\"string\" jdbcType=\"VARCHAR\"/>\n            <result property=\"content\" column=\"content\" javaType=\"string\" jdbcType=\"VARCHAR\"/> \n\t\t</collection>\n\t</resultMap>\n```\n\n4.SQL语句\n```xml\n<!-- 指定结果映射为resultUserMap 需要跟相应resultMap标签的id相同 -->\n<select id=\"getUser\" resultMap=\"resultUserMap\" parameterType=\"int\">\n\t\t<!-- 建立映射就是为了 能够映射SELECT后面的内容:u.*, p.* -->\n\t\t<!-- 没有建立映射的property返回的值不会显示在后台里 -->\n\t\tSELECT u.*,p.*\n\t\tFROM user u, post p\n\t\tWHERE u.id=p.userid AND id=#{user_id} \n </select>\n```\n\n**2021.4.6更新：**\n1. 注意都实现**Serializable**接口\n2. 注意，如果两张表中的字段重复了，记得在Select字段中起别名\n3. collection中的id标签 不会指两者映射的id **而只是指这个表的主键！**\n4. 真正映射一对多的 是collection中的**column属性**\n\n起别名代码：\n```sql\n<select>\n\tselect u.id as u_id, u.*, p.id as p_id,p.*\n\tfrom user u, post p\n\twhere u.u_id = p.p_id AND u.u_id = #{id}\n</select>\t\n\n```\n\n### Mybatis_plust新特性：代码生成器\n**注意，这里的代码指的是：**\n\n**1. DAO层的XXXMapper.java接口\n2. DAO层的XXXMapper.xml文件\n3. Model层的XXXExample.java类 方便提前处理数据**\n\n#### 1.需要的插件（IDEA右侧 MAVEN里面的插件双击启动）\n\n```java\n<plugin>\n\t<groupId>org.mybatis.generator</groupId>\n\t<artifactId>mybatis-generator-maven-plugin</artifactId>\n\t<configuration>\n\t\t<configurationFile>${basedir}/src/main/resources/mybatis-generator/generatorConfig.xml\n\t\t</configurationFile>\n\t\t<overwrite>true</overwrite>\n\t\t<verbose>true</verbose>\n\t</configuration>\n</plugin>\n```\n\n项目结构图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210410185916946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n#### 2.配置文件 generatorConfig.xml\n\n**这一步很关键，要避免多次生成重复的BaseResultMap**\n\n**注意对应Mapper.java/ Mapper.xml在项目结构图中的位置**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n\n<generatorConfiguration>\n\n    <!--    连接数据库jar包的路径-->\n    <classPathEntry location=\"C:\\Users\\Administrator\\.m2\\repository\\mysql\\mysql-connector-java\\8.0.23/mysql-connector-java-8.0.23.jar\"/>\n    \n\t<context id=\"DB2Tables\"  targetRuntime=\"MyBatis3\">\n        <commentGenerator>\n            <property name=\"suppressDate\" value=\"true\"/>\n            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->\n            <property name=\"suppressAllComments\" value=\"true\"/>\n        </commentGenerator>\n\n        <!--数据库连接参数 -->\n        <jdbcConnection\n                driverClass=\"com.mysql.jdbc.Driver\"\n                connectionURL=\"jdbc:mysql://localhost:3306/vue_demo?serverTimezone=UTC&amp;useSSL=true\"\n                userId=\"root\"\n                password=\"123456\">\n\t<!-- 避免生成重复的BaseResultMap -->\n            <property name=\"nullCatalogMeansCurrent\" value=\"true\" />\n        </jdbcConnection>\n\n        <javaTypeResolver>\n            <property name=\"forceBigDecimals\" value=\"false\"/>\n        </javaTypeResolver>\n\n        <!-- 实体类的包名和存放路径 -->\n        <javaModelGenerator targetPackage=\"com.example.demo.entity\" targetProject=\"src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n            <property name=\"trimStrings\" value=\"true\"/>\n        </javaModelGenerator>\n\n        <!-- 生成映射文件*.xml的位置-->\n        <sqlMapGenerator targetPackage=\"mybatis\" targetProject=\"src/main/resources\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </sqlMapGenerator>\n\n        <!-- 生成DAO的包名和位置 -->\n        <javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.example.demo.repository\" targetProject=\"src/main/java\">\n            <property name=\"enableSubPackages\" value=\"true\"/>\n        </javaClientGenerator>\n\n        <!-- tableName：数据库中的表名或视图名；domainObjectName：生成的实体类的类名-->\n        <!--<table tableName=\"book\" domainObjectName=\"Book\"/>-->\n        <table schema=\"catalog\" tableName=\"user\" domainObjectName=\"User\"/>\n\n    </context>\n</generatorConfiguration>\n```\n\n### Mybatis中出现的问题：\n\n#### 1.UserMapper.xml到底应该放在那里？\n**注意，在集成SpringBoot时**\n\n1. 首先确保 **UserMapper.java要有@Mapper注解**\n\n2. 其次，要注意**在SpringBoot配置文件application.yml中：**\n\n```yml\nmybatis:\n\tmapper-locations: classpath:mybatis/*.xml\n```\n\n并且项目结构图如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210406191232940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n3. UserMapper.xml中的namespace是UserMapper.java的具体位置\n\n**或者代码generator生成的配置文件中配置**\n\n```xml\n<mapper namespace=\"com.example.demo.repository.UserMapper\"> \n</mapper>\n```\n\n#### 配置实体类应该注意的问题\n\n**1. 尽量让实体类中的各个private属性名字与数据库的字段名字相同**\n\n**2. 用封装类！不要用int，而是应该用`Integer`**\n\n**3. 如果实体类中的属性名与数据库中的字段名相同，这样mapper中参数为实体类时，才能返回**","tags":["SSM学习笔记"],"categories":["SSM学习笔记"]},{"title":"不会吧？都2021年了，还有人觉得考研英语简单！？","url":"/2021/03/11/不会吧考研英语/","content":"\n<!-- 页面必备样式 -->\n<style>\n.back-top{position: fixed;top: 500px;height: 0px;float: right;right: 50px;}\n.back-top>a{font-weight:bold;width: 50px;height: 50px;text-align: center;text-decoration: none;font-size: 5px;line-height: 50px;border-radius: 50px;background-color:rgba(255,255,255,0.5);}\n</style>\n<div class=\"back-top\">\n\t<a href=\"#top\"> >返回顶部< </a>\n</div>\n<!-- toc -->\n<!-- 必备样式结束 -->\n\n# 刚过线低分学长考研英语做题方法分享（全是干货）你还在等什么？等我吗？：\n# 作者前言\n&nbsp;&nbsp;&nbsp;&nbsp;\n考研英语分为英语一与英语二，其中英语一多为学术型研究生而准备，而英语二多为专业型研究生而准备。本文旨在总结考研一路走来**自己对英语二学科的重要总结以及经验之谈**，<mark>比较适合在经过一段真题复习之后抓重点、查漏补缺！</mark>希望阅读到本文的你能够有所得。Respect！\n\n# 一、完形填空 Use of English\n<br>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;完形填空，一直都是大家不重视的科目，毕竟所占的分数不多，才 “十分”，但是非常重要！（请大家务必重视完形的做题方法）万事开头难，完形也不例外。</p>\n\n> Without further ado 废话不多说，我们直接进入正题~\n\n&nbsp;&nbsp;&nbsp;&nbsp;以下笔记以及方法论，自己总结归纳众多名师（其实没怎么看他们本人的课，都在各个网络渠道微博，知乎，哔哩哔哩等看到的方法哈哈哈）\n\n完形填空我建议同学去读读 **刘晓燕老师的《真题就这么点儿事》** 与**有道的赵楠楠老师**的相关教学，正文开始！\n<br>\n## 1.读懂前两句/段，即读懂文章的 *中心主旨句* ！\n<br>\n读懂文章所围绕写的中心，同时联系作者自身的态度！这一步能否做到，能决定你是否读懂文章大致走向（**同时也是阅读理解做题步骤中，关键的一步！后话。**）\n\n例如：（2015年英语二文章）\n==In our contemporary culture== , the prospect of communicating with-or even looking at- a stranger is virtually unberable. ==Everyone== around us   seems to  ==agree==  by the way they cling to their phones, even without a __ on a subway.\n\n\n第一句指出，**当代文化（=大众 everyone）认为，与陌生人交谈，甚至看向陌生人都是不可忍受的，** // 而**作者**的观点， **大多“*反对*”大众文化。**  \n\n我们看看第二段怎莫硕呢：\n\n  ==It's a sad reality== ---our desire to avoid interacting with other human beings---because there's___to be gained from talking to the stranger standing by you. \n  \n  \"sad\"表明作者对此观点表示批判（小技巧：附有<u>鲜明态度</u>的形容词，一般很好地体现出作者的态度），同时==表明自己的观点（与大众相反即可）：看向陌生人，与陌生人交谈其实没那么难以忍受。==\n\n在知道作者的观点与态度或者文章的主旨句之后，再去斟酌每个选项，也许可以从更宏观的方面去把握更正确更优的答案。\n\n我们再来看个例子：（2013年英语二文章）\n\nGiven the advantages of electronic money,==you might think== that we would move quickly to the cashless society in which all payments are made electronically. ___, a ==true== cashless society ==is probably not around the corner==.\n\n如出一辙，**you might think = 大众的观点**，即认为很快会进入“无纸化社会”，而后提到<mark>真正的无纸化社会也许还没有到来，明显提出自己的观点。</mark>因此，全文的选项，选择时都应该按照 **无纸化不会到来** 这个大方向来做。\n\n\n<br>\n\n## 2.具体填空处前后“词语”的逻辑关系\n<br>\n例如：（2018年英语二文章）\n\nThe drive to discover is deeply rooted in humans, much the same as the basic drives **for __ or shelter.**\n\n该文章主要说明：为什么人们总是在网上浏览很负能量的评论，做一些明显很令人痛苦的事情。<mark>因为人们习惯去解决“不确定”，可能明知到事情的答案，还是想满足自己内心的好奇心。</mark>\n\n而聚焦到问题，说**人类探索未知的渴求，如同探求__或避难所（庇护）一样**，或者所连接的前后意思相近\n\n<mark>A.Food （食物）</mark>  B.pay（工资） C.Marriage（婚姻） D.schooling（学校教育）\n根据排除法和常识，我们可以确定答案选 A，与 shelter 避难所含义相近。\n\n譬如active 与 alive 也是具有相同意义的词语。\n\n若文章的中心是反对战争支持和平，那么若某一细节处出现 *** ___war *** 选项中优先考虑 against等表示反对的介词.\n<br>\n## 3.具体填空处前后“语句”的逻辑关系\n<br>\n例如：（2013年英语二文章）\n\nGiven the advantages of electronic money,==you might think that we would move quickly to the cashless society in which all payments are made electronically.== ___, ==a true cashless society is probably not around the corner==.\n\n您也许会认为我们很快会进入无纸化社会，但是真正的无纸化社会也许可能不会很快来到。根据插入语（即填空处）前后的逻辑关系，属于虽然但是（让步状语从句），且转折处为作者观点，是重点！聚集选项：\n\n<mark>A. However (然而)</mark>\nB. Moreover (而且)\nC. Therefore (因此)\nD. Othervise (否则)\n\n同样地，对于：\n\t1.总分结构再次强调作者观点句的：For instance, for example,\n<br>\n\n## 4.与<mark>文章背景相关(context-oriented)</mark>的单词更容易成为正确选项\n<br>\n例如：（2013年英语二文章）\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210111204641483.png)\nDishonest persons 可能会进入电子支付系统并__某人的账户，本文所讲的是无纸化社会不会到了，**也就是说作者对无纸化社会的态度是negative的，因而我们首先判断这个动词的褒贬方向：是好的方向，还是坏的方向；** <mark>既然针对 “electronic payments system” 那么代表坏的方向</mark>，因而我们聚焦到选项：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210111205029885.png)\nA. 偷窃，盗取 \nB. 选择\nC. 使受益\nD. 返回，收益(pl) \n\n了解到出题者的用心良苦后，我想答案不言而喻。\n<br>\n\n## 5.填空之处前后的固定搭配&词组辨析\n<br>\n例如：2015年英语二真题!\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210112134801301.png)\n文章在此处阐述，与其与陌生人交谈，倒不如自己在乘车时独自闭口不谈，而在经历实验之后，大家没有觉得 “与陌生人交谈”让人尴尬。\n\n聚焦选项：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021011213512487.png)\ngo through with 经历 do away with 终结，废除 catch up with 追赶 put up with 容忍，忍受\n这里用put up with是不恰当的，因为受实验者并没有完全谴责或者反对与陌生人交谈的行为。因为使用经历较好。\n\n利用上文五大点，无论是宏观把握还是细节斟酌都能很好地选出最优答案，剩余的事情，就是从反复研读历年真题。找出选项与所在处前后的共性，不断总结归纳常考词汇。\n<br>\n<br>\n\n# 二、阅读理解\n## 1.个人认为，对于考研英语试卷而言，卷子的核心是阅读！阅读是值得我们反复研读的。\n<br>\n\n## 2.扎实的词汇基础，严谨的行文思路，最后辅佐于相对正确的小技巧。一定可以拿下高分！\n<br>\n对于英语而言，夯实词汇基础的重要性不言而喻，单词都不认识，更不用说读文章了。\n市面上有太多太多的词汇书。\n\n 基础不太好的同学，建议跟相关老师的视频课，撇开阅读而谈词汇： **朱伟老师的词汇课挺不错的！何凯文老师的必考词汇也不错，有些推荐的单词是专八系列。从词汇本身的难度而言，是比较好的，附有相近词与例句。** 建议基础较好的同学，可以不用听专门的词汇课，本人**反复看《十天搞定考研词汇》再辅佐历年真题（真题词汇，建议自己总结！！！）**，可以达到一样的效果，\n\n阅读方法正文：（本段以历年真题为例子）\n<br>\n## 拿到文章先看选项，只看选项即可（预热）\n<br>\n\n**考研阅读板块，我建议跟名师：\n1.有道唐迟老师、赵楠楠老师\n2.前文都、现新文道教育何凯文老师**\n\n唐迟而言，***串联题干而避免选项干扰*** 是对锁定文章内容、排除错误方向起着重要作用的。\n\n看完选项后，根据零散的记忆，<mark>是否可以推测以下大致围绕什么主题讲。</mark> 经济？社会问题？现象？文化板块....\n\n直接上题：2020年英语二真题Text1\n\n第一问：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113141557664.png)\n第二问：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113141620827.png)\n第三问：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113141646664.png)\n第四问：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113141704780.png)\n第五问：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113141722392.png)\n总览所有选项，几乎不离 <mark>Rat 老鼠 and Robot 机器人（文中的机器鼠）</mark> 单词，因而我们在读完题目之后。思考：\n本文或许是阐述，有关于老鼠的实验，从实验中，我们应该找到：\n\n1.<mark>具体人物表达的观点或态度</mark>\n\n2.<mark>作者的态度/若无明显态度，则作者不反对的态度基本与作者态度一致</mark>\n<br>\n\n## 再读完题目后，回到文章本身，精读文章首段/首两段\n<br>\n\n熟悉吗？没错，就是完形填空的第一步！精读文章第一段，再对文章大致主题的主观推测基础上，用作者自己的话再次佐证文章的中心话题。譬如本文第一段：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113161234364.png)\n第一句中，挑出比较重要的部分，to attuned to 意为 “ 适应，调整 或 对...敏感”。**因此，开篇提到老鼠对社会信号高度敏感，以此来认清敌友。** 因此纵观全文，作者应探讨老鼠与 “社会信号” 的关系。\n\n再比如：2018年英语二Text2\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113162005224.png)\n这种以 “while” 引导的让步状语从句，是考研长句中比较普遍的句式。**while** 此时作 “尽管，虽然” 的意思，<mark>从句不重要！重要的是主句</mark>，即逗号后面的内容（**未来属于例如风能、太阳能等新能源**）这一句同时也是文章围绕讲的内容。因此作者既然说出来了未来是属于**新能源**的，那么作者对新能源应持**正面，支持**的态度！\n\n<br>\n\n##  细节题目怎么做？难，难在什么地方？\n<br>\n个人认为，只需要将文章分为：\n\n**1.主旨题， 2.细节题， 3.例证题  4.态度题**\n\n凡是不属于主旨题（*中心思想，文章题目，文章大致内容*）、例证题（*某某例子说明什么？作者通过xx想表达什么？*）以及态度题（*不管是作者还是出现的某某某*）的，都归于**细节题，从文章某处本身上下文寻找最优答案。**\n\n看几个例子：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113162904700.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021011316291555.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113162945809.png)\n\n做法因人而异，但个人觉得比较适合大家的是：\n1.通读全文，一顿勾勾画画\n**2.定位到相应的句子，读懂句子，联系中心！！！\n3.找选项中错误的句子，找与关键句子同意替换的表达式\n4.与文章中心靠拢！排除与中心相反或根本无关的句子**\n\n其中，2，3，4，是较为困难的过程，同时需要大量的反复练习。揣摩到底这个选项是不是符合中心内容的，是不是对的？**哪里有相应同意的表达句**，或者是不是正话反说？（出现过，概率不大）\n\n仍然聚焦 2020年英语二 Text1：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113164018186.png)\n**Q与同事对老鼠进行测试是想看看老鼠是否会___?**\n\n明显属于细节题，看文章内容：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113164323905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n其中，蓝色划线句是文章背景句。而红色划线句是相应重点句，文章说：为了看看这种敏感程度是否会延伸到 “非动物”身上即：（**老鼠是否会对来自机器鼠的社交信号而敏感**），因而与选项中比对，是否有与其同意表达的，排除与中心内容无关的，排除说法相反的。\n\n选项：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210113164958811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**答案一定是来自文章的句子的，绝不是经过主观理解臆断出来的。** 这是考研英语阅读不变应万变的宗旨。因而，A选项提到**是否老鼠能够获得来自“机器鼠”的社交信号** ，即是细节句的同意表达。因而正确！因为是细节句的同意表达，因而在A选项的存在情况下，其他选项不具备更优答案的气质。\n\n再举个例子：\n2020年 Text4\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115141124847.png)\n M认为，相比较于 **millennials（千禧一代）** ，**Z世代比较___？**\n\n根据定位出题处，\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115141531762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n** 注意：题中问的<mark>Z世代</mark>如何？因此选项中可以排除千禧一代所具有的特点(flexible)。**而文中提到因为零工经济 (gig economy) Z世代者寻求更多的确定性、稳定性** ，有这一关键句就够了。从选项中找“确定性” “稳定性” 的同义词，同时排除相反的词。聚焦选项：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115141904345.png)\nA 更加勤奋 （中心无关）\nB 更加慷慨（同理）\nC 没那么追求实际 （相反含义应排除，因为正是零工经济，所以追求实际情况） \n**D 没那么冒险、比较谨慎** （more certainty、stability 的同义词 = 谨慎，不冒险）\n\n因此，该类型的题目的核心点：<mark> **答案文中找，不找无关的，找同意替换、更贴近中心的。**</mark>\n\n<br>\n\n## 例证题不找例子？那找什么？\n<br>\n\n相信听过唐迟老师课程的同学都知道， **例子不重要，重要的是例子所欲支撑的观点。** 没错，我们的目的就是找例子前后的观点。说来简单，做来实属不易。\n\n举个例子：2019年Text2\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115143256658.png)\n作者谈到 “艰难的挑战之一” ，何意？\n\n回归文章：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115143520867.png)\n句子很长，内容比较多。但是挑出与题目更直接相关的内容。可以看到，开篇作者提出森林给了我们庇护，**给了我们在应对环境变化中出现的艰难挑战** ，fight against climate change 是好事情啊，为何提到是 challenge 挑战呢？原来，The climate change **会使得森林排放比自身吸收得更多的碳元素** = **入不敷出** ，<mark>因而有了这一关键句就够了。做题时，抓住好事会变成坏事，找**森林给了我们艰难挑战**的同意表达：</mark>\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115144129782.png)\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115144136539.png)\n相比较而言，**森林给了我们艰难挑战**对应同意表达的选项是\n**【B】forests may become a potential threat 森林有可能成为潜在的威胁 = 艰难挑战 = 排放出多于自身吸收的碳元素**\n\n\n\n再看一个例子：2021年 Text 2\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115145244463.png)\nL大学的报告显示，在英国，____\n\n回归文章：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115144952172.png)\n划线句子是关键句，**根据报道，在英国，全国85%的土地与肉产品、奶制品直接相关。** 读文章时，有些必要成分是一定要揣摩的，比如 “数字” “书名号” “感叹号” <mark>作者不会无缘无故提到数字，不会无缘无故地提到某书的命名，同时也不会无缘无故地感叹、发表观点。</mark>\n\n比如这里，文中出现 85% ，*心中就要想，这个数字代表什么？想要强调什么？好事还是坏事？会不会与作者态度相关？*\n\n找到关键句后，回归选项：\n\n  [A] farmland has been inefficiently utilised\n  [B] factory style production needs reforming \n  **[C] most land is used for meat and dairy production**\n  [D] more green fields will be converted for farming\n      \n因而经过**关键句的同意表达：85% percent = most land** 再三斟酌，可以选出正确答案 C选项。\n<br>\n    \n## “主旨题” 约等于 ≈ 观点态度题？\n\n文章的主旨就是整个文章的心脏，文章主旨当然大部分是与作者观点态度直接相关的。因而，做文章时，应首先明确自己的做题目标：\n\n①、文章主旨/文章中心 \n\n②、作者观点（是否相同/相反）\n\n这一块我还是力挺唐迟老师的做法：**回文法。**\n如果给你ABCD四个标题，或者四个文章主旨，你会怎么写文章？\n\n例如：2016年text3\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115150846804.png)\n直接看第一段，思考中心话题\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115151027413.png)\n每个人都太忙了，这已经是Cliche（陈词滥调，老生常谈）了。**而抱怨声尤其来自：没时间阅读。** 至此，我们已经可以猜测到，这篇文章**是讲没时间阅读这个现象**，作者一定会围绕这个中心话题展开探讨。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115151317671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n因而，答案一目了然。 <mark>How to Find Time to Read 如何空出时间来阅读？</mark> 这不就是中心话题吗？反过来说，如果是命题作文：如何空出时间阅读？\n\n第一步当然就是陈述现象！阐述随着当今世界发展，越来越多的人哀嚎：没有时间阅读。然后继续行文...\n\n再举个例子：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115151704858.png)\n问作者态度，针对英国政府目前在**运动**方面所作出的努力。\n\n回归文章：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115152007604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\nThe Parkrun phenomenon 本地公园跑现象的成功，更加凸显**伦敦奥运遗风的失败！**，为全文点出**批评英国政府的总基调**。作者提到：十年前，Planning documents 承诺人们会更苗条，更健康，然后事情并不如人意，**Officials 并没有激励新一代更多地参与体育！** \n\n聚焦选项：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115152459147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\nA 忍受，容忍\nB 批判，批评\nC 不确定的\nD 同情的\n\n根据作者所表达的态度，**伦敦奥运遗风的失败！**  **批评英国政府的总基调,**  **Officials 并没有激励新一代更多地参与体育！** 我们可以确定，作者**对英国政府持批评态度**！\n<br>\n\n# 三、新题型（阅读理解的“儿子”：定位-关键句-比对）\n<br>\n\n为什么这么说？很简单，不管是**小标题题型**（每段话缺标题，给出若干个标题，一一对应）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121143412673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121143418117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n还是**概括句题** （文章后有一个表格，将左边的事物与右边的表述一一正确对应）\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121143449877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n均是在<mark>在阅读文章，完全理解了文章之后！对阅读到的信息进行归纳总结。</mark>\n\n**新题型板块，我建议：\n有道赵楠楠老师**\n\n可以说对于两种题型，方法大同小异：\n\n<mark>1.定位\n\t2.找同义替换\n\t3.回归选项\n\n带着做题思路做真题，例如2018年小标题题型，放出链接如下：\n\n[2018年真题及答案（转载自百度文库）](https://wenku.baidu.com/view/a3ba8cab900ef12d2af90242a8956bec0975a5df.html)\n\n第一步：**读选项，混个眼熟**\n第二步：读**文章标题**\n第三步：直接聚焦相应段落：**找段落重要句**\n\n\n该文章的标题：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121144526721.png)\n与人交谈的五种方法\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121144832291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n红色是关键句，作者提到：\n**I know the feeling and here is my advice: just get it (想说的话) out.** 读完回归众多选项，进行同义替换：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121145023812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n**Just say it = Just get it out 同意替换，因此相比之下，A为正确答案**\n\n再比如：\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121145651565.png)\n**Find the things which you and that person have in common** 说白了就是找到你与交谈对象所具有的共同点！找到共同点后，两人才能建立connection，才能使得谈话更顺利！\n\n聚焦选项，找与表达 “找共同点” 的同义替换：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121145855141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n再三斟酌，**Find the “me too”s = have in common**   能够形象地表达出共同点！因而，E成为正确答案。\n\n<br>\n\n# 四、翻译\n<br>\n\n翻译是可以说是，英语学科中，最难也是最重要的板块！这个板块中，我建议\n\n**前新东方名师，现跟谁学名师-教翻译的唐静老师**\n\n唐静老师所讲授的知识点特别他的《拆分与组合》，能够从根本上解决无法对句子进行长句断翻、短句补译、整理中英译法之差别等技巧。踏踏实实学翻译。\n\n我建议：\n\n**1.跟唐静老师学视频课\n2.利用学到的技巧，用在历年阅读真题上，精读文章中的句子！**\n\n# 五、作文\n<br>\n\n作文板块，我推荐**王江涛老师的《考研英语高分写作》**，基础不好的同学需要听王江涛老师的视频课，反复听！较好的有该书即可，并辅佐自己平时的总结！**英语作文范文不在于多，而在于精，因此我建议范文处理方法：**\n\n1. 针对**历年真题的五篇不同话题/类型范文**\n2. 《高分写作》老师所给**预测五篇**不同话题/类型\n3. 《高分写作》上每个板块的**作文拓展词汇**\n\n最后，利用已有反复诵读的范文模板，尝试去做新题，输出学到的相应必备句型！**模板的作用是在于用，不在于记！因而，要多用，否则考场上也无法很快地进入状态。**\n\n","tags":["研究生入学考试经验贴"],"categories":["研究生入学考试经验贴"]},{"title":"C/C++ 编程常见代码","url":"/2021/03/11/C_C++ 编程常见代码/","content":"\n\n\n##   1.加法器、累加器：（多实现 1+2+...+n 以及阶乘 n! 的功能）\n#### 一、求累加\n```cpp\nint main(){\n\t\t\n\t\tint i =0;\n\t\tint res = 0;\n\t\tint n;\n\t\tcin >> n;\n\t\t\n\t\twhile(i<=n){\t\n\t\t\tres += i;\n\t\t\ti++;\t\n\t\t}\n\t\t//其中 res为最终结果 n表示加到多少 i表示每次加的数 \n\t\t\n\t\tcout << res <<endl;\n\t\treturn 0;\n\t}\n```\n\t\n\t \n#### 二、求某数阶乘\n```cpp\n\nint main()\n{\n\tint i = 1;\n\tint sum = 1; \n\tint n;\n\tcin >> n;\n\t\n\twhile(i <=n){\n\t\t\n\t\tsum *=i;    // 1. sum = 1*1 =1\n\t\ti++;\t\t// 2. i =2;\n\t\t\t\t\t// 3. sum = 1*2=2 以此类推 \n\t}\n\t\n\tcout << \"其阶乘为：\" << sum <<endl;\n\t\n  return 0;\n}\n```\n## 2. 求两个数或数组中的最大值与最小值\nint main(){\n```cpp\n\tint a, b,max;\n\tcout << \"请连续输入待比较的两个数，空格隔开：\" <<endl;\n\tcin >> a >> b;\n\tmax = (a>b) ? a : b; //使用双目运算符取得最大值\n\tcout << max <<endl;\n\t\t\n\tint arr[5] = {5, 2, 13, 23, 66};\n\tint arr_max, arr_min;\n\tarr_max = arr[0]; //默认第一位元素为最值 \n\tarr_min = arr[0];\n\t\n\tfor(int i =0; i <5; i++)\n\t{\n\t\t\tif(arr_max < arr[i])\n\t\t\t{\n\t\t\t\tarr_max = arr[i];\t\t\n\t\t\t}else if(arr_min > arr[i]){  //往后遍历，若还有更大的则更新最值 否则最小值更新\n\t\t\t\tarr_min = arr[i]; \n\t\t}\n\t}\n\tcout << arr_min << \" \" <<arr_max <<endl;\n\t\n\treturn 0;\n} \n```\n## 3.冒泡排序，必须会默写\n```cpp\n#define LEN 5\nint main(){\n\tint a[LEN] = {2, 13, 5, 55, 20};\n\tfor(int i=0; i<LEN; i++)\n\t{\n\t\tfor(int j=0; j<LEN-i-1; j++){\n\t\t //注意两个for循环的初始条件与终止条件 都从0k开始\n\t\t\tif(a[j] > a[j+1]){\n\t\t\t\tint  t = a[j];\n\t\t\t\ta[j] = a[j+1];\n\t\t\t\ta[j+1] = t;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n## 4.简单的switch-case多分支条件语句\n```cpp\nint main(){\n\tint score;\n\tcout << \"请在0~100范围内输入你的分数(满分100分)：\" <<endl;\n\tcout << \" 60分以下不及格 60~70及格 70~80良好 80以上优秀  \" <<endl;\n\tcin >> score;\n\t\n\tswitch(score/10){\n\t\tcase 6 :\n\t\t\tcout<<\"及格\"<<endl; \n\t\t\tbreak;\n\t\tcase 7 :\n\t\t\tcout<<\"良好\"<<endl; \n\t\t\tbreak;\n\t\tcase 8 :\n\t\t\tcout<<\"优秀\"<<endl; \n\t\t\tbreak;\n\t\tcase 9 :\n\t\t\tcout<<\"优秀\"<<endl; \n\t\t\tbreak;\n\t\tcase 10 :\n\t\t\tcout<<\"满分\"<<endl; \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout<<\"不及格\"<<endl; \n\t\t\tbreak;\n\t}\n\treturn 0;\n} \n```\n## 5.求两个数的最大公约数、最小公倍数(不可含0) (谭浩强C语言例题）\n```cpp\nint main(){\n\tint x, y, r;\n\tcout << \"请输入待运算的两个数, 中间用空格隔开\" <<endl; \n\tcin >> x >> y;\n\tint mul = x * y;\n\t\n\tif(x > y) //将比如 8,2 与 2,8 的操作统一输出\n\t{\n\t\tr = x;\n\t\tx = y;\n\t\ty = r;  \n\t } \n\t \n\tr = x % y;  //直接判断两数是否可以整除 \n\t\n\twhile(r){\n\t\tx = y;\n\t\ty = r;\n\t\tr = x % y; \n\t\t//辗转相除法\n\t\t//直到余数不为0 \n\t\t//将余数作为除数 较小者作为被除数 继续求余判断\n\t}\n\tcout << \"最大公约数:\" << y << \"，最小公倍数:\" << mul / y <<endl;\t \n\t\n\treturn 0;\n} \n```\n## 6.斐波那契数列递归\n```cpp\nint fib(int n){\n\tif(n == 1){\n\n\t\treturn 1;\n\t}else if(n == 2){\n\n\t\treturn 1;\n\t}else{\n\n\t\treturn fib(n-2) + fib(n-1);\n\t}\n}\n```\n1, 1, 2, 3, 5...以此类推\n\n## 7.判断某数是否是素数 (谭浩强C语言例题）\n```cpp\n\nint main()\n{\n  int n, i;\n  bool isPrime = true;\n \n  cout << \"输入一个正整数: \";\n  cin >> n;\n \n  for(i = 2; i <= n / 2; ++i)\n  {\n      if(n % i == 0) //只能被1 和 自身整除的数 才能是素数 \n      {\n          isPrime = false;\n          break;\n      }\n  }\n  if (isPrime)\n      cout << \"是素数\";\n  else\n      cout << \"不是素数\";\n  return 0;\n}\n```\n\n## 8.大写字母转化为小写字母\n```cpp\n \nint main()\n{\n\t\n\tchar a;\n\ta = getchar();\n\tprintf(\"%c\", a+32); // C或C语言中字符数据均以ASCII值存储 大写字母与小写字母相差32\n\t\n  return 0;\n}\n```\n## 9.统计输入字符中单词的个数 (谭浩强C语言例题）\n```cpp\n#include<stdio.h>\n#include<iostream>\n#define N 30\n\nusing namespace std;\nint main()\n{\n\tchar b[N];\n\tint word,count=0,i; //word代表是否是单词 1代表是 0代表不是单词 而是空格 \n\t\t\t\t\t\t//count 代表单词个数\t \n\tputs(\"输入的字符长度要小于等于N\"); // 例如->  hello world \n\tgets(b);\n\t\n\tfor(i=0;b[i]!='\\0';i++)\n\t\tif(b[i]==' ')  //若为空格则不是单词 \n\t\t   word=0; \n\t\telse if(word==0) //若是空格则遇到的新单词使得count加一 \n\t\t{\n\t\t\tcount++;\n\t\t\tword=1;\n\t\t}\n\tprintf(\"%d\",count);\n\treturn 0;\n}\n```\n\n## 10.求Sn=a+aa+aaa+…+aa…aaa（有n个a）之值，其中a是一个数字，为2。 例如，n=5时=2+22+222+2222+22222，n由键盘输入。 (谭浩强C语言例题）\n\n```cpp\n#include<iostream>\nusing namespace std;\n\n\nint main()\n{\n    \n    int n,i,Sn =0,a=0;\n    cin >> n;  //n代表循环次数\n    \n    for(i=0; i<n; i++){\n    \ta = a*10 +2;   // 0, 2, 22, 222 \n    \tSn += a;\t\t/0+2+22 \n\t}\n\t\n\tcout << Sn;\n\treturn 0;\n}\n```\n\n## 11.求Sn=1!+2!+3!+4!+5!+…+n!之值，其中n是一个数字(n不超过20) 注意使用int类型 当n为19时会溢出 (谭浩强C语言例题）\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nlong long fac(long long n){\n\tlong long i = 1;\n\tlong long sum = 1; \n\twhile(i <=n){\n\t\tsum *=i;    // 1. sum = 1*1 =1\n\t\ti++;\t\t// 2. i =2;\n\t\t\t\t\t// 3. sum = 1*2=2 以此类推 \n\t}\n\treturn sum;\n}\n\nint main()\n{\n\tlong long n,sum=0,a = 0;\n\tcin >> n;\n\t\n\tfor(long long i=n; i>0; i--){\n\t\tsum += fac(i); \n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n```\n\n## 12.求一个3×3矩阵对角线元素之和。 (谭浩强C语言例题）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210116103426548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n```cpp\n#include<iostream>\nusing namespace std;\n\nint main(){\n\t\n\tint a[3][3];\n\tfor(int i=0; i<3; i++)\n\t{\n\t\tfor(int j=0;j<3; j++){\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}  //两个for循环输入二维数组\n\t\n\tint sum1 = 0;\n\tint sum2 = 0;\n\tfor(int i=0; i<3;i++)\n\t{\n\t  sum1 += a[i][i]; //主对角线求和\n\t}\n\t\n\tint j=2;\n\tfor(int i=0;i<3;i++)\n\t { \n\t \t\n\t \tsum2 += a[i][j]; \n\t \t//副对角线求和 注意变量j定义在循环外 不然值不会发生改变\n\t\t//j分别是2 1 0 \n\t\t j--;\n\t \t\n\t }\n\tcout << sum1 << \" \" << sum2;\n\treturn 0;\n} \n```\n\n## 13.用选择法对10个整数从小到大排序。 (谭浩强C语言例题）\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210116105046701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n```cpp\n#include<iostream>\n#define LEN 10\nusing namespace std;\n\nvoid swap(int *a,int *b)  //交换两个数 引用& 或者指针* 均可\n{\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid selection_sort(int arr[], int len)\n{\n    int i,j;\n\n        for (i = 0 ; i < len - 1 ; i++)\n    {\n                int min = i; //默认选择最小值 \n                for (j = i + 1; j < len; j++)    \n                        if (arr[j] < arr[min])    \n                                min = j;    \t\t\n                swap(&arr[min], &arr[i]);    \n                //调用数组元素时 元素前加引用 \n        }\n}\n\nint main(){\n\t\n\tint a[LEN];\n\t\n\tfor(int i=0; i<LEN; i++)\n\t\tcin >> a[i];\n\t\n\tselection_sort(a, LEN);\n\t\n\tfor(int i=0; i<LEN; i++){\n\t\tcout << a[i] << endl;\n\t}\n\treturn 0;\n}\n```\n \n \n## 14.数组插入处理，对一个排好序的数组，按原来的规律插入某数\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210120142711373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n\n```cpp\n#include<iostream>\nusing namespace std;\n\n\nint main(){\n\tint a[5],x;\n\tfor(int i=0; i<5; i++){\n\t\tscanf(\"%d\" ,&a[i]); //输入数组\n\t}\n\t\n\tscanf(\"%d\", &x); //输入待插入元素\n\tfor(int i=0; i<5; i++){\n\t\tif(a[i]<x && a[i+1]>x)  //满足条件模拟“插入” 并输入前后元素 \n\t\tcout << a[i] << \" \" <<x <<\" \";\n\t\telse \n\t\t\tprintf(\"%d \", a[i]); //否则正常输入\n\t}\n\treturn 0;\n} \n```\n## 15.写一个函数，使给定的一个二维数组（３×３）转置，即行列互换。 (谭浩强C语言例题）\n```cpp\n#include<iostream>\n#define N 3 \nusing namespace std;\n\n\nint main(){\n\tint a[N][N];\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tcout << a[j][i] <<\" \"; //行列互换即可\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n} \n```\n\n## 16.自定义函数之字符串反转\n\n```cpp\n#include<iostream>\n#include<cstring>\n#define N 100 \nusing namespace std;\n\n\nint main(){\n\tchar a[N];\n\tcin >> a; \n\t//遇tab、空格、回车都结束 \n\t//适合输入单个字符串且中间不含空格 \n\t//若需输入含空格的字符串 可用gets(str);\n\tint len = strlen(a);\n\t\n\tfor(int i=len-1; i>=0; i--){ \n\t//注意字符数组的最后一个字符是 '\\0'因而从倒数第二个开始\n\t\tprintf(\"%c\", a[i]);\n\t} \n\t\n\treturn 0;\n} \n```\n\n## 17.写一函数，将两个字符串连接\n```cpp\n#include<iostream>\n#include<cstring>\n#define N 100 \nusing namespace std;\n\n\nint main(){\n\n\tchar a[N], b[N];\n\t\n\tcin >> a;\n\tcin >> b;\n\t\n\tint len_a = strlen(a);\n\tint len_b = strlen(b);\n\t\n\tfor(int j = len_a,k=0; j < len_a + len_b; j++,k++ )\n\t{\n\t\ta[j] = b[k]; //后半部分赋新值即可\n\t}\t\n\tcout << a <<endl;\n\t\n\treturn 0;\n} \n```\n\n## 18.写一函数，输入一个四位数字，要求输出这四个数字字符，但每两个数字间空格。如输入1990，应输出\"1 9 9 0\"。 (谭浩强C语言例题）\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<stack>\n#define N 100\nusing namespace std;\n\n\nint main(){\n\t\n\t//1990\t\n\tint a;\n\tstack<int> s; //利用栈stack从个位到最高位 进栈\n\tcin >> a;\n\t\n\twhile(a>0){\n\t\ts.push(a%10);\n\t\ta /= 10;\n\t}\n\n\n\twhile(!s.empty())\n\t{\n\t\tcout << s.top() << \" \"; //根据栈的FILO原则 出栈即可\n\t\ts.pop();\t\n\t}\n\t\n\treturn 0;\n} \n```\n\n## 19.定义一个带参的宏，使两个参数的值互换，并写出程序，输入两个数作为使用宏时的实参。输出已交换后的两个值。\n\n```cpp\n#include<iostream>\n#include<cmath>\n#define exchange(a,b) t=a;a=b;b=t;  //相当于整段代码替换 \n\nusing namespace std;\n\nint main(){\n\tint a, b, t=0;\n\tcin >> a >> b;\n\t\n\texchange(a,b);\n\t\n\tcout << a << \" \" << b <<endl;\n}\n```\n## 20.输入两个整数，求他们相除的余数。用带参的宏来实现，编程序。\n```cpp\n#include<iostream>\n#include<cmath>\n#define MOD(a,b,res) res = a % b;  //相当于整段代码替换 \n\nusing namespace std;\n\nint main(){\n\tint a, b, res=0;\n\tcin >> a >> b;\n\t\n\tMOD(a,b,res);\n\t\n\tcout << res <<endl;\n}\n```\n## 21.输入一行电报文字，将字母变成其下一字母（如’a’变成’b’……’z’变成’ａ’其它字符不变）。\n\n```cpp\n#include<iostream>\n#define N 100\n\nusing namespace std;\n\nint main(){\n\tchar a[N];\n\tgets(a);  //输入字符串\n\t\n\tfor(int i=0; a[i] != '\\0'; i++){\n\t\tif(a[i] >= 'a' && a[i] < 'z'|| a[i] >= 'A' && a[i] < 'Z'){\n\t\t\ta[i] += 1; \n\t\t\t//C++与C一样 字符变量都由ASCII码整数存储\n\t\t\t//因而 相应ASCII码自增1即可\n\t\t}\n\t\t\n\t\tif(a[i]=='z')\n\t\t\ta[i] = 'a';\n\t\t\n\t\tif(a[i]=='Z')\n\t\t\ta[i] = 'A';\n\t}\n\tputs(a); //打印字符串\n\treturn 0; \n}\n```\n## 22.现有N个学生的数据记录，每个记录包括学号、姓名、三科成绩。 编写一个函数input,用来输入一个学生的数据记录。 编写一个函数print,打印一个学生的数据记录。 在主函数调用这两个函数，读取N条记录输入，再按要求输出。 N<100\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210202123009154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n```cpp\n#include<iostream>\n#define N 100\n\n//class:\n//私有属性：学号，姓名，三科成绩\n//公有方法：void input(); void print();\n \nusing namespace std;\nclass Student{ //类名可以不大写，但是推荐大写 符合Java命名规范\n\tpublic:\n\t\tvoid input();\n\t\tvoid print();\n\t\t\n\tprivate:\n\t\tstring num; \n\t\t//字符串类型 涉及到char 跟 int 的组合 \n\t\t//C++中的字符串是string类 Java中是String类\n\t\tstring name;\n\t\tint Chinese;\n\t\tint Math;\n\t\tint English;\n}; //记得有分号； \n\nvoid Student::input(){   //记得域名符:: 表示实现Student类的方法 \n\tcin >> num >> name >> Chinese >> Math >> English; //加上域名符直接引用属性 \n}\n\nvoid Student::print(){\n\tcout << num << \",\" << name << \",\" << Chinese << \",\" << Math << \",\" << English <<endl;\n}\n\nint main(){\n\tint n;\n\tStudent stu[N];\n\t\n\tcin >> n;\n\tfor(int i=0; i<n; i++){\n\t\tstu[i].input();\n\t}\n\t\n\tfor(int i=0; i<n; i++){\n\t\tstu[i].print();\n\t}\n\t\n\treturn 0;\n}\n```\n## 23.将一个字符串str的内容颠倒过来，并输出。str的长度不超过100个字符。\n```cpp\n#include<iostream>\n#include<string>\n#include<cstring>\n#define N 100\nusing namespace std;\n\nint main(){\n\tchar str[N];\n\tgets(str);\n\tint len = strlen(str);\n\t\n\tfor(int i=len-1; i>=0; i--){ \n\t//利用for循环颠倒该数组即可\n\t//由于C++中最后一个字符是'\\0' 因此从倒数第二个字符开始自减\n\t\tcout << str[i];\n\t} \n} \n```\n## 24.解一元二次方程 (谭浩强C语言例题）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210206145605924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n```cpp\n#include<iostream>\n#include<cmath>\n#include<string>\n#include<cstring>\n#define N 100\nusing namespace std;\n\nint main(){\n//\ta*x^2+b*x+c=0 \n\tint a, b, c;\n\tdouble res1, res2;\n\tcin >> a >> b >> c;\n\t\n\tdouble delta = pow(b,2) - 4 * a * c;\n\tif(delta == 0){\n\t\tres1 = (-b + sqrt(delta) ) / 2 * a;\n\t\tres2 = res1;\n\t}else{\n\t\tres1 = (-b + sqrt(delta) ) / 2 * a;\n\t\tres2 = (-b - sqrt(delta) ) / 2 * a;\n\t}\n\t\n\tprintf(\"%.2f %.2f\", res1, res2);\n\treturn 0;\n} \n```\n\n## 25.输入字符串 将组成字符的所有非英文字母的字符删除后输出\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210206151824180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQzNDQ1MDY3,size_16,color_FFFFFF,t_70)\n```cpp\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<string>\n#include<cstring>\n#define N 100\nusing namespace std;\n\nint main(){\n\t//a ASCII是97\n\tchar str[N]; //定义所输入的字符数组\n\tgets(str); \t//输入该数组的数据\n\tint len = strlen(str);\n\t\n\tvector<char> v; //定义vector模板类\n\tfor(int i=0; i<len; i++){\n\t\tif(str[i] < 'A'|| str[i] >'Z'&& str[i] <'a' || str[i]>'z'){  \n\t\t}else{\n\t\t\t//所输入数据是大小写字母时 存入动态数组vector中\n\t\t\tv.push_back(str[i]);\n\t\t}\n\t}\n\t\n\tfor(int i=0; i < v.size(); i++){\n\t\tcout << v[i];\n\t}\n\n\treturn 0;\n} \n```\n\n\n## 谭浩强第四版课后习题答案：\n```cpp\n### 第二章：\n2.4\n#1、以参数形式交换两个数（记得参数加引用）\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\n\nvoid swap(int &a, int &b){ \n//什么时候用引用？ 当需要将操作后的值 传递回去\n\tint t = a;\n\ta = b;\n\tb = t;\n}\n\nint main(){\n\tint num1, num2;\n\tcin >> num1 >> num2;\n\tswap(num1, num2);\n\tcout << num1 << \" \" << num2;\t\n\treturn 0;\n} \n\n#2.依次输入5个值 要求输入其中的最大值\n#include<iostream>\n#include<stdio.h>\n#define L 5\nusing namespace std;\n\n\nint main(){\n\tint a[L],max;\n\tfor(int i=0; i<L; i++){\n\t\tcin >> a[i];\n\t}\n\t\n\tmax = a[0];\n\tfor(int i=1; i<=5; i++){\n\t\tif(max < a[i])\n\t\t\tmax = a[i];\n\t}\n\t\n\tcout << \"Max is:\" << max << endl;\n\treturn 0;\n} \n\n#3.有三个数a,b,c 要求输出最大值\n#include<iostream>\n#include<stdio.h>\n#define L 5\nusing namespace std;\n\n\nint main(){\n\tint num1, num2, num3;\n\tint max;\n\tcin >> num1 >> num2 >> num3;\n\tmax = (num1 > num2)? num1 : num2; //第一个数与第二个数比较 结果是max\n\tmax = (max > num3)? max : num3;\t  //max与第三个数比较 重新赋max的值\n\tcout << max <<endl; \n\treturn 0;\n} \n\n#4.求1+2+3+...+100\n#include<iostream>\n#include<stdio.h> \nusing namespace std;\n\n\nint main(){\n\tint i, sum=0;\n\twhile(i<=100){\n\t\tsum += i;\n\t\ti++;\n\t}\n\t\n\tcout << sum <<endl;\n\t\n\treturn 0;\n} \n\n#5.判断一个数是否同时被3和5整除\n#include<iostream>\n#include<stdio.h> \nusing namespace std;\n\n\nint main(){\n\tint num;\n\tcin >> num;\n\tif(num%3==0 && num%5 ==0){\n\t\tprintf(\"该数%d可以被3和5整除\", num);\n\t}else{\n\t\tprintf(\"不行\");\n\t}\n\t\n\treturn 0;\n} \n\n#6.输出100~200之间的素数\n#include<iostream>\n#include<stdio.h> \nusing namespace std;\n\nbool fac(int x){\n\tbool flag = true;\n\tfor(int i=2; i<x/2; i++){ //注意 对素数的判断 是需要判断2~n/2即可\n\t\tif(x%i==0){\n\t\t\tflag = false;\n\t\t}\n\t}\n\treturn flag;\n}\n\nint main(){\n\tfor(int i=100; i<=200; i++)\n\t{\n\t\tif(fac(i) == true)\n\t\t{\n\t\t\tprintf(\"%d是素数\\n\", i);\n\t\t}\n\t}\n\treturn 0;\n} \n\n#7 求两个数的最大公约数\n#include<iostream>\n#include<stdio.h> \nusing namespace std;\n\nvoid fun(int a, int b){ //传参进来a大于b \n\tint c = a%b; \n\t//辗转相除法 若余数为0 则小者为最大公约数\n\t\n\twhile(c != 0){ //如果余数不为0 \n\t\ta = b; //否则将余数作为除数  \n\t\tb = c; //小者作为被除数\n\t\tc = a % b;\t\t\n\t}\n\tcout << b <<\"是最大公约数\" << endl;\n}\n\nvoid swap(int &a, int &b){\n\tint t = a;\n\ta = b;\n\tb = t;\n}\n\nint main(){\n\tint num1, num2;\n\tcin >> num1 >> num2;\n\tif(num1 < num2)\n\t\tswap(num1, num2); //对大小相反做处理 交换即可\n\tfun(num1, num2);\t\n\treturn 0;\n} \n\n#8. 求一元二次方程的根 \n#include<iostream>\n#include<cmath>\n#include<stdio.h> \nusing namespace std;\n\n\nint main(){\n\t//ax^2 + bx + c\n\tdouble a, b, c;\n\tcin >> a >> b >> c;\n\tdouble delt = pow(b,2) - 4 * a * c;\n\tdouble x1 = (-b+sqrt(delt))/(2*a);\n\tdouble x2 = (-b-sqrt(delt))/(2*a);\n\t\t\n\tif(delt > 0){\n\t\tcout << \"实根分别为：\" << x1 << \" \" << x2 <<endl;\n\t}else{\n\t\tif(delt == 0){\n\t\t\tcout << \"实根为:\" << x1 << endl;\t\t\t\n\t\t}else{\n\t\t\tcout << \"无实根\" << endl; \n\t\t}\n\t}\n\n\treturn 0;\n} \n```\n## 第三章\n\n```cpp\n\n\n第三章：\n#3-5：\n\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\n\nint main(){\n\n\tint a,b;\n\tfloat x;\n\tdouble y;\n\tchar c1, c2;\n\tprintf(\"input the Integer a,b:\\n\");\n\tscanf(\"%d %d\",&a, &b);\n\n\tprintf(\"input the Float x:\\n\");\n\tscanf(\"%f\",&x);\n\t\n\tprintf(\"input the Double y:\\n\");\n\tscanf(\"%lf\",&y);\n\n\tprintf(\"input the char c1:\\n\");\n\tc1 = getchar();\n\t\n\tprintf(\"input the char c2:\\n\");\n\tc2 = getchar();\n\n\tprintf(\"%d,%d,%.2f,%.2lf,%c,%c\",a,b,x,y,c1,c2);\n\treturn 0;\n}\n\n#3.6加密 将China译成密码 利用char字符在计算机中存储ASCII码值 每个字符相加四个单位即可\n#include<iostream>\n#include<stdio.h>\nusing namespace std;\n\nint main(){\n\tchar c1,c2,c3,c4,c5;\n\tc1 = 'C';\n\tc2 = 'h';\n\tc3 = 'i';\n\tc4 = 'n';\n\tc5 = 'a';\n\n\tc1+=4;\n\tc2+=4;\n\tc3+=4;\n\tc4+=4;\n\tc5+=4;\n\n\tputchar(c1);\n\tputchar(c2);\n\tputchar(c3);\n\tputchar(c4);\n\tputchar(c5);\n\n\tprintf(\"\\n\");\n\t\n\tprintf(\"%c%c%c%c%c\",c1,c2,c3,c4,c5);\n\n\treturn 0;\n}\n```\n\n## 第五章\n```cpp\n第五章：\n5.3 求最大公约数与最小公倍数\n\n5.3.1:最大公约数：\n#include<stdio.h>\n#include<iostream> \n#include<stack>\n#define N 100\nusing namespace std;\n\nint main(){\n\t//求a b两个数字的最大公约数 （辗转相除法） \n\tint a, b, res = 0;\n\tcin >> a >> b;\n\tif(a < b) //默认a>b\n\t{\n\t\tint t = a;\n\t\ta = b;\n\t\tb = t;\n\t} \n\t\n\tif(a % b == 0){  //如果a是b的倍数 那么最大公因数就是b \n\t\tres = b; \n\t}else{\n\t\tint c = a % b;\t//否则先取余 余数在else语句中肯定是不为0的 \n\t\twhile(c != 0){\t//若若满足不为0 则较小数作为a 余数作为b c重新被a b取余 \n\t\t\ta = b; \n\t\t\tb = c;\n\t\t\tc = a % b;\n\t\t}\n\t\t\n\t\tres = b;\n\t}\n\tcout << res;\n\treturn 0;\n}\n\n5.3.2：最小公倍数：\n#include<stdio.h>\n#include<iostream> \n#include<stack>\n#define N 100\nusing namespace std;\n\nint main(){\n\t//求a b两个数字的最小公倍数\n\tint a,b,res=0;\n\t\n\tcin >> a >> b;\n\tif(a < b){ //默认a大于b \n\t\tint t = a;\n\t\ta = b;\n\t\tb = t;\n\t}\n\t\n\tif(a % b == 0){ //如果a是b的倍数 那么最小公倍数就是a \n\t\tres = a; \n\t}else{\n\t\tint temp=b;\n\t\twhile(temp<=a*b){ //直到temp变成a*b \n\t\t\tif(temp%a==0&&temp%b==0){ //如果从较小数开始 一直自增 如果能同时取余两个数 那么就是公倍数 \n\t\t\t\tres = temp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttemp++;\n\t\t}\n\t}\n\t\n\tcout << res <<endl;\n\treturn 0;\n}\n\n5.8 输出所有水仙花数(三位数，且各数的立方和等于该数本身)：\n#include<stdio.h>\n#include<vector>\n#include<cmath>\n#include<iostream> \n#include<stack>\n#define N 100\nusing namespace std;\nbool isNum(int num){\n\tint sum = 0;\n\tvector<int> v(1, num);\n\tvector<int>::iterator it;\n\tbool flag = false;\n\t\n\twhile(num){\n\t\tv.push_back(num%10);\n\t\tnum /= 10;\n\t} \n\t\n\tfor(it=v.begin()+1; it != v.end(); it++){\n\t\tsum += (pow(*it, 3));\n\t}\n\t\n\t\n\tif(sum == v[0]){\n\t\tflag = true;\n\t}\t\n\t\n\treturn flag;\n} \n\nint main(){\n\t//求所有的水仙花 \n\tint num;\n\tfor(int i =100; i<1000; i++){\n\t\tif(isNum(i)){\n\t\t\tcout << i << \" \";\n\t\t}\t\n\t}\n\t\n\treturn 0;\n}\n\n5.9求1000之内的所有完数\n#include<stdio.h>\n#include<vector>\n#include<cmath>\n#include<iostream> \n#include<stack>\n#define N 100\nusing namespace std;\n\nvoid getNum(int num){\n\tint sum=0; \n\tvector<int> v(1, num);\n\tvector<int>::iterator it;\n\t\n\tfor(int i=1; i<num; i++){ //千万注意 取余的两边绝对！绝对不能为0 因此i不能是0 \n\t\tif(num%i==0)\n\t\t\tv.push_back(i);\n\t}\n\t\n\tfor(it=v.begin()+1; it!=v.end(); it++){\n\t\tsum += (*it);\n\t}\n\t\n\tif(sum == v[0]){\n\t\tcout << sum << \"是完数\" << endl;\n\t}\n\tv.clear();\n}\n\nint main(){\n\t//求完数 即一个数等于它所有的因子之和\n\tint num,end = 1000;\n\twhile(num++ < end){\n\t\tgetNum(num);\n\t}\n\treturn 0;\n}\n\n5.10：求 2/1 + 3/2 + 5/3 +... 数列的前20项和\n\n#include<stdio.h>\n#include<vector>\n#include<cmath>\n#include<iostream> \n#include<stack>\n#define N 100\nusing namespace std;\n\n\nint main(){\n\tdouble up=2, down=1,res = 0; //up代表分母 down代表分子 \n\tint i=0;\n\twhile(i++<20){\n\t\tres += (up/down);\n\t\tup = up + down;\n\t\tdown = up - down; //注意 这里不能用down = up  因为up 已经是 up+down \n\t\t\t\t\t\t  //而应该是新的up减去之前的down \n\t}\n\t\n\tcout << res;\n\treturn 0;\n}\n\n5.11: 一个球从100M高度落下 每次落地反弹回原高度的一般 再落下...求第10次 共经过多少米 反弹多高？\n#include <stdio.h>\nmain()\n{\nfloat height=100.0,sum_height=100;\nint i;\nfor(i=1;i<10;i++) {\n\theight=height/2;\n\tsum_height+=height*2;\n}\nprintf(\"%fm\\n\",sum_height);\nprintf(\"%fm\\n\",height);\nreturn 0;\n}\n```\n\n## 第六章：\n\n```cpp\n第六章：\n\t例题：输入字符串 从中打印出单词的个数\n\n#include <stdio.h>\n#include<iostream>\n#include<vector>\n#include<stack>\n#define N 100 \nusing namespace std;\n\n \nmain()\n{\n\tchar str[N];\n\tint num,word=0;\n\tgets(str);\n\t\n\tfor(int i=0; str[i]!='\\0'; i++){\n\t\tif(str[i] == ' '){ //如果一开始就是空格 那么不是单词 \n\t\t\tword = 0;\n\t\t}else if(word==0){\t//空格之后 认为是单词 记为遇到1个 \n\t\t\tword = 1;\n\t\t\tnum++;\n\t\t}\n\t}\n\t\n\tcout << num <<endl; \n\treturn 0;\n}\n\n6.5：逆序存放升序的数组 比如处理前：1 2 3 4 5 存放后为：5 4 3 2 1 \n#include <stdio.h>\n#include<iostream>\n#include<vector>\n#include<stack>\n#define N 100 \nusing namespace std;\n\n \nmain()\n{\n\tint arr[N],len;\n\tstack<int> s;\n\t\n\tcin >> len;\n\tfor(int i=0; i<len; i++)\n\t{\n\t\tcin >> arr[i];\n\t\ts.push(arr[i]);  //利用栈的FILO原理 从头到尾将元素进行入栈\n\t}\n\t\n\tcout << \"处理前的数组元素分别为：\" <<endl;\n\tfor(int i =0; i<len; i++)\n\t\tcout << arr[i] << \" \"; \t\t\n\t\n\tcout << endl;\n\t\n\tfor(int i=0; i<len; i++){\n\t\tarr[i] = s.top();\n\t\ts.pop();\n\t}\t\n\t\n\tcout << \"处理后的数组元素分别为：\" <<endl;\n\tfor(int i =0; i<len; i++)\n\t\tcout << arr[i] << \" \"; \t\t\n\n\treturn 0;\n}\n```\n\n```cpp\n6.9：\n有若干个数字在有序数组中 此时要求实现折半查找方式来查找某个元素\n并给出它的位置 若找不到该数 则输出 无此数\n#include <stdio.h>\n#include<iostream>\n#include<vector>\n#include<stack>\n#define N 100 \nusing namespace std;\n\n \nint main()\n{\n\tint a[6] = {1, 4, 6, 32, 58, 66};\n\tint left = 0;\n\tint right = 5; //注意是最后一个元素 即 长度-1\n\tint mid,num;\n\tcout << \"输入欲查找的数字：\" <<endl;\n\tcin >> num;\n\twhile(left <= right){ //注意条件\n\t\tmid = (left + right) / 2;\n\t\tif(a[mid] == num){\n\t\t\tcout << \"已找到，是第\" << mid+1 << \"个元素\" <<endl;\n\t\t\tbreak;\n\t\t}else if(a[mid] < num){ \n\t\t\tleft = mid + 1;\n\t\t}else{\n\t\t\tright = mid - 1;\n\t\t}\n\t}\n\t\n\tif(left > right){\n\t\tcout << \"无此数\" <<endl;\n\t}\n\treturn 0;\n}\n\n统计各字符\n#include <stdio.h>\n#include<iostream>\n#include<vector>\n#include<stack>\n#define N 100 \nusing namespace std;\n\n \nint main()\n{\n\tchar str[2][10];\n\tfor(int i =0; i<2; i++)\n\t\tgets(str[i]);      //for循环每次输入该行\n\n\tcout << endl;\n\t\n\t//统计大写字母 小写字母 数字 空格以及其他字符 \n\t\n\tint num=0, U_char=0, L_char=0, space=0, oth=0;\n\t\n\tfor(int i =0; i<2; i++) {\n\t\tfor(int j=0; j<10; j++){\n\t\t\tchar ch= str[i][j];\n\t\t\tif(ch >= '0' && ch <= '9' ){\n\t\t\t\tnum++;\t\t\t\t\n\t\t\t}else if(ch >= 'A' && ch <= 'Z'){\n\t\t\t\tU_char++;\n\t\t\t}else if(ch >= 'a' && ch <= 'z'){\n\t\t\t\tL_char++;\n\t\t\t}else if(ch == ' '){\n\t\t\t\tspace++;\n\t\t\t}else{\n\t\t\t\toth++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << \"数字：\" << num<<endl;\n\tcout << \"大写字母：\" << U_char <<endl;\n\tcout << \"小写字母:\" << L_char << endl;\n\tcout << \"空格：\" <<space <<endl;\n\tcout << \"其他：\" << oth <<endl;\n\n\treturn 0;\n}\n\n6.14\n比较两个字符串 其中返回正数 该正数表示相差的总值\n#include <stdio.h>\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<stack>\n#define N 100 \nusing namespace std;\n\n \nint main()\n{\n\t//两个字符串的比较 返回总相差的ASCII码值\n\tchar c1[N], c2[N];\n\tint len1, len2;\n\tint sum=0;\n\tcout << \"请输入字符串一：\" <<endl;\n\tgets(c1);\n\tlen1 = strlen(c1);\n\t\n\tcout << \"请输入字符串二：\" <<endl;\n\tgets(c2);\n\tlen2 = strlen(c2);\n\tint len = (len1>len2)? len1: len2;\n\tfor(int i=0; i<len; i++){\n\t   sum += abs(c1[i]-c2[i]);\n\t}\n\t \n\tcout << \"两者相差：\" << sum <<endl;\n\treturn 0;\n}\n\n6.15 将字符数组a2的所有字符都复制到a1中去 其中包括a2的结束字符'\\0'\n#include <stdio.h>\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<stack>\n#define N 100 \nusing namespace std;\n\n \nint main()\n{\n\t//两个字符串的比较 返回总相差的ASCII码值\n\tchar c1[N], c2[N]={'v','i','n','c','\\0'};\n\tint len1, len2;\n\tcout << \"请输入字符串一：\" <<endl;\n\tgets(c1);\n\tlen1 = strlen(c1);\n\t\n\tcout << \"请输入字符串二：\" <<endl;\n\n\tlen2 = strlen(c2)+1;\n\t\n\tfor(int k = len1,i=0; k<len1+len2; k++,i++){\n\t\tc1[k] = c2[i];\n\t}\n\t\n\tfor(int k = 0; k<len1+len2; k++){\n\t\tprintf(\"%c它的ASCII值为%d\\n\", c1[k],c1[k]);\n\t}\n\t\n\treturn 0;\n}\n```\n\n## 第七章：\n```cpp\n\n7.10：写一个函数，输入一行字符，将最长的单词输出：\n【转】：https://blog.csdn.net/navicheung/article/details/77990479\n\n#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<vector>\n#include<stack>\n#define N 100 \nusing namespace std;\n\n//最长单词函数\nvoid getLongWord(char str[])\n{\n    int max_length=0, len=0;\n    char temp[N], res[N];\n    int n = strlen(str);\n    \n    for (int i=0; i<=n; i++){\n    \t\n\t\t//如果字符是单词的一部分 加入到temp数组 \n        if ((str[i]>='a'&&str[i]<='z')||(str[i]>='A'&&str[i]<='Z')) \n            temp[len++]=str[i];\n        else{\n            //若不是单词 那么temp数组不再增添元素 而是结束 \n\t\t\ttemp[len]='\\0';\n            \n            //如果每次长度有更长的 更新 且记得len重新赋值为0 以下一次判断 \n\t\t\t//最终的结果存入ma数组中 关键语句 \n            len>max_length ? max_length=len, strcpy(res, temp), len=0 : len=0; \n        }\n    }\n    \n    printf(\"最长的单词是： \");\n    puts(res);\n}\n\nint main()\n{\n    char str[N];\n    printf(\"请输入字符串：\\n \");       //输入一行字符\n    gets(str);\n    \n    getLongWord(str);                         //调用最长单词函数\n    \n    return 0;\n}\n\n7.11 利用起泡法对输入的n个字符进行升序排序：\n#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<vector>\n#include<stack>\n#define N 100 \nusing namespace std;\n\nvoid swap(char &a, char &b){\n\tchar t = a;\n\ta = b;\n\tb = t;\n}\n\nint main()\n{\n    char str[N];\n   \tint length;\n\t\n\tcout << \"你要输入几个字符：\" <<endl;\n\tcin >> length;\n\t\n\tcout << \"依次输入这些字符：\" <<endl;\n\tfor(int i=0; i<length; i++){\n\t\tcin >> str[i];\n\t}\n\t \n\tfor(int i=0; i<length; i++){\n\t\tfor(int j=0; j<length-i-1; j++){\n\t\t\tif(str[j] > str[j+1]){\n\t\t\t\tswap(str[j], str[j+1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << \"起泡法排序结果：\" <<endl;\n\tfor(int i=0; i<length; i++)\n\t\tcout << str[i] << \" \";\n    return 0;\n}\n\n7.16 输入一个十六进制数字（字符串的形式），输出相应的十进制数字：\n#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<vector>\n#include<stack>\n#define N 100 \nusing namespace std;\n\n//十六进制数转换为十进制数\n//相应的位置 按权展开即可\n//A2 = A*10^1 + 2*10^0 \nint fun(char str[]){\n\t\n\tint n = strlen(str); //n代表字符串的长度 即代表十六进制数是n位数 \n\tint sum =0;\n\t\n\tfor(int i=n-1,j=0; i>=0; i--){\n\t\tint temp = 0;\n\t\tif(str[i]=='A'){\n\t\t\ttemp = 10;\n\t\t}else if(str[i]=='B'){\n\t\t\ttemp = 11;\n\t\t}else if(str[i]=='C'){\n\t\t\ttemp = 12;\n\t\t}else if(str[i]=='D'){\n\t\t\ttemp = 13;\n\t\t}else if(str[i]=='E'){\n\t\t\ttemp = 14;\n\t\t}else if(str[i]=='F'){\n\t\t\ttemp = 15;\n\t\t}else{\n\t\t\ttemp = str[i] - '0';\n\t\t}\n\t\tsum += (temp * pow(16, j++));\n\t}\n\treturn sum;\n}\n\nint main()\n{\n    char str[N];\n    gets(str);\n    \n    cout << \"十进制数是：\" <<endl;\n\tcout << fun(str) <<endl;\n    \n    return 0;\n}\n\n7.17 递归法 将一个整数转换为字符串\n#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<vector>\n#include<stack>\n#define N 100 \nusing namespace std;\n\n//将一个整数 转换成字符串 \n\nvoid fun(int n){\n\tchar ch; //每次输出的字符 \n\t\n\t//1.递归的第一步 首先想好边界情况 这里每次i位数每次取i-1 直到结果为0 \n\tif(n==0){  \n\t\treturn;\t\n\t}else{\t\t\n\t//2.否则 执行每一次的操作具体的行为\n\t//注意这里fun一直到边界才输出！因此结果是12（假如n=12）\n\t//如果fun放在末尾 那么会先输出数字 因而结果会是21 \n\t\tfun(n/10);\n\t\tprintf(\"%c\", (n%10) + '0');   \t\t\t\t\n\t}\n}\n\nint main()\n{\n\tint num =0;\n\tcin >> num;\n\t\n\tfun(num);\n\t\n    return 0;\n}\n\n6.18：给出年、月、日 计算是该年的第几天\n\n#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<vector>\n#include<stack>\n#define N 100 \nusing namespace std;\n\nbool isLeapYear(int year){\n\tbool flag = false;\n\tif( year%400==0 || (year%4==0&&year%100!=0) ){  \n\t//1.被400整除的年份是闰年\n\t//2.被4整除同时不能被100所整除的年份是闰年 \n\t\tflag = true;\n\t}\n\treturn flag;\t\n}\n\n//输入某年某月某日 判断这是该年中的第几天\nvoid fun(int year, int month, int day){\n\tint months[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; //非闰年的各月份天数数组 \n\tint days_sum = 0,i=0; \n\t\n\tif(month<2){ //如果没到2月 则不用计算是不是闰年 \n\t\tdays_sum = day;\n\t\tcout << \"该日期是第\" << days_sum << \"天\" <<endl; \n\t}else{\n\t\tif(isLeapYear(year)){\n\t\t\tmonths[1] = 29; //闰年2月有29天 \n\t\t}\n\t\t\n\t\twhile(i<month-1){ //计算该月之前有多少天\n\t\t\tdays_sum += months[i];\n\t\t\ti++;\n\t\t}\n\t\t//然后该月第几天加上去\n\t\tcout << \"该日期是第\" << days_sum+day << \"天\" <<endl; \n\t}\n\t\n}\n\nint main()\n{\n\tint year, month, day;\n\tcout << \"输入年份：\" <<endl;\n\tcin >> year;\n\t\n\tcout << \"输入月：\" <<endl;\n\tcin >> month;\n\t\n\tcout << \"输入日：\" << endl;\n\tcin >> day;\n\t\n\t//可以添加判断日期是否合法的函数... 现假设合法 正确输入格式 \n\t\n\tfun(year, month, day);\n    return 0;\n}\n\n\n```\n","tags":["C语言"],"categories":["经典C++算法"]},{"title":"C/C++力扣LeetCode转载","url":"/2021/03/11/C_C++力扣LeetCode转载/","content":"\n\n## 27.原地移出某数后的数组\n**给你一个数组 nums 和一个值 val**，你**需要 原地 移除所有数值等于 val 的元素**，**并返回移除后数组的新长度**。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n \n示例 1：\n\n输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n解释：**函数应该返回新的长度 2**, **并且 nums 中的前两个元素均为 2**。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n示例 2：\n\n输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,4,0,3]\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/remove-element\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        if(nums.size() == 0) return 0;\n        //一个指针指向头 一个指向尾部\n        int i = 0, index = nums.size()-1;\n        while(i <= index) \n        {\n\t\t\t//如果当前是要删除的值\n            if(nums[i] == val)\n            {\n           \t \t//将该数字与最后一个数字交换\n            \t//同时数组缩减\n                int temp = nums[index];\n                nums[index] = nums[i];\n                nums[i] = temp;\n                --index;\n            }\n            \t//如果不是要删除的值 继续往后推进\n            else\n                ++i;\n        }\n        return i;\n    }\n\n};\n```\n\n作者：Xiaohu9527\n链接：https://leetcode-cn.com/problems/remove-element/solution/cyi-ci-li-bian-bu-xu-yao-bao-li-gan-jue-82cz7/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n## 58.返回最后一个单词的长度\n**给你一个字符串 s，由若干单词组成，单词之间用空格隔开。****返回字符串中最后一个单词的长度。****如果不存在**最后一个单词，**请返回 0** 。**（注意本题最后 可能出现连续的空格）**单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n\n示例 1：\n\n输入：s = \"Hello World\"\n输出：5\n示例 2：\n\n输入：s = \" \"\n输出：0\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/length-of-last-word\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n</p>\n\n```cpp\nint lengthOfLastWord(string s) {\n        int count = 0, end = s.size()-1;\n        //直到最后一个变成第一个\n        //未遇到第一个字母前 若有连续的空格 直接跳过\n        while(end >= 0 && s[end] == ' ')  \n\t\t\t--end;\n\t\t//如果没有遇到最后一个字母前的空格 就count++ 且每次指针 end--\n        while(end >= 0 && s[end--] != ' ')\n            ++count ;\n        return count;\n    }\n```\n\n## 动态规划实现斐波那契数列\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。\n\n示例 1：\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n\n示例 2：\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/climbing-stairs\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n</p>\n\n```cpp\n//一定看懂本题的动态规划\n//利用dp[i]将可能用到的值存起来 return dp[n]\nint climbStairs(int n) {\n\t\tvector<int> dp(n+3, 0);  //元素个数为n+3 默认为0\n\t\tdp[0] = 0;\n\t\tdp[1] = 1;\n\t\tdp[2] = 2;\n\t\t\n\t\t//用数组把值存储起来 如果下次需要 直接调用相应的数组值即可 \n\t\tfor(int i=3; i<=n; i++){\n\t\t\tdp[i] = dp[i-1] + dp[i-2];\n\t\t}\n\t\treturn dp[n];\n    }\n   \n```\n\n## 合并有序数组使其有序\n给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 （本来都有序，想要合并之后仍有序）初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。\n\n \n\n示例 1：\n输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n输出：[1,2,2,3,5,6]\n\n示例 2：\n输入：nums1 = [1], m = 1, nums2 = [], n = 0\n输出：[1]\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/merge-sorted-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n\n```cpp\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    \t//从将nums2的全部内容 排在nums1的数组后面\n\t\tfor(int k=m,j=0; k<m+n; k++,j++){\n        \tnums1[k] = nums2[j];\n\t\t}\n\t\t//整体对nums1第一个元素 以及加进来之后的最后一个元素进行排序即可 注意排序的长度是容纳n1 n2的长度之和\n\t\tsort(nums1.begin(), nums1.begin()+(m+n));\n\t\t \n    }\n};\n```\n\n## 找到值的索引 或者理应插入的位置\n**给定一个排序数组和一个目标值**，在**数组中找到目标值，并返回其索引**。**如果目标值不存在于数组中，返回它将会被按顺序插入的位置。**你可以假设数组中无重复元素。\n\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/search-insert-position\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n\t\tint pos = 0;\n\t\tint end = nums.size();\n\t\t\n        //处理特殊情况 当小于第一个或者大于最后一个时\n\t\tif(target < nums[0]){\n\t\t\treturn pos;\n\t\t}\n\t\t\n\t\tif(target > nums[end-1]){\n\t\t\tpos = end;\n\t\t\treturn pos;\n\t\t}\n\t\t\n\t\t\n        //如果中间有 那么返回该位置\n\t\tfor(int i=0; i<end; i++){\n\t\t\tif(target == nums[i]){\n\t\t\t\tpos = i;\n\t\t\t\treturn pos;\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t//如果下一个比它大 则返回下一个位置\n\t\tfor(int i=0; i<end; i++){\n\t\t\tif(target >nums[i] && target < nums[i+1]){\n\t\t\t\tpos = i+1;\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t\treturn pos;\n    }\n};\n```\n\n## 121. 买卖股票的最佳时机\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n**示例 1：**\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n\t \n**示例 2：**\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n\t\tint profit=0, minValue=prices[0]; //假设第一个是最小值\n\t\tfor(int i=1; i<prices.size(); i++){ //从第二个到最后一个开始 \n\t\t\tminValue = min(minValue, prices[i]); //每次比较minValue与当前值的最小值 \n\t\t\tprofit = max(profit, prices[i]-minValue); //利润就是当前值减去最小值的最大差值 \n\t\t} \n\t\treturn profit;\n\t}\n};\n```\n\n## 202. 快乐数\n编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」定义为：\n对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\n如果 可以变为  1，那么这个数就是快乐数。\n如果 n 是快乐数就返回 true ；不是，则返回 false 。\n\n\n**示例 1：**\n输入：19\n输出：true\n解释：\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\n**示例 2：**\n输入：n = 2\n输出：false\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/happy-number\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n```cpp\nclass Solution {\npublic:\n    //拿到相应的各数之和函数\n    int getNum(int n){\n\t\tint sum=0;\n\t\twhile(n){\n\t\t\tsum += (pow(n%10, 2));\n\t\t\tn /= 10;\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tbool isHappy(int n) {\n\t\tset<int> s; \n        //定义一个集合 因为如果结果不为1 相加一定有重复的数字\n\t\t\n\t\twhile(1){     //一直循环\n\t\t\t\n\t\t\tint sum = getNum(n);\n            //每次将结果放入集合之前 先判断集合是否已经存在该元素\n\n        \t//如果已经出现了 说明结果肯定不会等于1\n            if(s.count(sum) == 1){\n\t\t\t\treturn false;\n\t\t\t}\n\n            //如果没有重复 则加入\n\t\t\ts.insert(sum);\n\t\t\t\n            //如果结果等于1 则返回true\n            if(sum == 1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t//对每一次得到的sum重复计算！\n            n = sum;\t\n\t\t}\n    }\n};\n```\n\n## 136. 只出现一次的数字\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n**示例 1:**\n输入: [2,2,1]\n输出: 1\n\n**示例 2:**\n输入: [4,1,2,1,2]\n输出: 4\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n           set<int> s;\n           int res = 0;\n           for(int i=0; i<nums.size(); i++){\n           \t\tif(s.count(nums[i]) == 1){ //如果集合中有这个元素 那么删除它\n           \t\t\ts.erase(nums[i]);\n\t\t\t\t}else{//如果集合中没有这个元素 就添加进去\n\t\t\t\t\ts.insert(nums[i]);\n\t\t\t\t}\n\t\t   }\n\t\t   set<int>::iterator it; \n\t\t   for(it=s.begin();it != s.end(); it++){\n\t\t   \t\tres = *it;//最后剩余的元素 一定是不重复的元素\n\t\t   }\n           return res;\n    }\n};\n```\n## 204. 计数质数\n统计所有小于非负整数 n 的质数的数量。\n\n示例 1：\n输入：n = 10\n输出：4\n解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n\n示例 2：\n输入：n = 0\n输出：0\n\n示例 3：\n输入：n = 1\n输出：0\n\n```cpp\nclass Solution {\npublic:\n    bool isPrime(int x) {\n\t\t//在0~根号x的范围内 即可判断是否是质数\n        for (int i = 2; i * i <= x; ++i) {  \n            if (x % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\t\n\t//在C++中 true的数字代表1 多少个true相加\n\t//就代表有多少个质数 从2~n-1判断即可\n    int countPrimes(int n) {\n        int ans = 0;\n        for (int i = 2; i < n; ++i) {\n            ans += isPrime(i);\n        }\n        return ans;\n    }\n};\n```\n\n## 217. 存在重复元素\n\n给定一个整数数组，判断是否存在重复元素。\n\n如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。\n\n示例 1:\n输入: [1,2,3,1]\n输出: true\n\n示例 2:\n输入: [1,2,3,4]\n输出: false\n\n示例 3:\n输入: [1,1,1,3,3,4,3,2,4,2]\n输出: true\n\n```cpp\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n\t\tset<int> s;\n\t\t\n\t\tfor(int i=0; i<nums.size(); i++){\n\t\t\t\n\t\t\t//如果集合中存在重复元素 直接return真\n\t\t\tif(s.count(nums[i])  == 1){ \n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\t//否则持续向集合中 添加数组中的元素\n\t\t\ts.insert(nums[i]);\n\t\t}\n\t\treturn false;\n    }\n};\n```\n\n## 258. 各位相加\n给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。\n\n示例:\n输入: 38\n输出: 2 \n解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。\n\n```cpp\nclass Solution {\npublic:\n\t//计算各数之和的方法\n    int getNum(int num){\n\t\tint res = 0;\n\t\twhile(num){\n\t\t\tres += num%10;\n\t\t\tnum /= 10;\n\t\t}\n\t\treturn res;\t\n\t}\n\t\n\tint addDigits(int num) {\n\t\tint res = 0;\n\t\t//不到跳出循环的条件不罢休\n\t\twhile(1){\n\t\t\t//算出num的各数之和\n\t\t\tres = getNum(num); \n\t\t\t//直到算到个数之和小于10\n\t\t\tif(res<10){\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t//下一次计算新结果的个数之和\n\t\t\tnum = res;\n\t\t}\n    }\n};\n```\n\n## 28.实现 strStr()\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。\n\n**示例 1:**\n输入: haystack = \"hello\", needle = \"ll\"\n输出: 2\n\n**示例 2:**\n输入: haystack = \"aaaaa\", needle = \"bba\"\n输出: -1\n\n当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/implement-strstr\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n```cpp\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int pos = 0;\n\t\t//如果是空字符串 返回0\n        if(needle == \" \"){ \n            return pos;\n        }else{\n\t\t\t//如果不为空 则找到对应的位置\n            pos = haystack.find(needle);\n\t\t\t//如果找得到 返回位置\n            if( pos != string::npos){\n                return pos;\n            }\n        }\n\t\t//如果找不到 就返回-1\n        return -1;\n    }\n};\n```\n\n## 83. 删除排序链表中的重复元素\n给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。\n\n**示例 1:**\n输入: 1->1->2\n输出: 1->2\n\n**示例 2:**\n输入: 1->1->2->3->3\n输出: 1->2->3\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n\t\tListNode* cur = head;\n\t\twhile(cur != NULL && cur->next != NULL){\n\t\t\tif(cur->val == cur->next->val){\n\t\t\t\tcur->next = cur->next->next;\n\t\t\t}else{\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\t\t}\n\t\treturn head;\n    }\n};\n```\n\n## 344. 反转字符串\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n\n你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。\n\n**示例 1：**\n输入：[\"h\",\"e\",\"l\",\"l\",\"o\"]\n输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n\n**示例 2：**\n输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/reverse-string\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n```cpp\nclass Solution {\npublic:\n    void reverseString(vector<char>& s) {\n        //给俩指针 一个指针指向第一个元素\n\t\t//再给一个指针给最后一个元素\n\t\tint i = 0; \n        int end = s.size()-1;\n\t\t//直到俩指针相遇\n        while(i<=end){\n\t\t\t//交换首尾元素\n            char temp = s[i];\n            s[i] = s[end];\n            s[end] = temp;\n\t\t\t\n            i++;\n            end--;\n        }\n    }\n};\n```\n\n## 383. 赎金信\n\n给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。\n如果可以构成，返回 true ；否则返回 false。\n(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)\n\n**示例 1：**\n输入：ransomNote = \"a\", magazine = \"b\"\n输出：false\n\n**示例 2：**\n输入：ransomNote = \"aa\", magazine = \"ab\"\n输出：false\n\n**示例 3：**\n输入：ransomNote = \"aa\", magazine = \"aab\"\n输出：true\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/ransom-note\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n```cpp\nclass Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n\t\tint count = 0; //count用来标记r串中 可以找到的个数 \n\t\tint r_i = 0;\n\t\tint r_len = ransomNote.size();\n\t\tint m_end = magazine.size();\n\t\t\n\t\t//从ran字符串中 一个一个判断\n\t\twhile(r_i < r_len){\n\t\t\tint pos = magazine.find(ransomNote[r_i]);\n\t\t\tif( pos != string::npos){\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\t//从mag中原地删除字符 \n\t\t\t\tint temp = magazine[pos];\n\t\t\t\tmagazine[pos] = magazine[m_end-1];\n\t\t\t\tmagazine[m_end-1] = temp;\n\t\t\t\t\n\t\t\t\t//删除最后一个字符\n\t\t\t\tmagazine.erase(m_end-1);\n\t\t\t}\n\t\t\tr_i++;\n\t\t}\n\t\t//如果都可以找到 就代表true \n\t\tif(count == ransomNote.size()){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n};\n```\n\n## 387. 字符串中的第一个唯一字符\n\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\n\n**示例：**\ns = \"leetcode\"\n返回 0\n\ns = \"loveleetcode\"\n返回 2\n\n**提示：你可以假定该字符串只包含小写字母。**\n\n```cpp\nclass Solution {\npublic:\n    int firstUniqChar(string s) {\n        \n        unordered_map<char, int> frequency;\n        \n\t\t//将字符串中的每个字符 遇到一个自增\n        for (char ch: s) {\n            ++frequency[ch];\n        }\n\n\t\t//从头到尾 输出第一个频度为1的\n        for (int i = 0; i < s.size(); ++i) {\n            if (frequency[s[i]] == 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n## 268. 丢失的数字\n给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。\n\n**示例 1：**\n输入：nums = [3,0,1]\n输出：2\n解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n\n**示例 2：**\n输入：nums = [0,1]\n输出：2\n解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n\n**示例 3：**\n输入：nums = [9,6,4,2,3,5,7,0,1]\n输出：8\n解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。\n\n**示例 4：**\n输入：nums = [0]\n输出：1\n解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。\n\n**提示：**\nn == nums.length\n1 <= n <= 104\n0 <= nums[i] <= n\nnums 中的所有数字都 独一无二\n\n```cpp\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n\t\t//首先从小到大进行排序\n\t\tsort(nums.begin(), nums.end()); \n        int n = nums.size();\n        for(int i=0; i<nums.size();i++){\n\t\t\t//如果n在数组当中 从小到大一次判断哪个数不在数组中\n            if(nums[i] != i){\n                return i;\n            }\n        }\n\t\t//否则没有找到 那么就是n这个数\n        return n;\n    }\n};\n```\n\n## 414. 第三大的数\n给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。\n\n**示例 1：**\n输入：[3, 2, 1]\n输出：1\n解释：第三大的数是 1 。\n\n**示例 2：**\n输入：[1, 2]\n输出：2\n解释：第三大的数不存在, 所以返回最大的数 2 。\n\n**示例 3：**\n输入：[2, 2, 3, 1]\n输出：1\n解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。\n此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。\n\n**提示：**\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1\n\n```cpp\nclass Solution {\npublic:\n\nint thirdMax(vector<int>& nums) {\n\t//对所给数组进行从小到大排序\n\tsort(nums.begin(), nums.end()); \n\n\tset<int> s;\n\tint len = nums.size();\n\tfor(int i=0; i<len; i++){\n\t\t//将元素加入无重复的集合中\n\t\ts.insert( nums[i] );\n\t}\t\n\n\t//清空vector\n\tnums.clear();\n\tfor(set<int>::iterator it=s.begin();it!=s.end();it++){\n\t\t//将集合中的元素 加入数组中\n\t\tnums.push_back(*it);\t\t\n\t} \n\t\n\t//如果数组的长度小于3 那么返回数组的最后一个元素\n\tif(nums.size()<3) return nums[nums.size()-1];\n\n\t//否则返回倒数第三个\n\treturn nums[nums.size()-3];\n}\n};\n\n\n```\n\n## 1004: 母牛的故事\n\n**题目描述**\n有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？\n\n**输入**\n输入数据由多个测试实例组成，每个测试实例占一行，包括**一个整数n(0<n<55)**，n的含义如题目中描述。\nn=0表示输入数据的结束，不做处理。\n\n**输出**\n对于每个测试实例，输出在第n年的时候母牛的数量。\n每个输出占一行。\n\n```cpp\n#include<iostream>\n#include<vector>\n#define N 100\nusing namespace std;\n\nint fun(int n){\n \tint a[N];\n \tint i;\n\t//避免索引错位 因此直接让a[1]=1...\n \tfor(int i=1; i<=4; i++){\n \t\ta[i] = i;\n\t}\n\t//索引从第五年开始 状态转移方程是 ai = ai-1 + ai-3\n\tfor(i=5; i<=n; i++){\n\t\ta[i] = a[i-1] + a[i-3];\n\t}\n\t\n\t//返回该数的数组位置\n\treturn a[n];\t\n}\n\nint main(){\n\tint y = 0;\n\twhile(cin >> y){\n\t\tif(y == 0)\n\t\t\tbreak;\n\t\tcout << fun(y) <<endl;\n\t}\n\treturn 0; \n}\n```\n\n## 434. 字符串中的单词数\n\n统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。\n\n请注意，你可以假定字符串里不包括任何不可打印的字符。\n\n**示例:**\n\n输入: \"Hello, my name is John\"\n输出: 5\n解释: 这里的单词是指连续的不是空格的字符，所以 \"Hello,\" 算作 1 个单词。\n\n```cpp\nclass Solution {\npublic:\n    int countSegments(string s) {\n  \t\t//flag stands for if it is the Number \n  \t    //count stands for the number of Num\n\t\tint flag=0,count = 0; \n\t\t\n\t\tfor(int i=0; s[i] != '\\0'; i++)\n\t\t{\n\t\t\tif(s[i] == ' '){\n\t\t\t\tflag = 0;\n\t\t\t}else if(flag == 0){\t\n                count++;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}\n\t  \treturn count;\n}\n};\n```\n\n## 392. 判断子序列\n\n给定字符串 s 和 t ，判断 s 是否为 t 的子序列。\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。\n\n**示例 1：**\n输入：s = \"abc\", t = \"ahbgdc\"\n输出：true\n\n**示例 2：**\n输入：s = \"axc\", t = \"ahbgdc\"\n输出：false\n \n**提示：**\n0 <= s.length <= 100\n0 <= t.length <= 10^4\n两个字符串都只由小写字符组成。\n\n```cpp\nclass Solution {\npublic:\nbool isSubsequence(string s, string t) {\n\tbool flag = true;\n\tint i,j = -1;\n\t\n\tfor(int i=0; s[i] != '\\0'; i++)\n\t{\n\t\t//从s中找各个字符 对应在t中的位置\n\t\tj = t.find(s[i]);\t\t\n\t\tif(j != string::npos){\n\t\t\t//如果没找到 就返回false \n\t\t\t//否则截取找到的位置 下一个位置到结束\n\t\t\t//继续往后找\n\t\t\tt = t.substr(j+1);\n\t\t}else{\n\t\t\tflag = false;\n\t\t\treturn flag;\t\t\t\n\t\t}\t\n\t}\n\treturn flag;\n}\n};\n```\n\n## 551. 学生出勤记录 I\n给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符：\n\n'A' : Absent，缺勤\n'L' : Late，迟到\n'P' : Present，到场\n如果一个学生的出勤记录中不超过一个'A'(缺勤)并且不超过两个连续的'L'(迟到),那么这个学生会被奖赏。\n\n你需要根据这个学生的出勤记录判断他是否会被奖赏。\n\n**示例 1:**\n输入: \"PPALLP\"\n输出: True\n\n**示例 2:**\n输入: \"PPALLL\"\n输出: False\n\n```cpp\nclass Solution {\npublic:\n   \nbool checkRecord(string s) {\n\tbool flag = false;\n\tint countA=0, countL=s.find(\"LLL\");\n\n\tfor(int i=0; i<s.size(); i++){\n\t\tif(s[i] == 'A'){\n\t\t\t//对于不用连续出现的A 通过统计即可\n            countA++;\n        }\n\t}\n\n\t//对于连续出现L 可以看成是否出现 不满足题目要求的“字串” \"LLL\"即可\n    if(countL==string::npos && countA <= 1){\n        flag = true;\n    }\n\treturn flag;\n}\n};\n```\n\n## 面试题 01.03. URL化\nURL化。编写一种方法，将字符串中的空格全部替换为%20。\n假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。\n（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）\n\n**示例 1：**\n输入：\"Mr John Smith    \", 13\n输出：\"Mr%20John%20Smith\"\n \n**示例 2：**\n输入：\"               \", 5\n输出：\"%20%20%20%20%20\"\n\n```cpp\nclass Solution {\npublic:\n   string replaceSpaces(string S, int length) {\n        string s = \"\"; //用一个新的字符串来装\n        for(int i=0; i<length; i++){\n            if(S[i] == ' '){\n                s += \"%20\";\n            }else{\n                s.push_back(S[i]);\n            }         \n        }\n        cout << s;\n        return s;\n    }\n};\n```\n\n## 459. 重复的子字符串(巧妙)\n给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。\n\n**示例 1:**\n输入: \"abab\"\n输出: True\n解释: 可由子字符串 \"ab\" 重复两次构成。\n\n**示例 2:**\n输入: \"aba\"\n输出: False\n\n**示例 3:**\n输入: \"abcabcabcabc\"\n输出: True\n解释: 可由子字符串 \"abc\" 重复四次构成。 (或者子字符串 \"abcabc\" 重复两次构成。)\n\n```cpp\nclass Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {  \n\t\t//如果是可用 子串重复 的串（比如abab）\n\t\t//那么本身轮回一圈后 下次找一定可以在 小于这个串长度的位置里\n\t\t//找到自身的串首次出现的位置\n\t\t\n\t\t//否则如果不是可重复的（比如ab）\n\t\t//本身轮回一圈后 下次再找到自己的串ab 一定不在自身的长度以内 abab\n\t\treturn (s + s).find(s, 1) != s.size();\n\t}\n};\n\n```\n\n## 506. 相对名次\n给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。\n前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"）。\n(注：分数越高的选手，排名越靠前。)\n\n示例 1:\n输入: [5, 4, 3, 2, 1]\n输出: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]\n解释: 前三名运动员的成绩为前三高的，因此将会分别被授予 “金牌”，“银牌”和“铜牌” (\"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\").\n余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。\n\n```cpp\nclass Solution {\npublic:\n    \nstatic bool cmp(int a, int b){\n\treturn a>b;\n}\n\nvector<string> findRelativeRanks(vector<int>& score) {\n\tvector<string> v;\n\tunordered_map<int, int> m;\n\tint num = 1; //根据分数 从高（第一名）到低进行排名\n\tstring gold = \"Gold Medal\";\n\tstring silver = \"Silver Medal\";\n\tstring bronze = \"Bronze Medal\";\n     \n\tvector<int> score1 = score; //新建一个数组 用来记录分数对应的名词\n\t\n\tsort(score1.begin(), score1.end(), cmp); //最高分的排在前面\n\n\tfor(int i=0; i<score1.size(); i++){\n\t\tm[score1[i]] = num++; //开始记录\n\t}\n\t\t\n\tfor(int i=0; i<score.size(); i++){\n\t\tint n = m[score[i]]; //根据自己的元素 原地取对应的排名 \n\n\t\t//修改前三名的string（金银铜）\n\t\tif(n == 1){\n\t\t\tv.push_back(gold);\n\t\t\tcontinue;\n\t\t}\n\t\tif(n == 2){\n\t\t\tv.push_back(silver);\n\t\t\tcontinue;\n\t\t}\n\t\tif(n == 3){\n\t\t\tv.push_back(bronze);\n\t\t\tcontinue;\n\t\t}\n\t\tv.push_back(to_string(n)); \n\t}\n\t\n\tfor(string str:v){\n\t\tcout << str << \" \";\n\t}\n\treturn v; \n}\n};\n\n```\n\n","tags":["C语言"],"categories":["经典C++算法"]}]